[ { "title": "创建 PVE debian cloud-init 模板", "url": "/linux/2023/08/04/creating-pve-debian-cloud-init-template/", "categories": "Linux", "tags": "Linux, PVE", "date": "2023-08-04 11:22:00 +0800", "snippet": "本文记录如何在 PVE 8.0.3 环境使用 debian 12 bookworm 的 cloud-init 镜像创建虚拟机模板，并进行一些定制化，例如预装一些常用软件包，修改 apt 源为国内镜像，和修改系统时区。下载镜像搜索 debian cloud init image 找到下载页面。有好几种镜像种类，看到页面描述：”generic: Should run in any environment using cloud-init, for e.g. OpenStack, DigitalOcean and also on bare metal.” ，应该下载这种镜像，因为有包含了 cloud-init.我们要下载 debian 12 bookworm，所以进入到 bookworm 的目录，再进入到 latest然后选择下载适合 PVE 节点具体架构的镜像版本，这里我选的是 debian-12-generic-amd64 的镜像，qcow2 是 qemu 支持导入的磁盘镜像格式。下载时候可以直接在 PVE 节点的终端里面 wget https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2 ，就不用下载完再传到 PVE，节省些时间。创建虚拟机并导入镜像这部分很多命令都是可以用等效的 Web UI 操作完成，不过为了简洁，就主要列出命令行方式。创建虚拟机创建一个新的虚拟机qm create 9000 --memory 2048 --core 2 --name debian-12-template --net0 virtio,bridge=vmbr0这里是创建 id 为 9000 的虚拟机，内存大小为 2G ， CPU 核心数量 2，名称是 debian-12-template 并设置网卡 net0 桥接到 vmbr0。然后将下载好的 debian 12 cloud init 镜像导入给刚创建的虚拟机，并且指定存储在 local-lvmqm importdisk 9000 debian-12-generic-amd64.qcow2 local-lvm将新导入的磁盘以 scsi 驱动器的方式装载到新建的虚拟机的 scsi 控制器qm set 9000 --scsihw virtio-scsi-pci --scsi0 local-lvm:vm-9000-disk-0添加 cloud init CD ROM 驱动器，用于提供 Cloud-init 参数给虚拟机。qm set 9000 --ide2 local-lvm:cloudinit将导入了 debian-12 镜像的那个磁盘设置为可启动并限制 BIOS 仅从该磁盘启动qm set 9000 --boot c --bootdisk scsi0设置串口控制台，因为某些 Cloud init 镜像可能要求要有串口控制台，如果用不了，那么可以切换回默认显示设备。qm set 9000 --serial0 socket --vga serial0这时候，如果不启动虚拟机，那么就可以将这个配置好的虚拟机转成模板了。但是因为还想给虚拟机预安装一些常用的工具包和配置 apt 源镜像等操作，所以现在启动虚拟机进行配置，但是虚拟机一旦启动，就会生成 machine-id ，以及留下其他的一些使用痕迹，但是主要有影响的是 machine-id，因为 DHCP 过程会根据这个 machine-id 分配 IP 的。如果在将已经启动过的虚拟机，并且没有清除掉 machine-id 就转成模板的话。后面创建的虚拟机会有同样的 machine-id，DHCP 的时候就是分配到同样的 IP（但是只有一个虚拟机能正常使用被分配的 IP），这就好造成一些不必要的麻烦。所以我们启动虚拟机并做完更改之后，要记得使用命令 sudo truncate -s /etc/machine-id /var/lib/dbus/machine-id 移除 machine-id，不能直接删除 machine-id 文件，但是可以清空内容。因为如果删除了文件，重启是不会重新生成，也是一个问题。如果不小心删除了，可以使用命令 sudo systemd-machine-id-setup 生成回来。预装软件和配置安装常用软件包sudo apt install -y htop qemu-guest-agent dnsutils tree acpid htop 查看进程 qemu-guest-agent 宿主机代理，搜集虚拟机信息(IP，主机名等) nslookup DNS 调试 dig DNS 调试 tree 方便浏览目录配置时区修改 /etc/cloud/cloud.cfg ，在底下添加ntp: enabled: truetimezone: Asia/Shanghai在 system_info 的 package_mirrors 那里还可以修改使用的源 mirrorssystem_info: package_mirrors: - arches: [default] failsafe: primary: https://deb.debian.org/debian security: https://deb.debian.org/debian-security不过目前是在 /etc/apt/mirrors/ 里面的文件修改，直接替换成阿里云的镜像地址：# debian.listhttps://mirrors.aliyun.com/debian# debian-security.listhttps://mirrors.aliyun.com/debian-security还有一个地方需要改，就是 /etc/cloud/cloud.cfg.d/01_debian_cloud.cfgapt: generate_mirrorlists: false改成 false，修改就不会被覆盖掉，前面两个地方的改动是有关的，如果改了生成镜像列表的地址，应该就不用将这个改成 false 不过手动修改，并改成 false 也可以。这样虚拟机就配置好了，清除 machine-id 关机就可以。转成虚拟机模板qm template 9000之后就可以由这个模板创建出新的虚拟机了。" }, { "title": "允许高版本 maven 使用 http 私有仓库", "url": "/java/2023/03/23/maven-default-http-blocker-override/", "categories": "Java", "tags": "Java, Maven", "date": "2023-03-23 17:58:00 +0800", "snippet": "高版本的 maven 默认会阻止使用 http 协议，仅支持 https 协议。但是如果本地网络私有仓库有 maven 的包，需要用到 http 的 repository例如在工程的 pom.xml 文件里面，假设是这样的：&lt;repositories&gt; &lt;repository&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;libs-release&lt;/name&gt; &lt;url&gt;http://my-url/libs-release&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;name&gt;libs-snapshot&lt;/name&gt; &lt;url&gt;http://my-url/libs-snapshot&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;那么，需要在本地的 ~/.m2/settings.xml 或者 .mvn/local-settings.xml 里面设置以下内容，以允许使用 http 协议的私有仓库：&lt;settings&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;release-http-unblocker&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;&lt;/name&gt; &lt;url&gt;http://my-url/libs-release&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;snapshot-http-unblocker&lt;/id&gt; &lt;mirrorOf&gt;snapshots&lt;/mirrorOf&gt; &lt;name&gt;&lt;/name&gt; &lt;url&gt;http://my-url/libs-snapshot&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt;其中，&lt;mirrorOf&gt; 标签填，pom.xml 里面定义的私有仓库的 id ，然后 &lt;url 填原来被镜像的 url （即默认被 block 的那个 http url）这样设置完，就可以跳过高版本强制使用 https 协议导致的报错。" }, { "title": "在 ESXi 使用 Cloud-init 安装系统的例子", "url": "/linux/2023/03/20/esxi-cloud-init-example/", "categories": "Linux", "tags": "Linux", "date": "2023-03-20 22:16:00 +0800", "snippet": "在 pve 使用 cloud-init 镜像 相对来说简单一些，要在 ESXi 中使用 cloud-init 镜像，步骤就繁琐一点。本文记录一下在 ESXi-7.0U3f-20036589-standard 中使用 cloud-init 镜像安装并配置 Ubuntu Server Jammy 的步骤。下载 VMDK 文件首先去 Ubuntu 的 cloud-images 网站下载对应版本的 VMDK 文件，用于 ESXi 新创建的虚拟机磁盘。创建虚拟机将 VMDK 上传到 ESXi 的存储目录，一路按默认步骤创建虚拟机，去到自定义设置的时候，删掉默认设置的硬盘。虚拟机创建好之后，在存储浏览器那里可以看到有个以虚拟机名称命名的目录。将 VMDK 文件复制一份到这个目录里面作为这个新建的虚拟机的硬盘。用复制而不是直接移动过去，是为了可以之后可以继续复用这个 VMDK.添加 Cloud-init 磁盘到新建的虚拟机在 ESXi 虚拟机的配置添加 cloud-init 的磁盘镜像作为虚拟机硬盘即可。 留意，一般保存配置之后，回头在编辑才可以修改磁盘空间大小。修改虚拟机设置，添加 Cloud-init userdata编辑新创建的虚拟机的选项，在【高级】-【配置参数】那里编辑配置，添加两个参数：guestinfo.userdata.encoding 和 guestinfo.userdata。其值分别是 ‘base64’，表示数据的类型是 base64 格式，和 userdata cloud-init 配置的 yaml 内容的 base64 后字符串。例如，一个最小配置的 userdata yaml 像这样：#cloud-configusers: - name: tao # passwd: $6$rounds=4096$4Jh2rwf9h2jM9TbQ$.CTSPJPIoIOUwKVo4A2Er19Deu945m/oD.JXVEGNH9g/piK.motblke/kpyPQ0npNKF.jZjzi61ZSBPGNbJyK/ plain_text_passwd: youPassword groups: sudo sudo: ALL=(ALL) NOPASSWD:ALL shell: /bin/bash lock_passwd: false注意 userdata 的 yml 文件开头的 #cloud-config 是必须的。以上最小配置，会创建一个用户。这样至少可以登录到系统。 默认 Cloud images 五百多个 MB，扩展磁盘 Cloud-init 初始化时候一般会扩展到最大可用空间。其实 Cloud-init 启动过程有一些 modules 可以在 /etc/cloud/cloud.cfg 配置的。 而且可以自定义一些配置操作，让 Cloud-init 去运行，例如，配置时区。可以在文件最后添加：timezone: Asia/Shanghai然后我们需要清理一下 Cloud-init, 使用以下命令：sudo cloud-init clean --logs先查看一下当前时区设置（默认应该是 UTC），用命令 timedatectl 查看。之后运行以下命令，应用 cloud-init 的改动：sudo cloud-init single --name cc_timezone效果如下图：配置需要安装的包要通过 cloud-init 配置系统初次启动后额外安装的一些包，例如常用的 docker，可以使用以下配置：#cloud-config# hostnamehostname: Oxmanage_etc_hosts: truechpasswd: expire: False# enable ntpntp: enabled: true# timezonetimezone: Asia/Shanghai# disable root login via sshdisable_root: true# optional, additional groupsgroups: # because we gonna install docker - dockerusers: - name: tao # allows password authnetication when set to false, true by default lock_passwd: False # password hash, created by `mkpasswd --method=SHA-512 --rounds=4096`, read the docs before complaining security against plain # passwd: $6$rounds=4096$4Jh2rwf9h2jM9TbQ$.CTSPJPIoIOUwKVo4A2Er19Deu945m/oD.JXVEGNH9g/piK.motblke/kpyPQ0npNKF.jZjzi61ZSBPGNbJyK/ # alternative approach with plain text password plain_text_passwd: youPassword ssh_authorized_keys: - ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIMOTan+yolWwBH4HKkVd6Y2OKzGGeJLijGGSd1NzuMSp Grace groups: - adm - cdrom - sudo - dip - plugdev - lxd # add user to docker group - docker sudo: # allow sudo - ALL=(ALL) NOPASSWD:ALL shell: /bin/bash# optional, additional apt sources, dockerapt: sources: docker.list: source: deb [arch=amd64] https://download.docker.com/linux/ubuntu $RELEASE stable keyid: 9DC858229FC7DD38854AE2D88D81803C0EBFCD88# apt update &amp;&amp; apt upgrade, reboot if neededpackage_update: truepackage_upgrade: truepackage_reboot_if_required: true# install packagespackages: - docker-ce - docker-ce-cli - containerd.io添加 metadata 部分，控制虚拟机网络初始化最常用的 Cloud-init 场景就是给虚拟机设置固定 ip，关于网络的设置，在 cloud-init 属于metadata 部分。所以需要在虚拟机配置那里另外添加两组 key-value:guestinfo.metadata.encoding 和 guestinfo.metadata。其值分别是 ‘base64’，表示数据的类型是 base64 格式，和 metadata cloud-init 配置的 yaml 内容的 base64 后字符串。例子如下：network: version: 1 config: - type: physical name: ens160 subnets: - type: static address: '192.168.3.222' netmask: '255.255.255.0' gateway: '192.168.3.1' - type: nameserver address: - '172.17.11.80' search: - 'linuxfield.com'这部分不强制要求文件开头要有 #cloud-config，上面内容是使用 version 1 网络配置，没那么灵活，但是也适合没有使用 netplan 的 Linux 发行版。在 pve 的虚拟机 cloud-init 配置里面，可以通过命令 qm cloudinit dump [虚拟机 id] [配置类型] 查看。例如查看虚拟机 100 的 网络配置：这样就可以参考 pve 的 cloud-init 配置，在 ESXi 上也使用类似的配置。最后是 ESXi cloud-init 配置固定 IP 的效果图：完。" }, { "title": "Linux 的 chattr 命令用途", "url": "/linux/2023/03/08/linux-chattr-command-usage/", "categories": "Linux", "tags": "Linux", "date": "2023-03-08 09:53:00 +0800", "snippet": "第一次使用 chattr 应该是在 安装Spring Boot应用作为系统服务 里： 如果被黑了，黑客可以将 jar 文件设为可写的并修改它的内容。其中一种防护方式是将它设置为不可修改的，通过使用 chattr 命令，命令如下：$ sudo chattr +i your-app.jar这会防止任何用户，包括 root 修改 jar 的内容。所以本文就列举一下 chttr 的用途。最常用的一般会使用 sudo chattr +i 文件名 来将某个文件设为不可修改，连 root 也不能修改。 man page 说明如下： i A file with the ‘i’ attribute cannot be modified: it cannot be deleted or renamed, no link can be created to this file, most of the file’s metadata can not be modified, and the file can not be opened in write mode. Only the superuser or a process possessing the CAP_LINUX_IMMUTABLE capability can set or clear this attribute.移除这个 i 属性，可以使用 sudo chattr -i 文件名 操作。查看文件属性可以使用 lsattr 命令列出文件的属性。 例如：ubuntu@zwt:~$ lsattr Hello.java--------------e------- Hello.javaubuntu@zwt:~$ sudo chattr +i Hello.javaubuntu@zwt:~$ lsattr Hello.java----i---------e------- Hello.javaubuntu@zwt:~$ echo \"class B {}\" &gt;&gt; Hello.java-bash: Hello.java: Operation not permittedubuntu@zwt:~$ sudo chattr -i Hello.javaubuntu@zwt:~$ echo \"class B {}\" &gt;&gt; Hello.javaubuntu@zwt:~$ java Hello.javaHello Worldubuntu@zwt:~$" }, { "title": "在 pve 使用 cloud-init 镜像", "url": "/virtualization/2023/02/24/proxmox-cloud-init-images/", "categories": "Virtualization", "tags": "Virtualization, Cloud-init", "date": "2023-02-24 14:20:00 +0800", "snippet": "使用 cloud images 和 cloud-init 可以很方便地在 pve 创建一个快捷高效的虚拟机克隆模板。首先选择自己偏好的 cloud image，例如 Ubuntu 的可以在 Ubuntu cloud init 镜像 下载， CentOS 的可以在 Centos cloud images 下载。提供下载的镜像有好几种格式， ubuntu 的一般用 img 就可以，centos 下载 qcow2c 就可以，后面导入的时候都会转换成 raw 格式。下载好所需的镜像之后（假设下载的是 jammy-server-cloudimg-amd64.img ），就开始按以下步骤制作虚拟机模板：创建一个新的虚拟机qm create 8000 --memory 2048 --core 2 --name ubuntu-cloud --net0 virtio,bridge=vmbr0这里是创建 id 为 8000 的虚拟机，内存大小为 2G ， CPU 核心数量 2，名称是 ubuntu-cloud 并设置网卡桥接到 vmbr0导入下载好的云镜像到 local-lvm 存储qm importdisk 8000 jammy-server-cloudimg-amd64.img local-lvm将新导入的磁盘以 scsi 驱动器的方式装载到新建的虚拟机的 scsi 控制器qm set 8000 --scsihw virtio-scsi-pci --scsi0 local-lvm:vm-8000-disk-0添加 cloud init 驱动器qm set 8000 --ide2 local-lvm:cloudinit将 cloud init 驱动器设置为可启动并限制 BIOS 仅从磁盘启动qm set 8000 --boot c --bootdisk scsi0添加串口控制台qm set 8000 --serial0 socket --vga serial0现在先不要启动虚拟机现在可以配置新虚拟机的硬件和 cloud init 选项，配置好之后转换成模板。磁盘大小的调整可以在转换成模板前调整，或者从模板克隆出新的虚拟机时候再调整。创建模板（也可以在 Web UI 操作）qm template 8000克隆模板（也可以在 Web UI 操作）qm clone 8000 135 --name huihui --full排障如果需要重置机器 idsudo rm -f /etc/machine-idsudo rm -f /var/lib/dbus/machine-id然后关机，下次启动会生成新的机器 id，如果没有生成，可以运行以下命令：sudo systemd-machine-id-setup" }, { "title": "在 Ubuntu 安装 MinIO", "url": "/minio/2022/07/25/install-minio-on-ubuntu/", "categories": "MinIO", "tags": "MinIO", "date": "2022-07-25 20:56:00 +0800", "snippet": "使用 Linux 二进制文件安装 MinIO使用以下命令在 macOS 上下载并运行独立的 MinIO 服务器。 将/data 替换为您希望 MinIO 存储数据的驱动器或目录的路径。wget http://dl.minio.org.cn/server/minio/release/darwin-amd64/miniochmod +x minio./minio server /data不过现在一般都容器化安装了。" }, { "title": "安装 Proxmox VE", "url": "/virtualization/2022/07/22/installing-proxmox/", "categories": "Virtualization", "tags": "Virtualization", "date": "2022-07-22 23:26:00 +0800", "snippet": " 记录安装 Proxmox VE 过程从 ISO 镜像制作启动 U 盘liuhuaqiang@shuiguotan:~$ sudo dd bs=1M conv=fdatasync if=./proxmox-ve_7.2-1.iso of=/dev/sdb994+1 records in994+1 records out1042497536 bytes (1.0 GB, 994 MiB) copied, 80.7667 s, 12.9 MB/s" }, { "title": "MySQL Max connect timeout reached 错误排查", "url": "/mysql/2022/07/22/MySQL-max-connect-timeout-reached/", "categories": "MySQL", "tags": "MySQL", "date": "2022-07-22 17:40:00 +0800", "snippet": " 线上环境遇到过 ‘java.sql.SQLException: Max connect timeout reached while reaching hostgroup 0 after 10000ms’ 这样的错误，记录一下事故排查过程。事故情况描述及紧急处理当天下午 5 点左右，收到投诉说用户登入不了网站，管理后台有发现 Max connect timeout reached while reaching hostgroup 0 after 10000ms 错误，大概可以判断是因为数据库连接问题导致所有用到数据库查询的 API 都出现了这个错误，所以网站、管理后台、Apps都登录不上。MySQL 达到最大连接超时错误紧急处理就是将新服务先停掉，以免影响到原先正常的服务。Hikari CP 数据库连接池配置检查初步怀疑是新上线的一个服务的 Hikari CP 配置项不恰当导致出现这样的问题。先看看当时正式环境的 Spring Boot 配置文件里面关于 Hikari CP 的配置参数：spring: datasource: hikari: poolName: Hikari auto-commit: false minimum-idle: 100 maximum-pool-size: 200 data-source-properties: cachePrepStmts: true prepStmtCacheSize: 250 prepStmtCacheSqlLimit: 2048 useServerPrepStmts: true这个跟以往使用的配置，或者说跟 JHipster 默认的配置有点点区别。主要是显式指定了 minimum-idle 和 maximum-pool-size 的值。 下面说说这两个参数的作用，根据 HikariCP GitHub: 🔢minimumIdleThis property controls the minimum number of idle connections that HikariCP tries to maintain in the pool. If the idle connections dip below this value and total connections in the pool are less than maximumPoolSize, HikariCP will make a best effort to add additional connections quickly and efficiently. However, for maximum performance and responsiveness to spike demands, we recommend not setting this value and instead allowing HikariCP to act as a fixed size connection pool. Default: same as maximumPoolSize这个属性控制 HikariCP 在池中尝试维护的最小空闲连接数量。如果空闲连接数低于这个值，并且在池中的总连接数少于 maximumPoolSize 的值， HikariCP 会尽可能迅速和高效地添加另外的连接。然而，为了最大化性能和对于对突增请求的响应性，我们建议不设置这个值，而让 HikariCP 去作为一个固定大小连接池。默认：同 maximumPoolSize 。所以没有必要设置 minimumIdle 的值。接下来看看 maximum-pool-size 的用途： 🔢maximumPoolSizeThis property controls the maximum size that the pool is allowed to reach, including both idle and in-use connections. Basically this value will determine the maximum number of actual connections to the database backend. A reasonable value for this is best determined by your execution environment. When the pool reaches this size, and no idle connections are available, calls to getConnection() will block for up to connectionTimeout milliseconds before timing out. Please read about pool sizing. Default: 10这个属性控制连接池能达到的最大大小，包括空闲和正在使用的连接。基本上这个值会决定与数据库后端连接的实际最大数量。一个合理的值最好取决于你的程序执行环境。当连接池达到这个大小，并且没有空闲连接可用，调用 getConnection() 会阻塞直至 connectionTimeout 毫秒直到超时。请看关于连接池大小。默认：10Hikari CP 常用配置属性（GitHub README）HikariCP comes with sane defaults that perform well in most deployments without additional tweaking. Every property is optional, except for the “essentials” marked below.📎 HikariCP uses milliseconds for all time values.🚨 HikariCP relies on accurate timers for both performance and reliability. It is imperative that your server is synchronized with a time-source such as an NTP server. Especially if your server is running within a virtual machine. Why? Read more here. Do not rely on hypervisor settings to “synchronize” the clock of the virtual machine. Configure time-source synchronization inside the virtual machine. If you come asking for support on an issue that turns out to be caused by lack time synchronization, you will be taunted publicly on Twitter.Essentials🔤dataSourceClassNameThis is the name of the DataSource class provided by the JDBC driver.这是 JDBC 驱动提供的的 DataSource 实现类的名称。Consult thedocumentation for your specific JDBC driver to get this class name, or see the table below.请查阅你所用的特定 JDBC 驱动的文档去找到这个类的名称，或者看看下方的表格。Note XA data sources are not supported. XA requires a real transaction manager likebitronix. Note that you do not need this property if you are usingjdbcUrl for “old-school” DriverManager-based JDBC driver configuration.Default: none- or -🔤jdbcUrlThis property directs HikariCP to use “DriverManager-based” configuration. We feel that DataSource-basedconfiguration (above) is superior for a variety of reasons (see below), but for many deployments there islittle significant difference. When using this property with “old” drivers, you may also need to setthe driverClassName property, but try it first without. Note that if this property is used, you maystill use DataSource properties to configure your driver and is in fact recommended over driver parametersspecified in the URL itself.Default: none🔤usernameThis property sets the default authentication username used when obtaining Connections fromthe underlying driver. Note that for DataSources this works in a very deterministic fashion bycalling DataSource.getConnection(*username*, password) on the underlying DataSource. However,for Driver-based configurations, every driver is different. In the case of Driver-based, HikariCPwill use this username property to set a user property in the Properties passed to thedriver’s DriverManager.getConnection(jdbcUrl, props) call. If this is not what you need,skip this method entirely and call addDataSourceProperty(\"username\", ...), for example.Default: none🔤passwordThis property sets the default authentication password used when obtaining Connections fromthe underlying driver. Note that for DataSources this works in a very deterministic fashion bycalling DataSource.getConnection(username, *password*) on the underlying DataSource. However,for Driver-based configurations, every driver is different. In the case of Driver-based, HikariCPwill use this password property to set a password property in the Properties passed to thedriver’s DriverManager.getConnection(jdbcUrl, props) call. If this is not what you need,skip this method entirely and call addDataSourceProperty(\"pass\", ...), for example.Default: noneFrequently used✅autoCommitThis property controls the default auto-commit behavior of connections returned from the pool.It is a boolean value.Default: true⏳connectionTimeoutThis property controls the maximum number of milliseconds that a client (that’s you) will waitfor a connection from the pool. If this time is exceeded without a connection becomingavailable, a SQLException will be thrown. Lowest acceptable connection timeout is 250 ms.Default: 30000 (30 seconds)⏳idleTimeoutThis property controls the maximum amount of time that a connection is allowed to sit idle in thepool. This setting only applies when minimumIdle is defined to be less than maximumPoolSize.Idle connections will not be retired once the pool reaches minimumIdle connections. Whether aconnection is retired as idle or not is subject to a maximum variation of +30 seconds, and averagevariation of +15 seconds. A connection will never be retired as idle before this timeout. A valueof 0 means that idle connections are never removed from the pool. The minimum allowed value is 10000ms(10 seconds).Default: 600000 (10 minutes)⏳keepaliveTimeThis property controls how frequently HikariCP will attempt to keep a connection alive, in order to preventit from being timed out by the database or network infrastructure. This value must be less than themaxLifetime value. A “keepalive” will only occur on an idle connection. When the time arrives for a “keepalive”against a given connection, that connection will be removed from the pool, “pinged”, and then returned to thepool. The ‘ping’ is one of either: invocation of the JDBC4 isValid() method, or execution of theconnectionTestQuery. Typically, the duration out-of-the-pool should be measured in single digit millisecondsor even sub-millisecond, and therefore should have little or no noticible performance impact. The minimumallowed value is 30000ms (30 seconds), but a value in the range of minutes is most desirable.Default: 0 (disabled)⏳maxLifetimeThis property controls the maximum lifetime of a connection in the pool. An in-use connection willnever be retired, only when it is closed will it then be removed. On a connection-by-connectionbasis, minor negative attenuation is applied to avoid mass-extinction in the pool. We strongly recommendsetting this value, and it should be several seconds shorter than any database or infrastructure imposedconnection time limit. A value of 0 indicates no maximum lifetime (infinite lifetime), subject ofcourse to the idleTimeout setting. The minimum allowed value is 30000ms (30 seconds).Default: 1800000 (30 minutes)🔤connectionTestQueryIf your driver supports JDBC4 we strongly recommend not setting this property. This is for“legacy” drivers that do not support the JDBC4 Connection.isValid() API. This is the query thatwill be executed just before a connection is given to you from the pool to validate that theconnection to the database is still alive. Again, try running the pool without this property,HikariCP will log an error if your driver is not JDBC4 compliant to let you know.Default: none🔢minimumIdleThis property controls the minimum number of idle connections that HikariCP tries to maintainin the pool. If the idle connections dip below this value and total connections in the pool are less than maximumPoolSize,HikariCP will make a best effort to add additional connections quickly and efficiently.However, for maximum performance and responsiveness to spike demands,we recommend not setting this value and instead allowing HikariCP to act as a fixed size connection pool.Default: same as maximumPoolSize🔢maximumPoolSizeThis property controls the maximum size that the pool is allowed to reach, including bothidle and in-use connections. Basically this value will determine the maximum number ofactual connections to the database backend. A reasonable value for this is best determinedby your execution environment. When the pool reaches this size, and no idle connections areavailable, calls to getConnection() will block for up to connectionTimeout millisecondsbefore timing out. Please read about pool sizing.Default: 10📈metricRegistryThis property is only available via programmatic configuration or IoC container. This propertyallows you to specify an instance of a Codahale/Dropwizard MetricRegistry to be used by thepool to record various metrics. See the Metricswiki page for details.Default: none📈healthCheckRegistryThis property is only available via programmatic configuration or IoC container. This propertyallows you to specify an instance of a Codahale/Dropwizard HealthCheckRegistry to be used by thepool to report current health information. See the Health Checkswiki page for details.Default: none🔤poolNameThis property represents a user-defined name for the connection pool and appears mainlyin logging and JMX management consoles to identify pools and pool configurations.Default: auto-generatedInfrequently used⏳initializationFailTimeoutThis property controls whether the pool will “fail fast” if the pool cannot be seeded withan initial connection successfully. Any positive number is taken to be the number ofmilliseconds to attempt to acquire an initial connection; the application thread will beblocked during this period. If a connection cannot be acquired before this timeout occurs,an exception will be thrown. This timeout is applied after the connectionTimeoutperiod. If the value is zero (0), HikariCP will attempt to obtain and validate a connection.If a connection is obtained, but fails validation, an exception will be thrown and the poolnot started. However, if a connection cannot be obtained, the pool will start, but laterefforts to obtain a connection may fail. A value less than zero will bypass any initialconnection attempt, and the pool will start immediately while trying to obtain connectionsin the background. Consequently, later efforts to obtain a connection may fail.Default: 1❎isolateInternalQueriesThis property determines whether HikariCP isolates internal pool queries, such as theconnection alive test, in their own transaction. Since these are typically read-onlyqueries, it is rarely necessary to encapsulate them in their own transaction. Thisproperty only applies if autoCommit is disabled.Default: false❎allowPoolSuspensionThis property controls whether the pool can be suspended and resumed through JMX. This isuseful for certain failover automation scenarios. When the pool is suspended, calls togetConnection() will not timeout and will be held until the pool is resumed.Default: false❎readOnlyThis property controls whether Connections obtained from the pool are in read-only mode bydefault. Note some databases do not support the concept of read-only mode, while others providequery optimizations when the Connection is set to read-only. Whether you need this propertyor not will depend largely on your application and database.Default: false❎registerMbeansThis property controls whether or not JMX Management Beans (“MBeans”) are registered or not.Default: false🔤catalogThis property sets the default catalog for databases that support the concept of catalogs.If this property is not specified, the default catalog defined by the JDBC driver is used.Default: driver default🔤connectionInitSqlThis property sets a SQL statement that will be executed after every new connection creationbefore adding it to the pool. If this SQL is not valid or throws an exception, it will betreated as a connection failure and the standard retry logic will be followed.Default: none🔤driverClassNameHikariCP will attempt to resolve a driver through the DriverManager based solely on the jdbcUrl,but for some older drivers the driverClassName must also be specified. Omit this property unlessyou get an obvious error message indicating that the driver was not found.Default: none🔤transactionIsolationThis property controls the default transaction isolation level of connections returned fromthe pool. If this property is not specified, the default transaction isolation level definedby the JDBC driver is used. Only use this property if you have specific isolation requirements that arecommon for all queries. The value of this property is the constant name from the Connectionclass such as TRANSACTION_READ_COMMITTED, TRANSACTION_REPEATABLE_READ, etc.Default: driver default⏳validationTimeoutThis property controls the maximum amount of time that a connection will be tested for aliveness.This value must be less than the connectionTimeout. Lowest acceptable validation timeout is 250 ms.Default: 5000⏳leakDetectionThresholdThis property controls the amount of time that a connection can be out of the pool before amessage is logged indicating a possible connection leak. A value of 0 means leak detectionis disabled. Lowest acceptable value for enabling leak detection is 2000 (2 seconds).Default: 0➡dataSourceThis property is only available via programmatic configuration or IoC container. This propertyallows you to directly set the instance of the DataSource to be wrapped by the pool, rather thanhaving HikariCP construct it via reflection. This can be useful in some dependency injectionframeworks. When this property is specified, the dataSourceClassName property and allDataSource-specific properties will be ignored.Default: none🔤schemaThis property sets the default schema for databases that support the concept of schemas.If this property is not specified, the default schema defined by the JDBC driver is used.Default: driver default➡threadFactoryThis property is only available via programmatic configuration or IoC container. This propertyallows you to set the instance of the java.util.concurrent.ThreadFactory that will be usedfor creating all threads used by the pool. It is needed in some restricted execution environmentswhere threads can only be created through a ThreadFactory provided by the application container.Default: none➡scheduledExecutorThis property is only available via programmatic configuration or IoC container. This propertyallows you to set the instance of the java.util.concurrent.ScheduledExecutorService that willbe used for various internally scheduled tasks. If supplying HikariCP with a ScheduledThreadPoolExecutorinstance, it is recommended that setRemoveOnCancelPolicy(true) is used.Default: noneMissing KnobsHikariCP has plenty of “knobs” to turn as you can see above, but comparatively less than some other pools.This is a design philosophy. The HikariCP design aesthetic is Minimalism. In keeping with thesimple is better or less is more design philosophy, some configuration axis are intentionally left out.Statement CacheMany connection pools, including Apache DBCP, Vibur, c3p0 and others offer PreparedStatement caching.HikariCP does not. Why?At the connection pool layer PreparedStatements can only be cached per connection. If your applicationhas 250 commonly executed queries and a pool of 20 connections you are asking your database to hold on to5000 query execution plans – and similarly the pool must cache this many PreparedStatements and theirrelated graph of objects.Most major database JDBC drivers already have a Statement cache that can be configured, including PostgreSQL,Oracle, Derby, MySQL, DB2, and many others. JDBC drivers are in a unique position to exploit database specificfeatures, and nearly all of the caching implementations are capable of sharing execution plans across connections.This means that instead of 5000 statements in memory and associated execution plans, your 250 commonly executedqueries result in exactly 250 execution plans in the database. Clever implementations do not even retainPreparedStatement objects in memory at the driver-level but instead merely attach new instances to existing plan IDs.Using a statement cache at the pooling layer is an anti-pattern,and will negatively impact your application performance compared to driver-provided caches.Log Statement Text / Slow Query LoggingLike Statement caching, most major database vendors support statement logging throughproperties of their own driver. This includes Oracle, MySQL, Derby, MSSQL, and others. Someeven support slow query logging. For those few databases that do not support it, several options are available.We have received a report that p6spy works well,and also note the availability of log4jdbc and jdbcdslog-exp.Rapid RecoveryPlease read the Rapid Recovery Guide for details on how to configure your driver and system for proper recovery from database restart and network partition events." }, { "title": "Linux fdisk 命令使用", "url": "/linux/2022/07/22/linux-fdisk-demo/", "categories": "Linux", "tags": "Linux, disk partition", "date": "2022-07-22 15:34:00 +0800", "snippet": "使用 fdisk 命令查看磁盘分区如下：liuhuaqiang@shuiguotan:~$ sudo fdisk -l /dev/sdbDisk /dev/sdb: 1.9 GiB, 2013265920 bytes, 3932160 sectorsDisk model: Flash DiskUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0x339542e9Device Boot Start End Sectors Size Id Type/dev/sdb1 * 512 33279 32768 16M 83 Linux/dev/sdb2 33792 558079 524288 256M 83 Linux" }, { "title": "查询 Linux 内存信息", "url": "/linux/2022/07/22/query-linux-memory-info/", "categories": "Linux", "tags": "Linux, Hardware", "date": "2022-07-22 13:00:00 +0800", "snippet": "使用 dmidecode 查看内存信息首先看系统是否已经安装 dmidecode:dmidecode --help如果已经有安装，会见到类似以下输出：Usage: dmidecode [OPTIONS]Options are: -d, --dev-mem FILE Read memory from device FILE (default: /dev/mem) -h, --help Display this help text and exit -q, --quiet Less verbose output -s, --string KEYWORD Only display the value of the given DMI string -t, --type TYPE Only display the entries of given type -H, --handle HANDLE Only display the entry of given handle -u, --dump Do not decode the entries --dump-bin FILE Dump the DMI data to a binary file --from-dump FILE Read the DMI data from a binary file --no-sysfs Do not attempt to read DMI data from sysfs files --oem-string N Only display the value of the given OEM string -V, --version Display the version and exit接下来是一些具体使用例子：查看内存插槽数量，已使用几个插槽，每条内存多大$ sudo dmidecode | grep -A5 \"Memory Device\" | grep Size | grep -v Range Size: No Module Installed Size: 8192 MB Size: No Module Installed Size: No Module Installed查看内存频率liuhuaqiang@shuiguotan:~$ sudo dmidecode | grep -A16 \"Memory Device\" | grep 'Speed' Speed: Unknown Speed: 1600 MT/s Speed: Unknown Speed: Unknown" }, { "title": "Portainer 简单上手", "url": "/container/2022/07/04/getting-started-with-portainer/", "categories": "Container", "tags": "Portainer, Docker", "date": "2022-07-04 02:05:00 +0800", "snippet": "Docker 单机安装 Portainer首先在 Docker 创建一个 Volume 用来存放它的数据库：docker volume create portainer_data然后下载并安装 Portainer Server 容器：docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker/sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest" }, { "title": "Spring Cloud OpenFeign 文档学习记录", "url": "/spring/2022/06/27/spring-cloud-OpenFeign/", "categories": "Spring", "tags": "Spring, http", "date": "2022-06-27 02:01:00 +0800", "snippet": " 本文涉及 Spring Cloud OpenFeign 的版本为 3.1.3Spring Cloud OpenFeign 通过自动装配和绑定为 Spring Boot 应用提供了 OpenFeign 在 Spring 环境及其他 Spring　编程模型中使用的集成。1. 声明式 REST 客户端：FeignFeign 是一种声明式 Web 服务客户端。它使得编写 Web 服务客户端更简单。要使用 Feign 只需创建一个接口并加上注解就可以了。它具有可插拔的注解支持，包括 Feign 本身的注解已经 JAX-RS 标准的注解。同时 Feign 也支持可插拔的编码器和解码器。 Spring Cloud (为 Feign) 添加了 Spring MVC 注解支持，并且使用了在 Spring Web 中一样的的默认 HttpMessageConverters 注解。 Spring Cloud集成了 Eureka，Spring Cloud CircuitBreaker 以及 Spring Cloud LoadBalancer 以便在使用 Feign 时候可以提供一种经过负载均衡了的客户端。1.1 如何引入 Feign在你的工程中使用 group 为 org.springframework.cloud 并且 artifact id 是 spring-cloud-starter-openfeign 的依赖。简单代码示例：@SpringBootApplication@EnableFeignClientspublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }}StoreClient.java@FeignClient(\"stores\")public interface StoreClient { @RequestMapping(method = RequestMethod.GET, value = \"/stores\") List&lt;Store&gt; getStores(); @RequestMapping(method = RequestMethod.GET, value = \"/stores\") Page&lt;Store&gt; getStores(Pageable pageable); @RequestMapping(method = RequestMethod.POST, value = \"/stores/{storeId}\", consumes = \"application/json\") Store update(@PathVariable(\"storeId\") Long storeId, Store store); @RequestMapping(method = RequestMethod.DELETE, value = \"/stores/{storeId:\\\\d+}\") void delete(@PathVariable Long storeId);}以上代码中，注解 @FeignClient 里面的值 “store” 表示自定义的客户端名称，被用于创建一个 Spring Cloud LoadBalancer 客户端。 你也可以通过 url 属性指定一个 URL（绝对路径或者是一个主机名）。 它对应的 Bean 的名称是它的全限定名称。要指定别名，你可以使用@FeignClient 注解里面的 qualifiers 的值。上面所说的负载均衡的会尝试去发现 “store” 服务的物理地址。 如果你的应用是一个 Eureka 客户端，那么它会从 Eureka 服务注册中心解析服务。如果你不想用 Eureka，你可以使用 SimpleDiscoveryClient 配置一个服务器列表在外部化配置中。" }, { "title": "Spring 中的声明式 HTTP 客户端", "url": "/spring/2022/06/27/spring-declarative-clients/", "categories": "Spring", "tags": "Spring, http", "date": "2022-06-27 00:48:00 +0800", "snippet": "如果使用 RestTemplate 的话，就太不简洁了。很多代码。Client interface method calls ====&gt; proxy ====&gt; HTTP callsFeign 是其中一种解决方案。Feign 支持多种 HTTP client 实现， 而且支持 Contracts， 支持自定义注解，参数解析支持多种 编码器、解码器，包括 Jackson 和 GSON支持 Metrics 包括 MicrometerSpring Cloud OpenFeignSpring MVC 和 Spring Cloud 支持 OpenFeign注解支持自动装配Spring Cloud LoadBalancer 支持Spring Cloud CircuitBreaker 支持Tracing 支持HttpMethod@RequestHeader@RequestParam@RequestBody@RequestAttributeResponseEntityHttpHeadersBodyvoidurlmethodcontentTypeacceptURIHttpMethod@RequestHeader@PathVariable@RequestBody@RequestParam@CookieValue" }, { "title": "如何在 Excel 中按列分割数据到多个工作表", "url": "/excel/2022/06/26/excel-split-data-by-column-using-vba/", "categories": "Excel", "tags": "Excel, VBA, 数据分割", "date": "2022-06-26 11:13:00 +0800", "snippet": "假设你有个 Excel 表格有很多行数据，比如有 ”年份“，”项目部“ 和 ”金额“ 这三个列（见下图 1）。然后你想将数据按照 ”项目部“ 分割成独立工作表，即工作表 “一部” 仅包含一部的数据。可能你还想将已分割的工作表分别保存到各个独立的 Excel 文件中，下文就说明如何使用 Excel VBA 脚本完成这些操作。首先看看表格的结构，和想要分割的效果。图 1接下来是 VBA 脚本代码和注释： Sub Splitdatabycol() 'comment by zwt Dim lr As Long Dim ws As Worksheet Dim vcol, i As Integer Dim icol As Long Dim myarr As Variant Dim title As String Dim titlerow As Integer Dim xTRg As Range Dim xVRg As Range Dim xWSTRg As Worksheet Dim wb As Workbook On Error Resume Next Set xTRg = Application.InputBox(\"请选择标题行：\", \"演示按列分割数据\", \"\", Type:=8) If TypeName(xTRg) = \"Nothing\" Then Exit Sub Set xVRg = Application.InputBox(\"请选择要拆分的列：\", \"演示按列分割数据\", \"\", Type:=8) If TypeName(xVRg) = \"Nothing\" Then Exit Sub vcol = xVRg.Column Set ws = xTRg.Worksheet lr = ws.Cells(ws.Rows.Count, vcol).End(xlUp).Row title = xTRg.AddressLocal titlerow = xTRg.Cells(1).Row icol = ws.Columns.Count ws.Cells(1, icol) = \"Unique\" Application.DisplayAlerts = False If Not Evaluate(\"=ISREF('xTRgWs_Sheet!A1')\") Then Sheets.Add(after:=Worksheets(Worksheets.Count)).Name = \"xTRgWs_Sheet\" Else Sheets(\"xTRgWs_Sheet\").Delete Sheets.Add(after:=Worksheets(Worksheets.Count)).Name = \"xTRgWs_Sheet\" End If Set xWSTRg = Sheets(\"xTRgWs_Sheet\") xTRg.Copy xWSTRg.Paste Destination:=xWSTRg.Range(\"A1\") ws.Activate For i = (titlerow + xTRg.Rows.Count) To lr On Error Resume Next If ws.Cells(i, vcol) &lt;&gt; \"\" And Application.WorksheetFunction.Match(ws.Cells(i, vcol), ws.Columns(icol), 0) = 0 Then ws.Cells(ws.Rows.Count, icol).End(xlUp).Offset(1) = ws.Cells(i, vcol) End If Next myarr = Application.WorksheetFunction.Transpose(ws.Columns(icol).SpecialCells(xlCellTypeConstants)) ws.Columns(icol).Clear For i = 2 To UBound(myarr) ws.Range(title).AutoFilter field:=vcol, Criteria1:=myarr(i) &amp; \"\" If Not Evaluate(\"=ISREF('\" &amp; myarr(i) &amp; \"'!A1)\") Then Sheets.Add(after:=Worksheets(Worksheets.Count)).Name = myarr(i) &amp; \"\" Else Sheets(myarr(i) &amp; \"\").Move after:=Worksheets(Worksheets.Count) End If xWSTRg.Range(title).Copy Sheets(myarr(i) &amp; \"\").Paste Destination:=Sheets(myarr(i) &amp; \"\").Range(\"A1\") ws.Range(\"A\" &amp; (titlerow + xTRg.Rows.Count) &amp; \":A\" &amp; lr).EntireRow.Copy Sheets(myarr(i) &amp; \"\").Range(\"A\" &amp; (titlerow + xTRg.Rows.Count)) Sheets(myarr(i) &amp; \"\").Columns.AutoFit Set wb = Workbooks.Add ThisWorkbook.Worksheets(myarr(i) &amp; \"\").Copy before:=wb.Worksheets(1) wb.SaveAs ThisWorkbook.Path &amp; \"\\\" &amp; Sheets(myarr(i) &amp; \"\").Name &amp; \".xlsx\" wb.Close savechanges = True Next xWSTRg.Delete ws.AutoFilterMode = False ws.Activate Application.DisplayAlerts = True MsgBox(\"数据已经切分完成。\") End Sub以上是 VBA 脚本代码。" }, { "title": "MySQL 优化策略", "url": "/mysql/2022/06/10/mysql-optimization-strategies/", "categories": "MySQL", "tags": "MySQL, Optimization, 优化", "date": "2022-06-10 17:13:00 +0800", "snippet": " 本文讨论 MySQL 一般优化策略数据库层面优化先问一下问题： 数据表结构是否合理，列是否使用的正确的数据类型，以及每张表的列数量是否合理？例如，经常做更新操作的应用通常是多表少列，而用于分析大量数据的应用一般是少表多列。 索引设置是否合理以便优化查询？ 表是否采用了合适的存储引擎？事务型用 InnoDB，非事务型用 MyISAM" }, { "title": "MySQL 文档型数据存储", "url": "/mysql/2022/05/30/using-mysql-as-nosql-engine/", "categories": "MySQL", "tags": "MySQL, NoSQL, JSON", "date": "2022-05-30 08:20:00 +0800", "snippet": " 本文记录使用 MySQL 作为 NoSQL 存储，主要是阅读 MySQL 8.0 Reference Manual 的 Chapter 20 Using MySQL as a Document Store 内容和练习时候的笔记。文档型数据存储文档型数据存储相对于传统的关系型数据存储，比较明显的区别就是文档型数据存储是不需要预先定义模式（schema）的，而关系型数据存储需要定义模式才能做数据存储的动作。MySQL 文档型数据存储模式当将 MySQL 作为文档存储使用时，主要会用到以下功能： X Plugin X Protocol X DevAPI安装 MySQL Shell 以便练习在 Ubuntu 中可以用以下命令安装 MySQL Shell：sudo apt install mysql-shell如果用 apt 安装有出现依赖库相关的问题，那么可以尝试通过 snap 安装：sudo snap install mysql-shell顺利安装完会提示： mysql-shell 8.0.23 from Canonical✓ installedMySQL 支持两种语言运行环境，一种是 JavaScript，另一种是 Python。 在 Windows 打开 MySQL shell 貌似默认是用 JavaScript，而在 Ubuntu 默认使用 Python。在终端输入 mysqlsh 就可以打开 MySQL shell，不过默认情况下可能没有连接到数据库。使用以下命令连接到数据库，注意 X Protocol 使用的端口号是 33060。mysqlsh root@192.168.3.33:33060/world_x其中 root 是用户，192.168.3.33 是主机 IP，33060 是端口号，最后部分是默认的 schema。 world_x 是 MySQL 官方提供的一个 example database，是世界上大部分国家/地区、城市等信息的数据库，带 “_x” 是 X Protocol 的版本，用 JSON document 存储数据的。所以这个数据库可以用来练习通过 X Protocol 或者 X DevAPI 使用 MySQL 的文档存储特性。一般在 Windows 安装 MySQL 8.x 时候会默认自带这个 world_x 示例数据库，且 8.x 版本默认开启 X Plugin（即支持 document store）。 不过如果发现你的 MySQL 实例没有 world_x 这个数据库，那么可以到 MySQL 的网站下载这些数据，只是一个 zip 压缩包，里面包含个 SQL 文件，导入即可。学习 MySQL 参考手册这个主题相关内容时候，录了个短视频记录。MySQL shell 的基本使用db 会输出 schema 相关信息，可以看到存在哪些 schema 和哪个正在使用。\\use world_x Default schema world_x accessible through db.表示使用 world_x 作为数据库默认 schema。" }, { "title": "播放器进度条预览实现", "url": "/2022/04/10/how-to-do-player-timeline-preview/", "categories": "", "tags": "ffmpeg, thumbnails, preview", "date": "2022-04-10 23:50:00 +0800", "snippet": "本文记录一种播放器进度条预览的实现方式，类似基于 vtt + 精灵图的实现，只不过是通过约定和计算公式确定所截取的雪碧图的小图位置，而不需要依赖 vtt 文件。1. 从视频文件或播放列表按照一定时间间隔抓取图抓取图的间隔决定了进度条预览的粒度，如果以 5s 为间隔取图，那么预览图就有一定跳跃性，最长可能要拖动进度条 5s 才会看到预览图有变化。如果每 1s 取一次图，预览时候效果就相对比较精细了，但没必要粒度太细。毕竟进度条的时间，一般不会显示毫秒数，拖动进度条的幅度一般也超过 1s。以下命令使用 ffmpeg 从视频文件 540p30.mp4 中按 1s 时间间隔抓取宽为 213 像素，高为 120 像素（16:9, 维持原来的宽高比）的缩略图，并保存到 thumbs 目录中，文件名以 ‘thumb-‘ 开头，后面跟数字位数为 5 的整数，个位数字则前面补 4 个 0，依此类推，文件扩展名为 .jpg.ffmpeg -i 540p30.mp4 -vf fps=1/1 -s 213x120 thumbs/thumb-%05d.jpg注意: 以上命令需要安装 ffmpeg2. 拼接缩略图成精灵图(Sprite)这一步将由第 1 步中生成的缩略图按照一定的行列数，按顺序拼接成精灵图以减少下载图片数量。这一步骤需要系统安装好 imagemagick, 因为会用到其中的 montage 命令去拼接缩略图。这个过程已经有 shell 脚本去做，参考自 rokudev 的一个仓库里的脚本。不过我对这个脚本微调了一下，以适应本文描述的做法。主要涉及两点调整，一个是对应地调整格式化打印读取文件时候的表达式，以适配第 1 步中的改动，即 %03d 改成 %05d 因为考虑到，如果有时长 10 小时的视频，按 1s 间隔取图，就会有 36000 张图，文件名也会去到 thumb-35999.jpg，只是为了”扩容“。 第二点改动是将最终拼接生成大图时候的文件名数字编码由从 1 开始改成从 0 开始，即在原来的控制这个数字编码的 shell 变量基础上减 1. 改动后的版本，放到了 GitHub Gist.这个脚本的使用如下：./gen_tiles.sh thumbs thumb images/pre 213x120 12 10上面的命令表示从 thumbs 目录（即第 1 步中缩略图存放的位置），读取文件名前缀是 ‘thumb’ 的文件，按每一格大小是 213x120，12 列，10 行地拼接一张精灵图。第 1 张会是 images/pre_0.jpg，第 2 张是 images/pre_1.jpg 依此类推，最后一张精灵图，如果剩余的缩略图的数量凑不够 120 个小格，那么后面剩下的格子会用黑色格子填充凑成一张 2556x1200 的大图。3. 根据时间线上的位置去确定取哪张精灵图的哪个小格先直接给出计算公式：① 获取哪个精灵图： 时间线当前位置时间 / 120 例如：pos 是 12:55 就是 12 x 60 + 55 = 775 秒775 / 120 = 6 所以应该去拿 xxx/images/pre_6.jpg 的精灵图② 得到小图的 x 坐标： ((pos % 120) % 12) * 213 例如：pos = 775, 则 x = (( 775 % 120) % 12) * 213 = 1491③ 得到小图的 y 坐标： ((pos % 120) / 12) * 120 例如 pos = 775, 则 y = (( 775 % 120) / 12) * 120 = 480④ 取小格缩略图： subImage(pre_6.jpg, 1491, 480, 213, 120)，这是个假想的方法，不过一般编程语言都有类似的API，传入精灵图，x,y 坐标，以及图片宽高可以切出小图，即要放在时间线上的预览图。总结以上步骤采用的参数可以实际情况调整，例如取图的时间间隔，精灵图的行列数，缩略图的宽高都可以调整，但计算套路仍然适用。下一步可能会引入一个 manifest.json 或 meta.json 之类，用于定义取图时间间隔等参数，这样客户端就不用写固定的参数，可以更灵活一些，服务端资源更新客户端也能适应。 本文没有给出客户端将预览图放到时间线上的具体 UI 实现，只是介绍一种通用做法，具体实现留给客户端。" }, { "title": "在 Ubuntu 20.04 安装 ffmpeg", "url": "/2022/03/08/installing-ffmpeg-on-ubuntu-20.04/", "categories": "", "tags": "ffmpeg, PPA", "date": "2022-03-08 11:54:00 +0800", "snippet": "FFmpeg 5.0 “Lorentz” 已经发布，不过可能项目不需要用到那么新的版本，所以这里记录在 Ubuntu 20.04 安装 FFmpeg 4.4 “Rao” 的过程。 添加 PPA:sudo add-apt-repository ppa:savoury1/ffmpeg4" }, { "title": "获取 Java thread dump", "url": "/2022/01/06/get-jvm-thread-dump/", "categories": "", "tags": "Java, JVM", "date": "2022-01-06 15:54:00 +0800", "snippet": "当生产环境的Java应用程序出现问题时，我们可以借助JVM提供的一些工具去分析问题根源。近期在线上环境遇到Java应用导致服务器CPU占用过高的情况，当时使用到一些JVM工具去获取线程转存，这里记录一下排查过程和用到的命令。" }, { "title": "安装Spring Boot应用作为系统服务", "url": "/2021/04/06/install-spring-boot-as-linux-service/", "categories": "", "tags": "Spring Boot, Linux, systemd, init.d", "date": "2021-04-06 15:54:00 +0800", "snippet": " 本文介绍 Spring Boot 应用打包为可执行 jar 文件,并将其安装到 Linux 系统作为 init.d 服务或 systemd 服务。注意，系统的 Java 要安装正常，不然 systemd 不能正常识别。以 jar 形式打包的 Spring Boot 应用可以使用命令 java -jar 运行，但也可以将它作为 Unix 环境的完全可执行文件的形式。一个完全可执行的 jar 可以像其它任何二进制可执行文件那样被执行，或者也可以注册到 init.d 或 systemd。这样的方式有助于在常见的生产环境中安装和管理 Spring Boot 应用。要在 Maven 创建一个完全可执行的 jar， 使用以下插件配置：&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;executable&gt;true&lt;/executable&gt; &lt;/configuration&gt;&lt;/plugin&gt;如果使用 Gradle 就用下面的配置：bootJar {\tlaunchScript()}生成的可执行 jar 可以通过命令 ./my-application.jar (其中 my-application 是你的应用 artifact 名称)。包含这个 jar 的目录会用作应用程序的工作目录。1. 支持的操作系统默认的脚本支持大部分 Linux 发行版而且已在 CentOS 和 Ubuntu 上测试过。 其它系统，例如 OS X 和 FreeBSD，需要使用自定义的 embeddedLaunchScript。2. Unix/Linux 服务Spring Boot 应用可以容易地作为 Unix/Linux service 让 init.d 或 systemd 去启动。2.1 安装为 init.d 服务 (System V)前面步骤生成的可执行 jar 可以用于 init.d service。 只需要符号连接到 init.d 就可以支持标准的 start，stop，restart，以及 status 命令。其中的脚本支持下列特性： 以 jar 文件拥有者的用户去启动服务 通过使用 /var/run/&lt;appname&gt;/&lt;appname&gt;.pid 追踪应用程序的 PID 将控制台输出的日志写到 /var/log/&lt;appname&gt;.log假设你有个 Spring Boot 应用安装在 /var/myapp ，那么要将它安装为一个 init.d 服务，可以按以下命令创建一个符号连接：$ sudo ln -s /var/myapp/myapp.jar /etc/init.d/myapp一旦安装完成，你就可以按照常规方式去启动和停止服务了。例如，在基于 Debian 的系统，你可以用以下命令启动：$ service myapp start 注意❗ 如果应用程序启动失败，请检查写到 var/log/&lt;appname&gt;.log 的日志。你也可以用操作系统的标准工具去将应用设为自动启动。例如，在基于 Debian 的系统，可以使用以下命令：$ update-rc.d myapp defaults &lt;priority&gt;保护 init.d 服务 ❕ 以下是一些关于以 init.d service 方式运行 Spring Boot 应用需要注意的一些安全问题。当以 root 执行，即用 root 用户去启动 init.d 的 service，默认的可执行脚本会以环境变量 RUN_AS_USER 所指定的用户去运行应用。当环境变量没有设置，就会以 jar 文件的拥有者用户去执行。你绝不应该以 root 用户运行 Spring Boot 应用，即 RUN_AS_USER 绝不应该设为 root，且你的应用的 jar 文件的拥有者不应该是 root。适当的做法是创建一个专门的用户用于运行应用，并设置 RUN_AS_USER 环境变量的值为该用户，或者使用 chown 去将其设为 jar 文件的拥有者，如以下命令所示：$ chown bootapp:bootapp your-app.jar在这情况下，默认的可执行脚本会以 bootapp 用户去运行应用。 💡 为降低应用程序的用户被黑的可能性，应该考虑禁用它的登录shell，例如，将那个帐户的shell为 /usr/sbin/nologin应该对应用程序的 jar 文件设置适当的权限，防止被修改。首先，权限设为不可写，只允许它的拥有者读或执行，如：$ chmod 500 your-app.jar接下来，限制当帐户被黑了的破坏范围。如果被黑了，黑客可以将 jar 文件设为可写的并修改它的内容。其中一种防护方式是将它设置为不可修改的，通过使用 chattr 命令，命令如下：$ sudo chattr +i your-app.jar这会防止任何用户，包括 root 修改 jar 的内容。如果 root 用于控制应用程序的 service，而且你使用 .conf 文件去自定义应用的启动，然后 .conf 文件被 root 用户读取并生效的。那么那文件也应该相应地做保护。使用 chmod 设置那文件只允许它的拥有者读取，并将 root 设为拥有者，如以下命令所示：$ chmod 400 your-app.conf$ sudo chown root:root your-app.conf2.2. 安装为一个 systemd Servicesystemd 是 System V init system 的继任者，并已被很多现代 Linux 发行版采用。尽管你可以继续在 systemd 使用 init.d 脚本，它也可以使用 systemd ‘service’ 脚本去启动 Spring Boot 应用程序的。假设你有个 Spring Boot 应用安装在 /var/myapp，要将 Spring Boot 应用程序安装为 systemd 服务，你需要创建一个名为 myapp.service 的脚本，并放到 /etc/systemd/system 目录。以下脚本提供作为例子：[Unit]Description=myappAfter=syslog.target[Service]User=myappExecStart=/var/myapp/myapp.jarSuccessExitStatus=143[Install]WantedBy=multi-user.target ❗ 记得修改 Description, User 和 ExecStart 字段为自己的应用程序。 ❕ 那个 ExecStart 字段没有声明脚本的动作命令，这意味着默认使用 run 命令注意，不像使用 init.d service 运行的那样，运行应用的用户，PID 文件，还有控制台输出日志文件都是由 systemd 本身管理的，因此，必须在 ‘service’ 脚本中使用适当的字段进行配置。详细配置方式可以参考 service unit configuration man page要将应用设置为开机启动，可以使用以下命令：$ systemctl enable myapp.service详情可参考 man systemctl 。2.3. 自定义启动脚本由 Maven 或 Gradle 插件写的内置启动脚本有好几种自定义的方式。对于大多数人而言，使用默认脚本和添加一些新的自定义配置通常就够了。如果发现没法自定义某些需要的东西，那使用 embeddedLaunchScript 选项去写你自己的版本。在写入过程自定义启动脚本通常在启动脚本被写入到 jar 文件的过程时去自定义脚本的元素是合理的。例如, init.d 脚本可以提供一个 “description”. 因为你提前就知道了 description (而且不需要变更),你可能也会在 jar 生成时候提供它。要自定义写入的元素,使用Spring Boot Maven 插件的 embeddedLaunchScriptProperties 选项, 或 Spring Boot Gradle 插件的 launchScript 的 properpies 属性.默认脚本支持替换的属性如下: 名称 描述 Gradle 默认值 Maven 默认值 mode The script mode. auto auto initInfoProvides The Provides section of “INIT INFO” ${task.baseName} ${project.artifactId} initInfoRequiredStart Required-Start section of “INIT INFO”. $remote_fs $syslog $network $remote_fs $syslog $network initInfoRequiredStop Required-Stop section of “INIT INFO”. $remote_fs $syslog $network $remote_fs $syslog $network initInfoDefaultStart Default-Start section of “INIT INFO”. 2 3 4 5 2 3 4 5 initInfoDefaultStop Default-Stop section of “INIT INFO”. 0 1 6 0 1 6 initInfoShortDescription Short-Description section of “INIT INFO”. Single-line version of ${project.description} (falling back to ${task.baseName}) ${project.name} initInfoDescription Description section of “INIT INFO”. ${project.description} (falling back to ${task.baseName}) ${project.description} (falling back to ${project.name}) initInfoChkconfig chkconfig section of “INIT INFO” 2345 99 01 2345 99 01 confFolder The default value for CONF_FOLDER Folder containing the jar Folder containing the jar inlinedConfScript Reference to a file script that should be inlined in the default launch script. This can be used to set environmental variables such as JAVA_OPTS before any external config files are loaded     logFolder Default value for LOG_FOLDER. Only valid for an init.d service     logFilename Default value for LOG_FILENAME. Only valid for an init.d service     pidFolder Default value for PID_FOLDER. Only valid for an init.d service     pidFilename Default value for the name of the PID file in PID_FOLDER. Only valid for an init.d service     useStartStopDaemon Whether the start-stop-daemon command, when it’s available, should be used to control the process true true stopWaitTime Default value for STOP_WAIT_TIME in seconds. Only valid for an init.d service 60 60 运行时自定义脚本对于 jar 写入后还需要自定义的脚本内容,你可以使用环境变量,或一个 config 文件默认脚本支持下来环境变量属性: 变量 描述 MODE The “mode” of operation. The default depends on the way the jar was built but is usually auto (meaning it tries to guess if it is an init script by checking if it is a symlink in a directory called init.d). You can explicitly set it to service so that the stop|start|status|restart commands work or to run if you want to run the script in the foreground. RUN_AS_USER The user that will be used to run the application. When not set, the user that owns the jar file will be used. USE_START_STOP_DAEMON Whether the start-stop-daemon command, when it’s available, should be used to control the process. Defaults to true. PID_FOLDER The root name of the pid folder (/var/run by default). LOG_FOLDER The name of the folder in which to put log files (/var/log by default). CONF_FOLDER The name of the folder from which to read .conf files (same folder as jar-file by default). LOG_FILENAME The name of the log file in the LOG_FOLDER (&lt;appname&gt;.log by default). APP_NAME The name of the app. If the jar is run from a symlink, the script guesses the app name. If it is not a symlink or you want to explicitly set the app name, this can be useful. RUN_ARGS The arguments to pass to the program (the Spring Boot app). JAVA_HOME The location of the java executable is discovered by using the PATH by default, but you can set it explicitly if there is an executable file at $JAVA_HOME/bin/java. JAVA_OPTS Options that are passed to the JVM when it is launched. JARFILE The explicit location of the jar file, in case the script is being used to launch a jar that it is not actually embedded. DEBUG If not empty, sets the -x flag on the shell process, allowing you to see the logic in the script. STOP_WAIT_TIME The time in seconds to wait when stopping the application before forcing a shutdown (60 by default). ❕ 其中 PID_FOLDER, LOG_FOLDER, 和LOG_FILENAME 变量仅适用于 init.d service. 对于systemd, 等价的自定义设置通过 ‘service’ script 实现. 详情请查看 service unit configuration man page.除了 JARFILE 和 APP_NAME , 上面所列出的设置都可以通过一个 .conf 文件去配置. 该文件应该与 jar 文件放在一起,并使用相同的文件名,但扩展名为 .conf 例如, 一个 jar 文件名为 /var/myapp/myapp.jar 使用的配置文件名称是 /var/myapp/myapp.conf , 入下面所示:myapp.confJAVA_OPTS=-Xmx1024MLOG_FOLDER=/custom/log/folder 💡 如果你不喜欢将config 文件跟 jar 文件放到一起, 你可以设置一个 CONF_FOLDER 环境变量以自定义配置文件的位置.了解更多对配置文件的安全保护措施, 可参考 the guidelines for securing an init.d service.3.Microsoft Windows Services一个 Spring Boot 应用程序可以通过使用winsw作为 Windows 服务启动详情可参考: A (separately maintained sample) describes step-by-step how you can create a Windows service for your Spring Boot application." }, { "title": "基于Grafana的物联网可视化仪表盘", "url": "/2021/03/05/grafana-iot-visualization-dashboard/", "categories": "", "tags": "IoT, 可视化, 物联网, 传感器", "date": "2021-03-05 02:45:00 +0800", "snippet": " 本文介绍如何在Ubuntu Server 20.04.2 LTS 服务器设置一个物联网可视化仪表盘。用到的技术包括 Docker, InfluxDB, MQTT, Grafana, Telegraf, NodeRed硬件方面采用 ESP8266、Arduino 或者其它任何兼容它的。本系统用于监控物联网设备的情况。其中 InfluxBD 用于存储来自传感器的数据。服务器我的服务器用的是旧的台式电脑安装 Ubuntu Server 20.04.2 LTS 操作系统，然后安装 Docker Engine。根据 Docker 官网文档提供的方法 先安装一些必要的包（如还没有）：sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg接下来：curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpgecho \\ \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io等 Docker 安装完成后：sudo usermod -aG docker $USER接下来是安装其它软件。安装并配置 Mosquittodocker pull eclipse-mosquitto一款开源的 MQTT broker，然后运行它。docker run -it -p 1883:1883 -p 9001:9001 eclipse-mosquitto安装并配置 InfluxDBInfluxBD 是一款时间序列数据库，可以用于存储与时间相关的数据，适合存传感器收集到的数据。docker pull influxdb运行 InfluxDBdocker run -d -p 8086:8086 -v influxdb:/var/lib/influxdb --name influxdb influxdb这里是将influxdb作为守护进程启动，并创建了卷用于存储数据在 /var/lib/influxdb如何创建 InfluxDB 数据库和用户这里需要创建数据库和用户，后面 Telegraf 需要访问数据库，以存储来自 MQTT 的数据。首先打开 InfluxDB CLI：docker exec -it influxdb influx接下来创建数据库和用户：create database sensorscreate user \"telegraf\" with password \"telegraf\"grant all on sensors to telegraf" }, { "title": "剑指Offer 面试题 3", "url": "/2020/12/07/find-duplicate-number-in-array/", "categories": "", "tags": "Java, 面试", "date": "2020-12-07 03:03:00 +0800", "snippet": "题目 在一个长度为n的数组里的所有数字都在 0 到 n-1 的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中第一个重复的数字。 例如，如果输入长度为7的数组{2 ,3, 1, 0, 2, 5, 3}，那么对应的输出是第一个重复的数字 2。这个题目在牛客网是请找出数组中第一个重复的数字，书中是“请找出数组中任意一个重复的数字”。如果直接按照书中的代码，那就不能通过牛客网的全部测试用例，这就有点搞了。不过还是先讲一下解题思路吧。先排序，再扫描排序后的数组很容易可以找出重复数字，从头到尾扫描一遍，发现相邻两个数相等的情况即找到了重复数字。时间复杂度为 $O(nlogn)$利用哈希表从头到尾扫描一遍数组，如果哈希表中没有这个数字，就将它加入哈希表，如果该数字已存在，则找到了重复数字。这个方法可以用 $O(1)$ 的时间来判断哈希表是否包含当前扫描到的数字，整个算法的时间复杂度是 $O(n)$ ，但代价是需要一个 $O(n)$ 大小的哈希表。利用数组下标因为数组中所有数字都在0~n-1范围内，如果数组没有重复数字，那么数组排序后里面数字应该与它对应的下标相等。但因为数组中数字有重复，所以某个位置上的数字应该会出现多于一次。其实说的是，某个下标对应着的与下标相等的数字可能出现多次。原书中那句话是，“由于数组中有重复的数字，有些位置可能存在多个数字，同时有些位置可能没有数字。”，当时看到这句话有点懵，难道数组的一个位置还可以挤下两个数字？后来知道他所指的“位置”是指，下标值与数值相等的这种情况。说起位置，就有点想起 PositionalList …清楚了上面的情况，那么怎么可以找出重复数字？书中也是一段文字描述，按照里边描述的确可以找出重复数字，但看起来有点不直观，所以画个流程图看看。这实际上是一个 in-place 的排序操作，一边排序同时判断是否有重复数字。上图中 i 表示数组的下标值，m 表示数字值。我们开始从头到尾依次扫描这个数组，当扫描到下标为 i 的数字时，首先比较这个数字(m)是否等于 i。如果是，就扫描下一个数字；如果不等，则将该数字与第 m 个数字进行比较（即与下标值等于 m 的那个数比较）。此时，如果它和第 m 个数字相等，则找到了一个重复数字，因为这个数字在下标值为 i 和 m 的位置都出现了。如果它和第 m 个数字不相等，就将第 i 个数字和第 m 个数字交换，这个操作就是将 m 放到下标值等于其数值的位置，放在它该出现的位置上。这个过程其实就是一个插入排序（Insertion Sort），利用了数组下标有序，in-place 操作做到空间复杂度为 $O(1)$ ，每个数字最多只要交换两次就可以找到它自己的位置，因此总的时间复杂度是 $O(n)$，代码如下：/** * @param numbers 输入的数组 * @param length 数组的长度 * @param duplication 原书中的是 C/C++ 的一个指针，用于返回数组中重复的数字， 在这里可能只是为了统一，将重复数字存在数组第一个位置 * @return true 如果有重复，否则 false */public boolean duplicate(int numbers[], int length, int[] duplication) { // 判空 if (numbers == null || length &lt;= 0) { return false; } // 判断是否数组内数字是否符合题目要求范围 for (int i = 0; i &lt; length; i++) { if (numbers[i] &lt; 0 || numbers[i] &gt; length - 1) { return false; } } for (int i = 0; i &lt; length; i++) { while(numbers[i] != i) { // 原题是找到任意一个重复数字，但这样做不符合牛客网的要求 // if (numbers[i] != i) { // 改为 if 可以通过牛客网题目测试，但题解不正确，因为测试用例有问题，奇怪。 if (numbers[i] == numbers[numbers[i]]) { duplication[0] = numbers[i]; return true; } // swap numbers[i] and numbers[numbers[i]] int temp = numbers[i]; numbers[i] = numbers[temp]; numbers[temp] = temp; } } return false;}可以通过测试的一种解法public boolean duplicate(int[] numbers, int length, int[] duplication) { if (numbers == null || length &lt;= 0) { return false; } Set&lt;Integer&gt; values = new HashSet&lt;&gt;(); for (int i = 0; i &lt; length; i++) { if (numbers[i] &lt; 0 || numbers[i] &gt; length - 1) { return false; } } int[] cloned = Arrays.copyOf(numbers, numbers.length); for (int i = 0; i &lt; length; i++) { while (numbers[i] != i) { //原题是找到任意一个重复数字 if (numbers[i] == numbers[numbers[i]]) { //duplication[0] = numbers[i]; values.add(numbers[i]); break; } // swap numbers[i] and numbers[numbers[i]] int temp = numbers[i]; numbers[i] = numbers[temp]; numbers[temp] = temp; } } if (!values.isEmpty()) { for (int i : cloned) { if (values.contains(i)) { duplication[0] = i; break; } } } return !values.isEmpty();}改成这样还不如下面这种方法：// 使用临时数组public boolean duplicate(int numbers[], int length, int[] duplication) { if (numbers == null || numbers.length == 0) return false; int[] temp = new int[length]; for (int i = 0; i &lt; length; i++) { temp[numbers[i]]++; if (temp[numbers[i]] &gt; 1) { duplication[0] = numbers[i]; return true; } } return false;}上面这个方法参考自：牛客网的一个解题结束了这个题是剑指 Offer 开局的第一题，有点经典，除了上面主要着重分析的方法，还有其它各种解法，但传统解题以点到为止。时间不太够，要继续刷其它题了。" }, { "title": "剑指Offer 面试题 34", "url": "/2020/12/03/binary-path-sum/", "categories": "", "tags": "Java, 面试", "date": "2020-12-03 21:40:00 +0800", "snippet": "题目书中原题目是： 题目：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。二叉树节点的定义如下：struct BinaryTreeNode{ int m_nValue; BinaryTreeNode m_pLeft; BinaryTreeNode m_pRight;}不过牛客网上的题目，稍微有点不同： 输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。题目是要求返回 ArrayList&lt;ArrayList&lt;Integer&gt;&gt;，还有那个按字典序打印。这道题主要是对树进行前序遍历，访问到某个节点时累加起来，直到叶子节点，判断路径节点值之和是否为要求的整数。思路相对来说比较简单和直接，但是需要注意实现采用的数据结构的细节。首先，从一个具体例如入手分析，输入下图 1 中二叉树和整数 22图 1从根节点 10 开始按前序遍历，下一个节点是 5，此时路径包含两个节点，分别是 10，5。接下来将访问到 4 这个节点，这时候已经达到叶子节点，但路径上的节点值之和是 19，不等于 22，所以不符合要求。之后回溯到父子点 5，接着再去访问右节点 7，此时路径中的节点的值 10，5，7之和刚好是 22，符合要求。其中的规律是，当用前序遍历的方式访问到某一节点时，我们把该节点添加到路径上，并累加该节点的值。如果该节点为叶节点，并且路径中节点值的和刚好等于输入的整数，则当前路径符合要求，我们把它添加到ArrayList里边。如果当前节点不是叶节点，则继续访问它的子节点。当前节点访问结束后，递归方法将自动回到它的父节点。因此，我们在方法退回之前在路径上删除当前节点并减去当前节点的值，以确保返回父节点时路径刚好是从根节点到父节点。可以看出保存路径的数据结构实际上是一个栈，因为路径要与递归调用状态一致，而递归调用的本质就是一个压栈和出栈的过程。这里的内容基本跟书里的讲解差不多，只不过按牛客网的题目要求，并且用 Java 实现的话，我自己的做法是使用了集合框架里的 Deque 接口，一个双端队列。因为这样子，可以保证队列的顺序符合最终要求返回的路径内节点的顺序，同时也可以当作一个栈在队尾（相当于栈顶）操作。具体代码如下：package io.zwt.ch4;import java.util.ArrayDeque;import java.util.ArrayList;import java.util.Deque;/** * 输入一颗二叉树的根节点和一个整数， * 按字典序打印出二叉树中结点值的和为输入整数的所有路径。 * 路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 */public class FindPathSum { private final ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists; public FindPathSum() { this.lists = new ArrayList&lt;&gt;(); } public static class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } /** * @param root 输入的二叉树的根节点 * @param target 预期路径节点值之和 * @return 路径组成的 List */ public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) { if (root == null) { return new ArrayList&lt;&gt;(); } Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(); // 一个双端队列存储路径 int currentSum = 0; return findPath(root, target, path, currentSum); } /** * @param root 当前节点 * @param target 路径节点值之和 * @param path 路径 * @param currentSum 当前路径值之和 * @return 返回多少路径 */ private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(TreeNode root, int target, Deque&lt;Integer&gt; path, int currentSum) { currentSum += root.val; path.offer(root.val); // 放入队列 // 如果是叶节点，并且路径上节点值的和等于输入的值， // 则将这条路径添加到 ArrayList boolean isLeaf = root.left == null &amp;&amp; root.right == null; // 递归结束条件 if (currentSum == target &amp;&amp; isLeaf) { lists.add(new ArrayList&lt;&gt;(path)); } // 如果不是叶节点，则遍历它的子节点 if (root.left != null) { findPath(root.left, target, path, currentSum); } if (root.right != null) { findPath(root.right, target, path, currentSum); } // 在返回父节点之前，在路径上删除当前节点 path.pollLast(); return lists; }}" }, { "title": "水塔液位自动控制装置", "url": "/2020/11/23/water-tank-level-control-automation/", "categories": "", "tags": "Personal, Draft, Notes", "date": "2020-11-23 12:13:00 +0800", "snippet": "前段时间做了点小东西，随缘记录一下。在家里日常生活用水是用水塔，通过水泵将水从水井抽到楼顶的水塔用的。通常这些水塔都会有自动液位控制的，一般是一个浮球，机械式的开关。但家里的水塔比较旧没有安装水位控制装置，所以我一直想在水塔添加这样的功能。因为不想用浮球式液位控制，主要是想趁机折腾一下，玩一下技术。最初有些不太实际的脑洞，例如，可不可以通过测量液位变化时水塔的电容反映水位变化；还有根据水压变化计算出液面高度…… 因为不想安装水压测量到水管里，而且还要设法与水泵开关联动，麻烦。大概五年前，上大二的时候，刚学单片机，就想着用 51 做一个东西去根据水塔液位变化自动控制水泵开关。 大概就是这么一个东西，当初用 51 接一个超声波测距模块，还有继电器，联合起来控制水泵。测得距离大于某个值，说明水位低于某个值，就打开水泵抽水，直到距离小于某个值就关掉水泵停止抽水，逻辑很简单的。不过当时程序可能写得不太好，硬件也没有弄得很好，因为用洞洞板焊接的。那东西在一次暴雨天后就坏了，我弟以为那是遭雷击了，我也不太清楚，反正就坏了。 然后半个月前，我闲着又再次折腾起这东西。这次硬件上使用 Arduino + ESP8266 + 小米路由器 + 小米智能网关 + 加个小米 ZigBee 版智能插座。超声波测距模块由Arduino 驱动，再通过串口发送距离数据到 ESP8266，通过 WiFi TCP 传到小米路由器（跑 OpenWRT)，在小米路由器上的 Linux 写了个程序，基于 ubox (epoll) 的 TCP 和 UDP 客户端。其中 TCP 接收来自 ESP8266 的液位数据，UDP 客户端用于与小米智能网关交互。当水塔液位低于某个水平，这个程序就会向小米智能网关发送命令，去控制米家智能插座打开。这个插座接着水泵，就相当于初版里边的继电器。之前还弄了个可视化监控的东西，但是后来 PC 机做的服务器崩了，就没有继续玩下去。本来还有个基于 JavaFX 的图形界面，可以查看液位，手动控制开关之类的。更新了。上周换了一个防水的超声波模块，因为考虑到我不在老家的时候，如果用那种普通的 HC-SR04，不防水，一两个月就坏，没有空维修就麻烦。所以换了一个防水的，贵很多，但估计会比较耐用、稳定。录了个视频大概聊了一下: BV1b5411N7UX然后关于可视化监控的，见另外一篇文章的介绍 基于Grafana的物联网可视化仪表盘 。" }, { "title": "Spring单例与单例模式", "url": "/2020/11/02/Spring-singleton-vs-Singleton-pattern/", "categories": "", "tags": "Personal, Notes", "date": "2020-11-02 02:04:00 +0800", "snippet": " Spring 单例不是 Java 单例。本文讨论 Spring 的单例与单例模式的区别。前言单例是 Spring 当中 bean 的默认范围(Scope)。Spring 容器会为某个 bean 定义对象创建唯一的实例，很多时候我们会将这种设计跟《设计模式》(GoF) 书中定义的单例模式作比较。1. 单例范围 vs 单例模式Spring 当中的单例范围跟单例模式不是同一个东西。其中的两点差异如下： 单例模式确保某个类加载器的某个类只有一个实例 而 Spring 单例范围是每个容器的每个bean 1.1 单例范围的例子Spring 的单例实例会被放在缓存中，下次再访问那个命名的 bean 的时候就会从缓存里面取。下边看看例子。public class Account { private String name; public Account() { } public Account(String name) { this.name = name; } public String getName() { return name; } @Override public String toString() { return \"Account{\" + \"name='\" + name + '\\'' + '}'; }}Spring Boot 的 main 方法：@SpringBootApplication@SpringBootApplicationpublic class SpringSingletonApp { public static void main(String[] args) { SpringApplication.run(SpringSingletonApp.class, args); } @Bean(name = \"bean1\") public Account account() { return new Account(\"Test User 1\"); } @Bean(name = \"bean2\") public Account account1() { return new Account(\"Test User 2\"); }}理解上面的代码： 我们创建了同一个类的 2 个实例，并有不同的 bean id。那么上面代码中 Spring 的 IoC 容器创建了多少个实例？ 2 个不同的实例，在容器中分别绑定到它们的 id？ 还是 1 个实例绑定到 2 个 bean id？1.2 测试用例我们使用单元测试找出答案。@SpringBootTestclass SpringSingletonAppTests { private static final Logger log = LoggerFactory.getLogger(SpringSingletonAppTests.class); @Resource(name = \"bean1\") Account account1; @Resource(name = \"bean1\") Account duplicateAccount; @Resource(name = \"bean2\") Account account2; @Test public void testSingletonScope() { log.info(account1.getName()); log.info(account2.getName()); log.info(\"Accounts are equal -&gt; {}\", account1 == account2); log.info(\"Duplicate account -&gt; {}\", account1 == duplicateAccount); }}输出为：20:06:31.165 [main] INFO i.z.s.SpringSingletonAppTests - Test User 120:06:31.165 [main] INFO i.z.s.SpringSingletonAppTests - Test User 220:06:31.165 [main] INFO i.z.s.SpringSingletonAppTests - Accounts are equal -&gt; false20:06:31.167 [main] INFO i.z.s.SpringSingletonAppTests - Duplicate account -&gt; true从上面的输出我们发现：Spring 返回了两个不同的实例，单例范围的同一个类可以有多于一个的对象实例。对于某个 bean id，Spring 容器仅维护唯一的共享单例 bean，在我们上面的例子中，Spring IoC 容器基于同一个类的 bean 定义创建了两个实例，并将它们绑定到对应的 id。Spring 的 bean 定义就像键值对那样，bean id 就是 key，bean 的实例就是 value。每个 key 引用都会返回同一个 bean 实例（例如 bean1 引用始终返回 id 为 bean1 的 bean）总结Spring 单例跟传统的单例模式是不同的。Spring 确保在每个容器对给定 bean id 定义只创建一个 bean 实例。 传统单例模式是保证给定一个类加载器所加载的某个类只有唯一的一个实例。" }, { "title": "DS-ch15 Memory Management and B-Trees", "url": "/2020/08/16/ds-ch15/", "categories": "", "tags": "Data Structure", "date": "2020-08-16 02:36:00 +0800", "snippet": "15.5 ExercisesReinforcementR-15.1 Julia just bought a new computer that uses 64-bit integers to address memory cells. Argue why Julia will never in her life be able to upgrade the main memory of her computer so that it is the maximum-size possible, assuming that you have to have distinct atoms to represent different bits.R-15.2 Consider an initially empty memory cache consisting of four pages. How many page misses does the LRU algorithm incur on the following page request sequence: (2,3,4,1,2,5,1,3,5,4,1,2,3)?R-15.3 Consider an initially empty memory cache consisting of four pages. How many page misses does the FIFO algorithm incur on the following page request sequence: (2,3,4,1,2,5,1,3,5,4,1,2,3)?R-15.4 Consider an initially empty memory cache consisting of four pages. What is the maximum number of page misses that the random algorithm incurs on the following page request sequence: (2,3,4,1,2,5,1,3,5,4,1,2,3)? Show all of the random choices the algorithm made in this case.R-15.5 Describe, in detail, algorithms for adding an item to, or deleting an item from, an $(a,b)$ tree.R-15.6 Suppose T is a multiway tree in which each internal node has at least five and at most eight children. For what values of a and b is $T$ a valid $(a,b)$ tree?R-15.7 For what values of d is the tree $T$ of the previous exercise an order-d B-tree?R-15.8 Draw the result of inserting, into an initially empty order-7 B-tree, entries with keys (4,40,23,50,11,34,62,78,66,22,90,59,25,72,64,77,39,12), in this order. CreativityC-15.9 Describe an efficient external-memory algorithm for removing all the duplicate entries in an array list of size n.C-15.10 Describe an external-memory data structure to implement the stack ADT so that the total number of disk transfers needed to process a sequence of k push and pop operations is $O(k/B)$.C-15.11 Describe an external-memory data structure to implement the queue ADT so that the total number of disk transfers needed to process a sequence of k enqueue and dequeue operations is $O(k/B)$.C-15.12 Describe an external-memory version of the PositionalList ADT (Section 7.3), with block size B, such that an iteration of a list of length n is completed using $O(n/B)$ transfers in the worst case, and all other methods of the ADT require only $O(1)$ transfers.C-15.13 Change the rules that define red-black trees so that each red-black tree T has a corresponding $(4,8)$ tree, and vice versa.C-15.14 Describe a modified version of the B-tree insertion algorithm so that each time we create an overflow because of a split of a node w, we redistribute keys among all of w’s siblings, so that each sibling holds roughly the same number of keys (possibly cascading the split up to the parent of w). What is the minimum fraction of each block that will always be filled using this scheme?C-15.15 Another possible external-memory map implementation is to use a skip list, but to collect consecutive groups of $O(B)$ nodes, in individual blocks, on any level in the skip list. In particular, we define an order-d B-skip list to be such a representationof a skip list structure, where each block contains at least $⌈d/2⌉$ list nodes and at most d list nodes. Let us also choose d in this case to be the maximum number of list nodes from a level of a skip list that can fit into one block. Describe how we should modify the skip-list insertion and removal algorithms for a B-skip list so that the expected height of the structure is $O(logn/logB)$.C-15.16 Describe how to use a B-tree to implement the Partition ADT (Section 14.7.3) so that the union and find operations each use at most $O(logn/logB)$ disk transfers.C-15.17 Suppose we are given a sequence S of n elements with integer keys such that some elements in S are colored “blue” and some elements in S are colored “red.” In addition, say that a red element e pairs with a blue element f if they have the same key value. Describe an efficient external-memory algorithm for finding all the red-blue pairs in S. How many disk transfers does your algorithm perform?C-15.18 Consider the page caching problem where the memory cache can hold m pages, and we are given a sequence P of n requests taken from a pool of $m + 1$ possible pages. Describe the optimal strategy for the offline algorithm and show that itcauses at most $m + n/m$ page misses in total, starting from an empty cache.C-15.19 Describe an efficient external-memory algorithm that determines whether an array of n integers contains a value occurring more than n/2 times.C-15.20 Consider the page caching strategy based on the least frequently used (LFU) rule, where the page in the cache that has been accessed the least often is the one that is evicted when a new page is requested. If there are ties, LFU evicts the least frequently used page that has been in the cache the longest. Show that there is a sequence P of n requests that causes LFU to miss $Ω(n)$ times for a cache of m pages, whereas the optimal algorithm will miss only $O(m)$ times.C-15.21 Suppose that instead of having the node-search function $f (d) = 1$ in an order-d B-tree T , we have $f (d) = logd$. What does the asymptotic running time of performing a search in T now become?ProjectsP-15.22 Write a Java class that simulates the best-fit, worst-fit, first-fit, and next-fit algorithms for memory management. Determine experimentally which method is the best under various sequences of memory requests.P-15.23 Write a Java class that implements all the methods of the sorted map ADT by means of an $(a,b)$ tree, where a and b are integer constants passed as parameters to a constructor.P-15.24 Implement the B-tree data structure, assuming a block size of 1024 and integer keys. Test the number of “disk transfers” needed to process a sequence of map operations." }, { "title": "DS-ch01", "url": "/2020/08/15/ds-ch01/", "categories": "", "tags": "Data Structure", "date": "2020-08-15 00:00:00 +0800", "snippet": "1.10 ExercisesReinforcementR-1.1 Write a short Java method, inputAllBaseTypes, that inputs a different value of each base type from the standard input device and prints it back to the standard output device.R-1.2 Suppose that we create an array A of GameEntry objects, which has an integer scores field, and we clone A and store the result in an array B. If we then immediately set A[4].scores equal to 550, what is the score value of the GameEntry object referenced by B[4]?R-1.3 Write a short Java method, isMultiple, that takes two long values, n and m, and returns true if and only if n is a multiple of m, that is, $n = mi$ for some integer i.R-1.4 Write a short Java method, isEven, that takes an int i and returns true if and only if i is even. Your method cannot use the multiplication, modulus, or division operators, however.R-1.5 Write a short Java method that takes an integer n and returns the sum of all positive integers less than or equal to n.R-1.6 Write a short Java method that takes an integer n and returns the sum of all the odd positive integers less than or equal to n.R-1.7 Write a short Java method that takes an integer n and returns the sum of the squares of all positive integers less than or equal to n.R-1.8 Write a short Java method that counts the number of vowel in a given character string.R-1.9 Write a short Java method that uses a StringBuilder instance to remove all the punctuation from a string s storing a sentence, for example, transforming the string “Let’s try, Mike!” to “Lets try Mike”.R-1.10 Write a Java class, Flower, that has three instance variables of type String, int, and float, which respectively represent the name of the flower, its number of petals, and price. Your class must include a constructor method that initializes each variable to an appropriate value, and your class should include methods for setting the value of each type, and getting the value of each type.R-1.11 Modify the CreditCard class from Code Fragment 1.5 to include a method that updates the credit limit.R-1.12 Modify the CreditCard class from Code Fragment 1.5 so that it ignores any request to process a negative payment amount.R-1.13 Modify the declaration of the first for loop in the main method in Code Fragment 1.6 so that its charges will cause exactly one of the three credit cards to attempt to go over its credit limit. Which credit card is it? CreativityC-1.14 Write a pseudocode description of a method that reverses an array of n integers, so that the numbers are listed in the opposite order than they were before, and compare this method to an equivalent Java method for doing the same thing.C-1.15 Write a pseudocode description of a method for finding the smallest and largest numbers in an array of integers and compare that to a Java method that would do the same thing.C-1.16 Write a short program that takes as input three integers, a, b, and c, from the Java console and determines if they can be used in a correct arithmetic formula (in the given order), like “a+b = c,” “a = b - c,” or “a ∗ b = c.”C-1.17 Write a short Java method that takes an array of int values and determines if there is a pair of distinct elements of the array whose product is even.C-1.18 The p-norm of a vector v = (v1,v2,…,vn) in n-dimensional space is defined as kvk = qp v1p +v2p +···+vnp. For the special case of p = 2, this results in the traditional Euclidean norm, which represents the length of the vector. For example, the Euclidean norm of a two-dimensional vector with coordinates (4,3) has a Euclidean norm of √42 +32 = √16+9 = √25 = 5. Give an implementation of a method named norm such that norm(v, p) returns the p-norm value of v and norm(v) returns the Euclidean norm of v, where v is represented as an array of coordinates.C-1.19 Write a Java program that can take a positive integer greater than 2 as input and write out the number of times one must repeatedly divide this number by 2 before getting a value less than 2.C-1.20 Write a Java method that takes an array of float values and determines if all the numbers are different from each other (that is, they are distinct).C-1.21 Write a Java method that takes an array containing the set of all integers in the range 1 to 52 and shuffles it into random order. Your method should output each possible order with equal probability.C-1.22 Write a short Java program that outputs all possible strings formed by using the characters ‘c’, ‘a’, ‘t’, ‘d’, ‘o’, and ‘g’ exactly once.C-1.23 Write a short Java program that takes two arrays a and b of length n storing int values, and returns the dot product of a and b. That is, it returns an array c of length n such that c[i] = a[i]· b[i], for i = 0,…,n - 1.C-1.24 Modify the CreditCard class from Code Fragment 1.5 so that printSummary becomes a nonstatic method, and modify the main method from Code Fragment 1.6 accordingly.C-1.25 Modify the CreditCard class to add a toString() method that returns a String representation of the card (rather than printing it to the console, as done by printSummary). Modify the main method from Code Fragment 1.6 accordingly to use the standard println command.ProjectsP-1.26 Write a short Java program that takes all the lines input to standard input and writes them to standard output in reverse order. That is, each line is output in the correct order, but the ordering of the lines is reversed.P-1.27 Write a Java program that can simulate a simple calculator, using the Java console as the exclusive input and output device. That is, each input to the calculator, be it a number, like 12.34 or 1034, or an operator, like + or =, can be done on aseparate line. After each such input, you should output to the Java console what would be displayed on your calculator.P-1.28 A common punishment for school children is to write out a sentence multiple times. Write a Java stand-alone program that will write out the following sentence one hundred times: “I will never spam my friends again.” Your program should number each of the sentences and it should make eight different random looking typos.P-1.29 The birthday paradox says that the probability that two people in a room will have the same birthday is more than half, provided n, the number of people in the room, is more than 23. This property is not really a paradox, but many people find it surprising. Design a Java program that can test this paradox by a series of experiments on randomly generated birthdays, which test this paradox for n = 5,10,15,20,…,100.P-1.30 (For those who know Java graphical user interface methods:) Define a GraphicalTest class that tests the functionality of the CreditCard class from Code Fragment 1.5 using text fields and buttons." }, { "title": "回顾OCP 1Z0-816认证考试", "url": "/2020/05/31/Oracle-1Z0-816-exam-review/", "categories": "", "tags": "Java, Certification", "date": "2020-05-31 06:32:00 +0800", "snippet": " 群 OCA/OCP 考试交流QQ群 157563860其实这篇文章起源于 Twitter 上以为委瑞内拉小哥问我关于 OCP 考试的问题，我只好写这个作为回应。但中英夹杂，如果是国内读者看起来可能有点难受，改天再更新整理一下。 注意，现在 1Z0-816 考试已经没有了，只有 1Z0-819 考试。 另外前段时间我录了个视频，放在B站小号这里，讲了一些关于考试的。I started with OCA Java SE 8 Programmer I exam last year, it took me 12 days to prepare the OCA exam. It was relatively easy to pass the OCA exam, but it was much harder to pass the OCP 11 exam. It took me roughly 3 months to get fully prepared for the ultimate 1Z0-816, namely Java SE 11 Programmer II exam, for which response to the Oracle Certified Professional: Java SE 11 Developer certification. This is by far the most difficult Java certification exam from Oracle/Sun, not just because it covers topics such as modules, functional programming, concurrent programming, IO. But also it includes some new objectives, like Java Secure Coding Guideline. For those who plan on taking the Oracle Java Certification exam, I strongly recommend you take a look at the official exam objectives before you start your study plan. Buy a good book, I think Selikoff’s book is great, I use that book for my exam preparation. Study the book chapter by chapter, or by topic, or whatever you want. Be sure to do the exercises, it will help you to consolidate your knowledge. It is also helpful to use flashcards to aid the memorization process, for example, some core APIs or some syntax rules. Don’t go directly into the quiz without studying the materials thoroughly, that will be just a waste of time and energy. Because that’s very frustrating to see lots of errors. Take your time, start slowly, and gradually level up the difficulty. Below are some useful references.Books(参考书籍)I recommend : OCP Oracle Certified Professional Java SE 11 Programmer II Study Guide: Exam 1Z0-816 1st Edition by Scott Selikoff (Author), Jeanne Boyarsky (Author)（This title will be released on July 8, 2020.）我建议使用这本书作为考试参考。 Selikoff Java SE 11 experience 书的作者的考试经验 While questions within a topic were relatively straight-forward, the amount of topics you had to know for the 1Z0-816 exam dwarfs the 1Z0-809 exam. Annotations, Security, Local Type Inference, Private/Static Interface Methods, and Modules are completely new. 尽管考试相关的主题相对来说是很直接的，但你在 1Z0-816 考试所需要知道的主题内容使得 1Z0-809 相形见绌。注解、安全、局部类型推导，接口的私有/静态方法，以及模块的内容都是全新的。If you have time… （有时间还推荐） Java Language Features, Java The Complete Reference, Effective JavaMock exam software(模拟软件)I used (我使用的是) OCP Java 11 - 1Z0-816 Mock Exams Practice Tests/Questions Part 2Oracle website pages(官方页面)Technical(技术相关) Secure Coding Guidelines for Java SE (页面已经更新了，排版比较现代了，而且小标题改为 Updated for Java SE 11 而不是 Java SE 13)Secure Coding Guidelines for Java SEUpdated for Java SE 11Document version: 7.2Published: 27 September 2018Last updated: 7 May 2019 Java SE 11 API docs : Java® Platform, Standard Edition &amp; Java Development Kit Version 11 API Specification jls : Java SE Specifications Annotations Trail : Learn something new about annotations since Java 8(学习 Java 8 以来更新的注解)About Online Proctored Exam(关于在线考试) Get Ready for your Online Proctored Exam - Oracle Certification(Video)Oracle onvue Where to schedule an exam(考试报名地址 )Online Proctoring FAQs 常见问题pearsonvue online-proctored-policies 在线考试政策甲骨文大学 (Oracle University)主页Checkout more info about certification exams(关于认证考试本身的信息，我建议你去Oracle University官方网站看看，考试的信息和认证路径的信息。)OCA 808Oracle Learning Subscriptions Eight Quick Tips 官方贴士OnVUE Testing Experience 一个视频，在线考试的体验Oracle Certification Exams Are More Accessible Than Ever Before 同样是一个关于在线考试的文章Your Guide to Oracle Certification Testing Anywhere 在线考试文章考试复习大纲(1Z0-816 exam objects in Chinese)Java 基础创建并使用 final 类创建并使用内部，嵌套，以及匿名类创建并使用枚举Java 接口创建并使用带有默认方法的接口创建并使用带有私有方法的接口函数式接口与 Lambda 表达式定义并编写函数式接口创建并使用 Lambda 表达式，包括 Lambda 语句，局部变量作 lambda 参数内置函数式接口使用 java.util.function 包里的接口使用核心函数式接口，包括 Predicate, Consumer, Function 和 Supplier使用 java.util.function 包里基础接口的基本数据类型及二元变式迁移到模块化应用迁移使用 Java SE 9 以前版本开发的应用到 SE 11，包括自上而下和自下而上迁移方式，将一个 Java SE 8 应用分模块作迁移使用 jdeps 确定依赖关系，并识别解决循环依赖的方法。并发使用 Runnable，Callable 创建工作线程，并使用 ExecutorService 并发地执行任务使用 java.util.concurrent 包里的容器和类，包括 CyclicBarrier 和 CopyOnWriteArrayList编写线程安全的代码识别线程问题，例如死锁和活锁I/O (基础以及 NIO2)使用 I/O 流从控制台和文件读写数据使用 I/O 流读写文件使用序列化读写对象使用 Path 接口操作文件和目录路径使用 Files 类去检查、删除、复制或移动一个文件或目录结合 Files 类使用 Stream APIJDBC 数据库应用使用 JDBC URLs 和 DriverManager 连接到数据库使用 PreparedStatement 去执行 CRUD 操作使用 PreparedStatement 和 CallableStatement APIs 去执行数据库操作注解表述注解的用途以及典型使用模式应用注解到类和方法描述 JDK 中常用的注解声明自定义注解异常处理与断言使用 try-with-resources 结构创建并使用自定义异常类使用断言测试不变性泛型与容器使用包装类，自动装箱和自动拆箱用钻石记号和通配符创建并使用泛型类、方法描述容器框架并使用主要容器接口使用 Comparator 和 Comparable 接口创建并使用容器的便利方法Java Stream API描述 Stream 接口和管道使用 lambda 表达式和方法引用Streams 上的 Lambda 操作使用 map, peek 和 flatMap 方法提取 stream 数据使用 findFirst, findAny, anyMatch, allMatch 和 noneMatch 方法搜索 stream 数据使用 Optional 类使用 count, max, min, average 和 sum stream 操作执行计算使用 lambda 表达式对容器排序在 streams 使用 Collectors ，包括 groupingBy 和 partitioningBy 操作模块化应用中的服务描述服务的组件，包括指令设计一个服务类型，使用 ServiceLoader 加载服务，检查服务的依赖，包括消费者和提供者模块并行 Streams编写使用并行 streams 的代码用 streams 实现分解与归约操作Java SE 应用安全编码在 Java 应用中预防拒绝服务在 Java 应用中保护机密信息实现数据一致性准则——注入和包含以及输入校验通过限制可访问性和可扩展性保护代码受外部攻击，妥善处理输入校验以及可变性安全地构建敏感对象保护序列化与反序列化本地化使用 Locale 类使用资源包使用 Java 格式化消息、日期和数字" }, { "title": "Java笔试题1", "url": "/2020/05/10/java-interview-test1/", "categories": "", "tags": "Java 笔试", "date": "2020-05-10 20:02:00 +0800", "snippet": "真题1 某知名互联网下载服务提供商软件工程师笔试题一、选择题1. 访问修饰符作用范围由大到小是（ ）。 A.private-protected-default-publicB.public-protected-default-privateC.private-default-protected-publicD.public-default-protected-private这题没什么好说，当然是选择 B 啦，初学的时候可能有点难记住，不过习惯了就记住了。后来越了解就更容易记住，根本不需要死记硬背。 default 关键字，表示访问权限的时候，其实新的规范（8以上？）改称为 ‘package private’ 可以理解为包内私有访问权限，所以限制程度就是仅次于私有。接着protected和public容易，因为public肯定是范围最宽（大）的。关于类的访问修饰符的作用范围，Java语言规范的 8.1.1 节有：The access modifier public pertains only to top level classes and member classes, not to local classes or anonymous classes.The access modifier protected and private pertain only to member classes within a directly enclosing class declaration.2. 在Java 语言中，下面接口以键−值对的方式存储对象的是（ ）。 A.java.util.ListB.java.util.MapC.java.util.CollectionD.java.util.Set选 B 这题也很直接。3. 以下不是Object 类的方法的是（ ）。 A.hashCode()B.finalize()C.notify()D.hasNext()选 D4. 有如下代码：public class Test { public void change(String str, char ch[]) { str = \"test ok\"; ch[0] = 'g'; } public static void main(String args[]) { String str = new String(\"good\"); char[] ch = { 'a', 'b', 'c' }; Test ex = new Test(); ex.change(str, ch); System.out.print(str + \" and \"); System.out.print(ch); }}上面程序的运行结果是（ ）。 A.good and abcB.good and gbcC.test ok and abcD.test ok and gbc选 B 在 Java 语言中，除了8 种原始的数据类型（分别为 byte、short、int、long、float、double、char 和 boolean）外，其他的类型都是对象，在方法调用的时候，传递的都是引用。引用从本质上来讲也是按值传递，只不过传递的这个值是对象的引用而已，因此，在方法调用的时候，对形参引用所指对象属性值的修改对实参可见。但是对引用值本身的修改对实参是不可见的。二、填空题1. Math.round(12.5) 的返回值等于（ 13 ），Math.round(-12.5) 的返回值等于（ -12 ）。 round 是一个四舍五入的方法，12.5 的小数部分为 0.5，当对其执行 Math.round() 操作时，结果需要四舍五入，所以，结果为 13；−12.5 的小数部分也为 0.5，当对其执行 Math.round() 操作时，结果也需要四舍五入，由于 −12 &gt; −13，因此，结果为 −12。2. 有如下程序：String str1 = \"hello world\";String str2 = \"hello\" + new String(\"world\");System.out.println(str1 == str2);那么程序的运行结果是（ false ）。3. 在Java 语言中，基本数据类型包括（ 浮点型 float、double ）、字符类型（ char ）、布尔类型 boolean 和 数值类型（byte、short、int、long ）。4. 字符串分为两大类：一类是字符串常量（ String ）；另一类是字符串变量（ StringBuffer ）。三、简答题1. 接口和抽象类有什么区别？答案：接口（interface）和抽象类（abstract class）是支持抽象类定义的两种机制（注意，该句中前后两个抽象类的意义不一样，前者表示的是一个实体，后者表示的是一个概念）。两者具有很大的相似性，甚至有时候是可以互换的。但同时，两者也存在很大的区别。具体而言，接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的，如果一个类中包含抽象方法，那么这个类就是抽象类。在Java 语言中，可以通过把类或者类中的某些方法声明为abstract（abstract 只能用来修饰类或者方法，不能用来修饰属性）来表示一个类是抽象类。接口就是指一个方法的集合，接口中的所有方法都没有方法体，在Java 语言中，接口是通过关键字interface 来实现的。包含一个或多个抽象方法的类就必须被声明为抽象类，抽象类可以声明方法的存在而不去实现它，被声明为抽象的方法不能包含方法体。在抽象类的子类中，实现方法必须含有相同的或者更低的访问级别（public-&gt;protected-&gt;private）。抽象类在使用的过程中不能被实例化，但是可以创建一个对象使其指向具体子类的一个实例。抽象类的子类为父类中所有的抽象方法提供具体的实现，否则，它们也是抽象类。接口可以被看作是抽象类的变体，接口中所有的方法都是抽象的，可以通过接口来间接地实现多重继承。接口中的成员变量都是static final类型，由于抽象类可以包含部分方法的实现，所以，在一些场合下抽象类比接口存在更多的优势。接口与抽象类的相同点如下：1）都不能被实例化。2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能被实例化。接口与抽象类的不同点如下：1）接口只有定义，不能有方法的实现，而抽象类可以有定义与实现，即其方法可以在抽象类中被实现。2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类，因此，使用接口可以间接地达到多重继承的目的。3）接口强调特定功能的实现，其设计理念是“has-a”关系，而抽象类强调所属关系，其设计理念为“is-a”关系。4）接口中定义的成员变量默认为public static final，只能够有静态的不能被修改的数据成员，而且，必须给其赋初值，其所有的成员方法都是public、abstract 的，而且只能被这两个关键字修饰。而抽象类可以有自己的数据成员变量，也可以有非抽象的成员方法，而且，抽象类中的成员变量默认为default，当然也可以被定义为private、protected 和public，这些成员变量可以在子类中被重新定义，也可以被重新赋值，抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized 和native 等访问修饰符修饰，同时方法必须以分号结尾，并且不带花括号{}。所以，当功能需要累积时，使用抽象类；不需要累积时，使用接口。5）接口被运用于实现比较常用的功能，便于日后维护或者添加删除方法，而抽象类更倾向于充当公共类的角色，不适用于日后重新对里面的代码进行修改。2. 实现多线程的方法有哪几种？答案：Java 虚拟机（Java Virtual Machine，JVM，是运行所有Java 程序的抽象计算机，是Java 语言的运行环境）允许应用程序并发地运行多个线程。在Java 语言中，多线程的实现一般有以下三种方法：1）实现Runnable 接口，并实现该接口的run()方法。以下是主要步骤：① 自定义类并实现Runnable 接口，实现run()方法。② 创建Thread 对象，用实现Runnable 接口的对象作为参数实例化该Thread 对象。③ 调用Thread 的start()方法。3. 利用递归方法求6!答案：本题考查的是递归知识。使用递归时，关键问题是要明白递归表达式的含义以及递归的终止条件。实现代码如下：public class Test { public static long fac(int n) { if(n &gt; 1) return (n * fac(n - 1)); else return 1; } public static void main(String[] args) { System.out.println(fac(6)); }}程序运行的结果为 7204. 用Java 语言实现一个观察者模式。答案：观察者模式（也被称为发布/订阅模式）提供了避免组件之间紧密耦合的另一种方法，它将观察者和被观察的对象分离开。在该模式中，一个对象通过添加一个方法（该方法允许另一个对象，即观察者注册自己）使本身变得可观察。当可观察的对象更改时，它会将消息发送到已注册的观察者。这些观察者收到消息后所执行的操作与可观察的对象无关，这种模式使得对象可以相互对话，而不必了解原因。Java 语言与C#语言的事件处理机制就是采用的此种设计模式。例如，用户界面（同一个数据可以有多种不同的显示方式）可以作为观察者，业务数据是被观察者，当数据有变化后会通知界面，界面收到通知后，会根据自己的显示方式修改界面的显示。面向对象设计的一个原则是：系统中的每个类将重点放在某一个功能上，而不是其他方面。一个对象只做一件事情，并且将它做好。观察者模式在模块之间划定了清晰的界限，提高了应用程序的可维护性和重用性。设计类图如图1 所示。图1👆具体的实现代码的继承关系如图2所示：图2👆下面给出一个观察者模式的示例代码，代码的主要功能是实现天气预报，同样的温度信息可以有多种不同的展示方式：package io.zwt.observer;public interface Subject { void registerObserver(Observer o); void removeObserver(Observer o); void notifyObservers();}package io.zwt.observer;public interface Observer { // 更新温度 void update(float temp);}package io.zwt.observer;import java.util.ArrayList;public class Whether implements Subject { private final ArrayList&lt;Observer&gt; observers = new ArrayList&lt;&gt;(); private float temperature; @Override public void registerObserver(Observer o) { this.observers.add(o); } @Override public void removeObserver(Observer o) { this.observers.remove(o); } @Override public void notifyObservers() { for (Observer observer : this.observers) { observer.update(temperature); } } public void whetherChange() { this.notifyObservers(); } public float getTemperature() { return temperature; } public void setTemperature(float temperature) { this.temperature = temperature; notifyObservers(); }}package io.zwt.observer;public class WhetherDisplay1 implements Observer { private float temperature; public WhetherDisplay1(Subject whether) { whether.registerObserver(this); } @Override public void update(float temp) { this.temperature = temp; display(); } private void display() { System.out.println(\"display1****:\" + this.temperature); }}package io.zwt.observer;public class WhetherDisplay2 implements Observer { private float temperature; public WhetherDisplay2(Subject whether) { whether.registerObserver(this); } @Override public void update(float temp) { this.temperature = temp; display(); } private void display() { System.out.println(\"display1----:\" + this.temperature); }}5. 一个有10 亿条记录的文本文件，已按照关键字排好序存储，请设计一个算法，可以从文件中快速查找指定关键字的记录。答案: 10 亿条记录对应的数量在 GB 量级,对于普通的计算机来讲,没有这么大的内存空间供使用,因此,无法一次把这些数据信息全部都读到内存中进行处理,需要对问题进行分解,例如把数据分成 100 份,每一份就是 100MB 量级,基本上放入内存无压力了.把这 10 亿条记录,均分为 100 份, 把每份的第一条记录关键字和此纪录对应的文件偏移量先扫入内存(类似索引),这里需要磁盘随机 IO 100 次.这样可以马上定位出指定关键字所在的记录块,把相应的记录块拿到内存,二分查找即可." }, { "title": "OCP-1Z0-816模拟测试2回顾", "url": "/2020/03/28/ocp-mock-test2-review/", "categories": "", "tags": "Java, 1Z0-816, 认证考试", "date": "2020-03-28 12:20:00 +0800", "snippet": "1. Givenclass Booby {}class Dooby extends Booby {}class Tooby extends Dooby {}public class TestClass { Booby b = new Booby(); Tooby t = new Tooby(); public void do1(List&lt;? super Dooby&gt; dataList) { //1 INSERT CODE HERE } public void do2(List&lt;? extends Dooby&gt; dataList) { //2 INSERT CODE HERE }}and the following four statements: b = dataList.get(0); t = dataList.get(0); dataList.add(b); dataList.add(t);What can be inserted in the above code? Statements 1 and 3 can inserted at //1 and Statements 2 and 4 can be inserted at //2. Statement 4 can inserted at //1 and Statement 1 can be inserted at //2. Statements 3 and 4 can inserted at //1 and Statements 1 and 2 can be inserted at //2. Statements 1 and 2 can inserted at //1 and Statements 3 and 4 can be inserted at //2. Statement 1 can inserted at //1 and Statement 4 can be inserted at //2.Explanation addData1(List&lt;? super Dooby&gt; dataList)This means that dataList is a List whose elements are of a class that is either Dooby or a super class of Dooby. We don’t know which super class of Dooby. Thus, if you try to add any object to dataList, it has to be a assignable to Dooby.Thus, dataList.add(b); will be invalid because b is not assignable to Dooby.Further, if you try to take some object out of dataList, that object will be of a class that is either Dooby or a Superclass of Dooby. Only way you can declare a variable that can be assigned the object retrieved from dataList is Object obj. Thus, t = dataList.get(0); and b = dataList.get(0); are both invalid. addData2(List&lt;? extends Dooby&gt; dataList)This means that dataList is a List whose elements are of a class that is either Dooby or a subclass of Dooby. Since we don’t know which subclass of Dooby is the list composed of, there is no way you can add any object to this list.If you try to take some object out of dataList, that object will be of a class that is either Dooby or a subclass of Dooby and thus it can be assigned to a variable of class Dooby or its superclass.. Thus, t = dataList.get(0); is invalid. 泛型规则（JLS）A type argument $T_1$ is said to contain another type argument $T_2$, written $T_2 &lt;= T_1$, is the set of types denoted by $T_2$ is provably a subset of the set of types denoted by $T_1$ under the reflexive and transitive closure of the following rules(where $&lt;:$ denotes subtyping($\\S4.10$)): $?\\space extends\\space T&lt;=\\space ?\\space extends \\space S$ if $T &lt;: S$ $?\\space extends \\space T&lt;=\\space ?$ $?\\space super \\space T&lt;=\\space ?\\space super \\space S$ if $T &lt;: S$ $?\\space super \\space T&lt;=\\space ?$ $?\\space super \\space T&lt;=\\space ? \\space extends \\space Object$ $ T&lt;=\\space T$ $T &lt;= \\space ? \\space extends \\space T$ $T &lt;= \\space ? \\space super \\space T$2.Given the following RDBMS table information :STUDENT TableSID INT Primary Key NAME VARCHAR(50)GPA INTand the following code:Statement stmt = connection.createStatement(); ResultSet rs = stmt.executeQuery(\"select SID, NAME, GPA from STUDENT\"); while(rs.next()){ System.out.println( INSERT CODE HERE ); } connection.close(); What can be inserted in the above code so that it will print the GPA value for each student? (Assume that items not specified such as import statements and try/catch block are all valid.) rs.getString(2) The numbering of columns in a ResultSet stars with 1. Therefore, it should be rs.getString(3). rs.getString(3) Although the value of the GPA field is int, it can still be retrieved using getString().Note that if a field is of type VARCHAR and if you try to retrieve the value using say getInt(), it may throw an exception at runtime if the value cannot be parsed into an Integer. rs.getInt(2) The numbering of columns in a ResultSet starts with 1. Therefore, it should be rs.getInt(3). rs.getInteger(2) rs.getInt(“GPA”)3.Given:class Item { private int id; private String name; public Item(int id, String name) { this.id = id; this.name = name; } public Integer getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String toString() { return name; }}public class Test { public static void main(String[] args) { List&lt;Item&gt; l = Arrays.asList( new Item(1, \"Screw\"), new Item(2, \"Nail\"), new Item(3, \"Bolt\") ); l.stream() // INSERT CODE HERE .forEach(System.out::print); }}Which of the following options can be inserted in the above code independent of each other, so that the code will print BoltNailScrew? .sorted((a, b)-&gt;a.getId().compareTo(b.getId())) This option creates a Comparator using a lambda expression that compares two Item objects for their id attribute. Syntactically, this option is correct but we need to sort by name instead of id. .sorted(Comparator.comparing(a-&gt;a.getName())).map((i)-&gt;i.getName()) This option uses Comparator’s comparing method that accepts a function that extracts a Comparable sort key, and returns a Comparator that compares by that sort key. Note that this is helpful only if the type of the object returned by the function implements Comparable. Here, it returns a String, which does implement Comparable and so it is ok. Although the map part is not required because Item class overrides the toString method to print the name anyway, it is valid. .map((i)-&gt;i.getName()) Just mapping the Items to their names will not help because we need to sort the elements as well. .map((i)-&gt;i.getName()).sorted() The call to map converts the stream of Items to a stream of Strings. The call to sorted() sorts the stream of String by their natural order, which is what we want here. 5.Given:List&lt;Integer&gt; ls = Arrays.asList(3,4,6,9,2,5,7);System.out.println(ls.stream().reduce(Integer.MIN_VALUE, (a, b)-&gt;a&gt;b?a:b)) //1System.out.println(ls.stream().max(Integer::max).get()); //2System.out.println(ls.stream().max(Integer::compare).get()); //3System.out.println(ls.stream().max((a, b)-&gt;a&gt;b?a:b)); //4Which of the above statements will print 9? 1 and 4 2 and 3 1 and 3 2,3, and 4 All of them. None of them.ExplanationThe code will print:939Optional[3]You need to understand the following points to answer this question: The reduce method needs a BinaryOperator. This interface is meant to consume two arguments and produce one output. It is applied repeatedly on the elements in the stream until only one element is left. The first argument is used to provide an initial value to start the process. (If you don’t pass this argument, a different reduce method will be invoked and that returns an Optional object. ) The Stream.max method requires a Comparator. All you need to implement this interface using a lambda expression is a reference to any method that takes two arguments and returns an int. The name of the method doesn’t matter. That is why it is possible to pass the reference of Integer’s max method as an argument to Stream’s max method. However, Integer.max works very differently from Integer.compare. The max method returns the maximum of two numbers while the compare method returns a difference between two numbers. Therefore, when you pass Integer::max to Stream’s max, you will not get the correct maximum element from the stream. That is why //2 will compile but will not work correctly. //4 is basically same as //2. It will not work correctly for the same reason.6.Given:@Retention(RetentionPolicy.RUNTIME)public @interface DebugInfo { String[] params() default {\"\"}; String date() default \"\"; int depth() default 10; String value() ;}Which of the following options correctly uses the above annotation? List&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;(); al.forEach((@DebugInfo(\"lambda\") x) -&gt;{ System.out.println(x);}); It is possible to annotate lambda parameters but to do that the type of the lambda parameter must be specified. List&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;(); al.forEach((@DebugInfo(\"lambda\") var x) -&gt;{ System.out.println(x);}); Normally, when a lambda express requires only a single parameter, you don’t need to specify its type because it can be inferred by the compiler. However, in that case, you cannot apply an annotation to it. To be able to apply an annotation and to get the benefit of type inferencing, you can specify the type of the variable as var. List&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;(); al.forEach((@DebugInfo(\"lambda\") Integer x) -&gt;System.out.println(x)); @DebugInfo( \"01/01/2019\") void applyLogic(int index){ } Since there is only one element in the @DebugInfo annotation that does not have a default value and since its name is value, you can pass a value for this element directly without specifying the name. BinaryOperator&lt;Integer&gt; bin = @DebugInfo(\"lambda\")( a, b)-&gt; a+b; The annotation is not placed correctly. You can do something like this: BinaryOperator&lt;Integer&gt; bin = ( @DebugInfo(\"lambda\") Integer a, Integer b)-&gt; a+b; or BinaryOperator&lt;Integer&gt; bin = ( @DebugInfo(\"lambda1\") Integer a, @DebugInfo(\"lambda1\") Integer b)-&gt; a+b; or even this: BinaryOperator&lt;Integer&gt; bin = ( @DebugInfo(\"lambda\") var a, var b)-&gt; a+b; But you cannot do: BinaryOperator&lt;Integer&gt; bin = ( @DebugInfo(\"lambda\") var a, Integer b)-&gt; a+b; because you cannot mix var and explicit types in lambda. @DebugInfo( date=new Date(), value=\"01/01/2019\") void applyLogic(int index){ } Value of an element must be a constant expression. So, new Date() is not a valid value for date element. 7.Which of the following method implementations will write a boolean value to the underlying stream? public void usePrintWriter(PrintWriter pw){ boolean bval = true;     pw.writeBoolean(bval); } PrintWriter does not have write methods such as writeInt, writeBoolean, WriteLong. It has overloaded print methods for writing various primitives. public void usePrintWriter(PrintWriter pw) throws IOException{     boolean bval = true; pw.write(bval); } PrintWriter does not have write(boolean ) method. It does have write(String), write(int ), write(char[] ) methods. It also has write(char[] buf, int off, int len) and write(String buf, int off, int len) methods that let you write a portion of the input buf. public void usePrintWriter(PrintWriter pw) throws IOException{     boolean bval = true; pw.print(bval); } Although the throws IOException clause is not required here, it is not invalid. public void usePrintWriter(PrintWriter pw) { boolean bval = true;     pw.print(bval); } public void usePrintWriter(PrintWriter pw) { boolean bval = true;     pw.println(bval); }ExplanationRemember that none of PrintWriter’s print or write methods throw I/O exceptions (although some of its constructors may). This is unlike other streams, where you need to include exception handling (i.e. a try/catch or throws clause) when you use the stream.10.Consider the following code fragment:public static void myMethod(int x) //Specify throws clause here{ try{ if(x == 0){ throw new ClassNotFoundException(); } else throw new NoSuchFieldException(); }catch(RuntimeException e){ throw e; }}Which of the following is a valid throws clause for the above method? No throws clause is necessary. throws ClassNotFoundException, NoSuchFieldException throws ClassNotFoundException throws NoSuchFieldException throws ExceptionExplanationClassNotFoundException and NoSuchFieldException are checked exceptions and are thrown when you use Java reflection mechanism to load a class and access its fields. For example:Class c = Class.forName(\"test.MyClass\"); //may throw ClassNotFoundExceptionjava.lang.reflect.Field f = c.getField(\"someField\"); //may throw NoSuchFieldException11.Which of the following are correct definitions of a repeatable annotation? public @interface Meal{ String value(); } For an annotation to be repeatable it must be defined with @Repeatable meta-annotation.@Repeatable requires the name of the container annotation class. It cannot be empty. For example, @Repeatable(Meals.class) @Repeatable(Meals.class) public @interface Meal { int id() default 0; } public @interface Meals{ Meal[] meals(); } The name of the Meal[] array should be value, not meals. public @interface Meals{ Meal[] value(); String course() default \"maincourse\"; } @Repeatable(Meals.class) public @interface Meal{ int id() default 0; String name(); } The value of the @Repeatable meta-annotation, in parentheses, is the type of the container annotation that the Java compiler generates to store repeating annotations. Containing annotation type must have a value element with an array type. The component type of the array type must be the repeatable annotation type. It is possible to use other elements in the container annotation but they must have default values. public @interface Meals{ Meal[] value(); String course(); } @Repeatable(Meals.class) public @interface Meal{ int id() default 0; String value(); } It is possible to use other elements in the container annotation but they must have default values. So, String course(); should be changed to something like String course() default “maincourse”;The reason for this restriction is simple. Java allows you to use the contained annotation and omit the container annotation. But internally, the container does create the container annotation and if there is no default value for any element of the container annotation, the compiler will not be able to supply its value. ExplanationTo make it easy to repeat annotations, Java does not require you to use the container annotation. You can just write @Meal(name=\"sandwich\") but, internally, Java converts it to @Meals(@Meal(name=\"sandwich\")). If you apply two such annotations, for example:@Meal(name=\"sandwich\")@Meal(name=\"fries\")the compiler will convert them to: @Meals({@Meal(name=\"sandwich\"), @Meal(name=\"fries\") })A container annotation is also an annotation and just like any other annotation, it can be used independently. It can have other elements as well. For example, you can use the @Meals annotation like this:@Meals(value={@Meal(name=\"sandwich\"), @Meal(name=\"fries\") }, course=\"starter\")Remember that values of a repeated annotations are not additive. So, for example, you cannot expect @Meal(id=1) and @Meal(name=\"fries\") to combine automatically to @Meal(id=1, name=\"fries\"). Since id is defined using a default value but name is not, @Meal(name=\"fries\") is valid but @Meal(id=1) is not valid.12.Your application is packaged in myapp.jar and depends on a jar named datalayer.jar, which in turn depends on mysql-connector-java-8.0.11.jar. The following packages exist in these jars:myapp.jar: com.abc.myappdatalayer.jar: com.abc.datalayermysql-connector-java-8.0.11.jar: com.mysql.jdbcYou want to use bottom up approach for migrating your app to a modular app. Which of the following is required before you can do this? Mysql driver jar and datalayer.jar must first be converted into modular jars. In this case, mysql-connector-java-8.0.11.jar would have to become modular first, then datalayer.jar.In the top down approach, on the other hand, you would directly make myapp.jar modular by including a module-info and adding requires datalayer; clause. You would create an automatic module for datalayer.jar by simply placing it on module-path (instead of classpath). You would leave mysql jar on the classpath so that datalayer could access it. datalayer.jar must first be converted into modular jar. The mysql jar need not be converted. The mysql jar must first be converted into modular jar. The datalayer.jar need not be converted. Neither datalayer nor mysql driver need to be converted into modular jars.ExplanationBottom Up Approach for modularzing an applicationWhile modularizing an app using the bottom-up approach, you basically need to convert lower level libraries into modular jars before you can convert the higher level libraries. For example, if a class in A.jar directly uses a class from B.jar, and a class in B.jar directly uses a class from C.jar, you need to first modularize C.jar and then B.jar before you can modularize A.jar.Thus, bottom up approach is possible only when the dependent libraries are modularized already.14.Given:List&lt;Integer&gt; ls = Arrays.asList(1, 2, 3);Which of the following options will compute the sum of all Integers in the list correctly? double sum = ls.stream().sum(); There no sum method in Stream. There is one in IntStream and DoubleStream. double sum = ls.stream().reduce(0, (a,b)-&gt; a+b); The reduce method performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value. double sum = ls.stream().mapToInt(x-&gt;x).sum(); double sum = 0; ls.stream().forEach(a-&gt;{sum=sum+a;}); This code is almost correct but for the fact that only final local variables can be used in a lambda expression. Here, the code is trying to use sum and sum is not final. Effectively final means that even though it is not declared as final, it is not assigned any value anywhere else after the first assignment. That compiler determines that this variable never changes and consider it as final. double sum = 0; ls.stream().peek(x-&gt;{sum=sum+x;}).forEach(y-&gt;{}); This has the same problem as above. sum is not final or effectively final. ExplanationIt is important that you go through the JavaDoc API description of the three flavors of reduce method given here: You should read about the three flavors of reduce method given here: https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html15.Given:public class Book{ private String title; private Double price; public Book(String title, Double price){ this.title = title; this.price = price; } //accessor methods not shownWhat will the following code print when compiled and run?Book b1 = new Book(\"Java in 24 hrs\", null);DoubleSupplier ds1 = b1::getPrice;System.out.println(b1.getTitle()+\" \"+ds1.getAsDouble()); Java in 24 hrs null Java in 24 hrs 0.0 Java in 24 hrs It will throw a NullPointerException. It will not compile. There is no problem with the code. Explanationjava.util.function.DoubleSupplier(and other similar Suppliers such as IntSupplier and LongSupplier) is a functional interface with the functional method named getAsDouble. The return type of this method is a primitive double (not Double). Therefore, if your lambda expression for this function returns a Double, it will automatically be converted into a double because of auto-unboxing. However, if your expression returns a null, a NullPointerException will be thrown.19.What will the following code print?import java.util.Optional;public class NewClass { public static Optional&lt;String&gt; getGrade(int marks){ Optional&lt;String&gt; grade = Optional.empty(); if(marks&gt;50){ grade = Optional.of(\"PASS\"); } else { grade.of(\"FAIL\"); } return grade; } public static void main(String[] args) { Optional&lt;String&gt; grade1 = getGrade(50); Optional&lt;String&gt; grade2 = getGrade(55); System.out.println(grade1.orElse(\"UNKNOWN\")); if(grade2.isPresent()){ grade2.ifPresent(x-&gt;System.out.println(x)); }else{ System.out.println(grade2.orElse(\"Empty\")); } }} UNKNOWN PASS Optional[UNKNOWN] PASS Optional[UNKNOWN] Optional[PASS] FAIL PASS Optional[FAIL] OPTIONAL[PASS]ExplanationYou should go through the following article about java.util.Optional:http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.htmlHere are a few important things you need to know about Optional class: Optional has a static method named of(T t) that returns an Optional object containing the value passed as argument. It will throw NullPointerException if you pass null. If you want to avoid NullPointerException, you should use Optional.ofNullable(T t) method. This will return Optional.empty if you pass null. You cannot change the contents of Optional object after creation. Optional does not have a set method. Therefore, grade.of, although technically correct, will not actually change the Optional object referred to by grade. It will return a new Optional object containing the passed argument. The orElse method returns the actual object contained inside the Optional or the argument passed to this method if the Optional is empty. It does not return an Optional object. Therefore, print(grade1.orElse(\"UNKNOWN\")) will print UNKNOWN and not Optional[UNKNOWN]. isPresent() returns true if the Optional contains a value, false otherwise. ifPresent(Consumer) executes the Consumer object with the value if the Optional contains a value. Not that it is the value contained in the Optional that is passed to the Consumer and not the Optional itself.21.Consider the following method exposed by a utility class:public static String getOptions(final String propName) { return AccessController.doPrivileged( new PrivilegedAction&lt;String&gt;() { public String run() { return System.getProperty(propName); } } ); }It has been decided to give appropriate permission in the security file for this code. Identify correct statements. It violates secure coding guidelines for invoking privileged actions. As per Guideline 9-3 / ACCESS-3: “Safely invoke java.security.AccessController.doPrivileged”, the given code should retrieve a system property using a hardcoded value instead of passing user input directly to the OS. In the given code, the user can potentially wreck the application by requesting illformated or mischievous property name. Since the code is privileged, the call may cause unwanted impact directly on the OS. It violates secure coding guidelines for exposing static methods. It violates secure coding guidelines for validating inputs. Ideally, it should validate whether the property name for which the value is requested is valid or not. It violates secure coding guidelines for protecting confidential information.22.Which of the following statements are true regarding the try-with-resources statement? Resources are closed in the same order of their creation. Resources may not be closed properly if the code in the try block throws an exception for which there is no catch block. Resources may not be closed properly if the code in the catch block throws an exception. catch and finally blocks are executed after the resources opened in the try blocks are closed.ExplanationYou need to know the following points regarding try-with-resources statement for the exam:1. The resource class must implement java.lang.AutoCloseable interface. Many standard JDK classes such as implement java.io.Closeable interface, which extends java.lang.AutoCloseable.2. AutoCloseable has only one method - public void close() throws Exception.3. Resources are closed at the end of the try block and before any catch or finally block.4. Resources are not even accessible in the catch or finally block. For example:try(Device d = new Device()){ d.read();}finally{ d.close(); //This will not compile because d is not accessible here.}Note that the try-with-resource was enhanced in Java 9 and it now allows you to use a variable declared before the try statement in the try-with-resource block. In this case, of course, the variable is accessible after the try block but the object referred to by it has been closed. For example, the following is valid since Java 9:Device d = new Device();try(d){ //valid since Java 9 ...}finally{ d.close(); //this will compile but may not work correctly because the object referred to by d has already been closed.}5. Resources are closed in the reverse order of their creation.6. Resources are closed even if the code in the try block throws an exception.7. java.lang.AutoCloseable’s close() throws Exception but java.io.Closeable’s close() throws IOException.8. If code in try block throws exception and an exception also thrown while closing is resource, the exception thrown while closing the resource is suppressed. The caller gets the exception thrown in the try block.23.What will the following code print when run?import java.nio.file.Path;import java.nio.file.Paths;public class PathTest { static Path p1 = Paths.get(\"c:\\\\finance\\\\data\\\\reports\\\\daily\\\\pnl.txt\"); public static void main(String[] args) { System.out.println(p1.subpath(0, 2)); }} finance\\data finance\\data\\ \\finance\\data\\reports c:\\finance\\data c:\\financeExplanationRemember the following points about Path.subpath(int beginIndex, int endIndex) Indexing starts from 0. Root (i.e. c:) is not considered as the beginning. name at beginIndex is included but name at endIndex is not. paths do not start or end with .Thus, in case of “c:\\finance\\data\\reports\\daily\\pnl.txt”, name at 0 is finance and name at 2 is reports. However, since the name at endIndex is excluded, subpath(0, 2) will correspond to finance\\data.The following is the API description for this method:public Path subpath(int beginIndex, int endIndex)Returns a relative Path that is a subsequence of the name elements of this path.The beginIndex and endIndex parameters specify the subsequence of name elements. The name that is closest to the root in the directory hierarchy has index 0. The name that is farthest from the root has index count-1. The returned Path object has the name elements that begin at beginIndex and extend to the element at index endIndex-1.Parameters:beginIndex - the index of the first element, inclusiveendIndex - the index of the last element, exclusiveReturns:a new Path object that is a subsequence of the name elements in this PathThrows:IllegalArgumentException - if beginIndex is negative, or greater than or equal to the number of elements. If endIndex is less than or equal to beginIndex, or larger than the number of elements.24.Consider the following code:public class AssertErrorTest{ public void robustMethod(int[] intArray) throws AssertionError { int[] newIA = //get new array by processing intArray assert newIA != intArray; }}Which of the following declarations of robustMethod(int[] intArray) are valid in a subclass of the above class? public void robustMethod(int[] intArray) public void robustMethod(int[] intArray) throws Exception Exception is in a different branch of Exceptions than AssertionError. public void robustMethod(int[] intArray) throws Throwable Throwable is a super class of AssertionError so it cannot be thrown from the subclass’s overriding method. public void robustMethod(int[] intArray) throws Error Error is also a superclass of AssertionError but any Error or any RuntimeException can be thrown without having to declare them in the throws clause. public void robustMethod(int[] intArray) throws RuntimeExceptionExplanationThis questions tests two concepts: An overriding method must not throw any new or broader checked exceptions than the ones declared in the overridden method. This means, the overriding method can only throw the exceptions or the subclasses of the exceptions declared in the overridden method. It can throw any subclass of Error or RuntimeException as well because it is not mandatory to declare Errors and RuntimeExceptions in the throws clause. An overriding method may also choose not to throw any exception at all. AssertionError is a subclass of Error.Therefore, option 1, 4, and 5 are valid.25.Given:String sentence = \"Life is a box of chocolates, Forrest. You never know what you're gonna get.\"; //1Optional&lt;String&gt; theword = Stream.of(sentence.split(\"[ ,.]\")).anyMatch(w-&gt;w.startsWith(\"g\")); //2System.out.println(theword.get()); //3Which of the following statements are correct? It may print either gonna or get It will print gonna. It may print either gonna or get if lines //2 and //3 are changed to: String theword = Stream.of(sentence.split(\"[,.]\")).anyMatch(w-&gt;w.startsWith(\"g\")); //2 System.out.println(theword.get()); //3 It may print either gonna or get if lines //2 and //3 are changed to: Optional&lt;String&gt; theword = Stream.of(sentence.split(\"[,.]\")).parallel().anyMatch(w-&gt;w.startsWith(\"g\")); //2 System.out.println(theword.get()); //3 It will fail to compile. anyMatch returns a boolean and not an Optional. Therefore, //2 will not compile.The expression Stream.of(sentence.split(“[,.]”)).anyMatch(w-&gt;w.startsWith(“g”)); will actually just return true. ExplanationanyMatch returns a boolean and not an Optional. Therefore, //2 will not compile.27.Given: Connection con = DriverManager.getConnection(dbURL); con.setAutoCommit(false); String updateString = \"update SALES \" + \"set T_AMOUNT = 100 where T_NAME = 'BOB'\"; Statement stmt = con.createStatement(); stmt.executeUpdate(updateString); //INSERT CODE HEREWhat statement can be added to the above code so that the update is committed to the database? con.setAutoCommit(true); con.commit(true); commit() does not take any parameter.FYI, there are two flavors of rollback() - one does not take any argument and another one takes a java.sql.Savepoint as an argument. stmt.commit(); con.setRollbackOnly(false) There is no such method in Connection. Node code is necessaryExplanationThis is a trick question. Since auto-commit has been disabled in the given code (by calling c.setAutoCommit(false)), you have to explicitly commit the transaction to commit the changes to the database. The regular way to do this is to call con.commit(). Notice that commit method does not take any arguments.Another way is to utilize the side effect of changing the auto-commit mode of the connection. If the setAutoCommit method is called during a transaction and the auto-commit mode is changed, the transaction is committed. If setAutoCommit is called and the auto-commit mode is not changed, the call is a no-op. In this question, con.setAutoCommit(true) changes the auto-commit mode of the connection from false to true and therefore this call commits the changes.28.What will the following code print when run?import java.nio.file.Path;import java.nio.file.Paths;public class PathTest { static Path p1 = Paths.get(\"c:\\\\a\\\\b\\\\c\"); public static String getValue(){ String x = p1.getName(1).toString(); String y = p1.subpath(1,2).toString(); return x+\" : \"+y; } public static void main(String[] args) { System.out.println(getValue()); }} \\b:\\b b:b b:b\\c\\ a:a\\b b:b\\cExplanationRemember the following points about Path.subpath(int beginIndex, int endIndex) Indexing starts from 0. Root (i.e. c:) is not considered as the beginning. name at beginIndex is included but name at endIndex is not. paths do not start or end with .Thus, if your path is “c:\\a\\b\\c”,subpath(1,1) will cause IllegalArgumentException to be thrown.subpath(1,2) will correspond to b.subpath(1,3) will correspond to b/c.Remember the following 4 points about Path.getName() method : Indices for path names start from 0. Root (i.e. c:) is not included in path names. \\ is NOT a part of a path name. If you pass a negative index or a value greater than or equal to the number of elements, or this path has zero name elements, java.lang.IllegalArgumentException is thrown. It DOES NOT return null.Thus, for example, If your Path is “c:\\code\\java\\PathTest.java”,p1.getRoot()  is c:\\  ((For Unix based environments, the root is usually / ).p1.getName(0) is codep1.getName(1) is javap1.getName(2) is PathTest.javap1.getName(3) will cause IllegalArgumentException to be thrown.29.Given:@Retention(RetentionPolicy.RUNTIME)public @interface DebugInfo { String value() default \"\"; String[] params(); String date(); int depth() default 10;}Which of the following options correctly uses the above annotation? @DebugInfo(date = \"2019\", params = \"index\") void applyLogic(int index){ } The date element is defined as String. So, it doesn’t really have to be a date. Any string value will be valid.params is defined as a String[]. So, you can either use a single string such as used in this option or a String array such as params={“index”} or params={“index1”, “whatever”} or even params={}.value and depth elements have default values so, the value for these elements can be omitted. @DebugInfo(date = \"2019-1-1\", params = { null }) void applyLogic(int index){ } You cannot set an annotation element (or its values, if it is an array) to null. @DebugInfo(depth = 10, date = \"01/01/2019\", params = {\"index\"}, value=\"applyLogic\") static final String s = null; The order of values for the elements is not important. Since @Target annotation is not specified in the definition of @DebugInfo, it will be assumed that @DebugInfo is applicable to all place where annotations can be used. @DebugInfo({\"index\"}, \"01/01/2019\") void applyLogic(int index){ } Names of the elements cannot be omitted when there are more than one values. Even when there is only one value, the name of the element can be omitted only if the name of the element is value. @DebugInfo(\"value\", params={\"index\"}, date=\"01/01/2019\") void applyLogic(int index){ } You cannot omit the name of any element, if you are specifying values for more than one element. So, you must write value=”value” instead of just “value”. 30.Given:String qr = \"insert into STOCK ( ID, TICKER, LTP, EXCHANGE ) values( ?, ?, ?, ?)\";String[] tickers = {\"AA\", \"BB\", \"CC\", \"DD\" };You are trying to initialize the STOCK table and for that you need to insert one row for each of the ticker value in the tickers array. Each row has to be initialized with the same values except the ID and TICKER columns, which are different for each row. The ID column is defined as AUTO_INCREMENT and so you need to pass only 0 for this column.Which of the following code snippets would you use? option 1for(String ticker: tickers)try(PreparedStatement ps = c.preparedStatement(qr);) { ps.setInt(1,0); ps.setString(2, ticker); ps.setDouble(3, 0.0); ps.setString(4, \"NYSE\"); ps.executeUpdate();} This will close the PreparedStatement after each insert. This is very inefficient. option 2try(PreparedStatement ps = c.prepareStatement(qr);){ for(String ticker: tickers) { ps.setInt(1, 0); ps.setString(2, ticker); ps.setDouble(3, 0.0); ps.setString(4, \"NYSE\"); ps.executeUpdate()； }} This is better than option 1 but there is no need to set the values for ID, LTP, and EXCHANGE columns in every iteration. option 3try(PreparedStatement ps = c.prepareStatement(qr);){ ps.setInt(1, 0); ps.setDouble(3, 0.0); ps.setString(4, \"NYSE\"); for(String ticker: tickers) { ps.setString(2, ticker); ps.executeUpdate()； }} All of the options will insert the required rows in the table, however, this option is most suitable because it is the most efficient of all. A PreparedStatement remembers the values once you set them until you close it. So, there is no need to reset the values for ID, LTP, and EXCHANGE columns if they are not changing. option 4for(String ticker: tickers)try(Statement s = c.createStatement(qr);){ s.executeUpdate(\"insert into STOCK (ID, TICKER, LTP, EXCHANGE ) values (0, '\"+ticker+\"', 0.0, 'NYSE')\");} This option is as bad as option 1 in terms of performance. Further, it does not offer protection from SQL injection either.31.Given that Book is a valid class with appropriate constructor and getTitle and getPrice methods that return a String and a Double respectively, what can be inserted at //1 and //2 so that it will print the price of all the books having a title that starts with “A”?List&lt;Book&gt; books = Arrays.asList( new Book(\"Atlas Shrugged\", 10.0), new Book(\"Freedom at Midnight\", 5.0), new Book(\"Gone with the wind\", 5.0));Map&lt;String, Double&gt; bookMap = //1 INSERT CODE HERE//2 INSERT CODE HEREbookMap.forEach(func); option 1books.steam().collect(Collectors.toMap((b-&gt;b.getTitle()), b-&gt;b.getPrice()));// andBiConsumer&lt;String, Double&gt; func = (a, b) -&gt; { if(a.startsWith(\"A\")) { System.out.println(b); }}; The first line generates a Map&lt;String, Double&gt; from the List using Stream’s collect method. The Collectors.toMap method uses two functions to get two values from each element of the stream.  The value returned by the first function is used as a key and the value returned by the second function is used as a value to build the resulting Map. The forEach method of a Map requires a BiConsumer. This function is invoked for each entry, that is each key-value pair, in the map. The first argument of this function is the key and the second is the value. option 2books.stream().toMap((b-&gt;b.getTitle()), b-&gt;b.getPrice()));// andBiConsumer&lt;String, Double&gt; func = (a, b) -&gt; { if(a.startsWith(\"A\")) { System.out.println(b); }}; toMap is not a valid method in Stream. option 3books.stream().toMap((b-&gt;b.getTitle()), b-&gt;b.getPrice()));// andBiConsumer&lt;Map.Entry&gt; func = (b)-&gt; { if(b.getKey().startsWith(\"A\")) { System.out.println(b.getValue()); }}; toMap is not a valid method in Stream. BiConsumer requires two generic types and two arguments. option 4books.stream().collect(Collectors.toMap((b-&gt;b.getTitle()), b-&gt;b.getPrice()));// andConsumer&lt;Map.Entry&lt;String, Double&gt;&gt; func = (e)-&gt; { if(e.getKey().startsWith(\"A\")) { System.out.println(e.getValue()); }}; The implementation of Consumer is technically correct. However, the forEach method requires a BiConsumer.33.NOTE: If you are not from a Computer Science background, this question will seem very complicated and almost unanswerable. Further, this has more to do with understanding of an algorithm than assertions. Unfortunately, we have seen similar question in the real exam. If you get such a question in your exam, our suggestion is to just mark it and move on. Attempt it only at the end if you have time.Given the following code that implements a sorting algorithm:public static void mysort(int[] values){ int n = values.length; for(int i = 1; i&lt;n; i++){ //1 int temp = values[i]; int j = i-1; while( (j&gt;-1) &amp;&amp; values[j]&gt;temp){ values[j+1] = values[j]; j--; //2 } //3 values[j+1] = temp; //4 } //5}To test the working of this code, you want to assert that the elements are partially sorted in the middle of the sorting process using this statement:assert j&lt;0 || values[j]&lt;=values[j+1];Where can this statement be put? At //1. At //2. At //3. At //4. At //5.ExplanationThe basic idea behind this algorithm is to determine the right place of an element of among the elements that appear before it in the input array. If a list contains only 1 element, then the list is always already sorted. So, the first top level iteration starts with the second element. In this iteration, the second element is put in the correct position considering just the first two elements. Thus, at the end of the first iteration, first two elements will be sorted. The process is continued till the last element is put in its right place.Try to run the above code Step by Step in an editor. Observe the values of the variables.38.What will the following code print when run? LocalDate d = LocalDate.now(); DateFormat df = new DateFormat(DateFormat.LONG); System.out.println(df.format(d)); It will print current date in LONG format. It will print the number of milliseconds since 1 Jan 1970. It will not compile. It will throw an exception at runtime.Explanationjava.text.DateFormat class provides several static getXXXInstance methods. The following are the important methods that you need to know for the exam:static DateFormat getDateInstance()          Get a default date/time formatter that uses the SHORT style for both the date and the time.static DateFormat getDateInstance(int style)          Gets the date formatter with the given formatting style for the default locale.static DateFormat getDateInstance(int style, Locale aLocale)          Gets the date formatter with the given formatting style for the given locale.static DateFormat getInstance()          Get a default date/time formatter that uses the default style for both the date and the time.Note that valid styles values are : DateFormat.DEFAULT, DateFormat.FULL, DateFormat.LONG, DateFormat.MEDIUM, and DateFormat.SHORT44.Assuming that STOCK table exists and is empty, what will the following code snippet print?String qr = \"insert into STOCK ( ID, TICKER, LTP, EXCHANGE ) values( ?, ?, ?, ?)\";try(PreparedStatement ps = c.prepareStatement(qr);){ ps.setInt(1, 111); ps.setString(2, \"APPL\"); ps.setDouble(3, 0.0); ps.setString(4, \"NYSE\"); int i = ps.executeUpdate(); //1 System.out.println(i);} It will not compile due to error at //1. It will print 0. It will print 1. executeUpdate returns the number of rows that have been affected by the query. If you execute a query that, for example, causes updates to 10 existing rows, executeUpdate would return 10. Here, 1 row has been inserted and so it will return 1. It will print 4. It will print -1.45.Given that a method named Double getPrice(String id) exists and may potentially return null, about which of the following options can you be certain that a run time exception will not be thrown? option 1Optional&lt;Double&gt; price = Optional.of(getPrice(\"1111\")); Optional.of method throws NullPointerException if you try to create an Optional with a null value. If you expect the argument to be null, you should use Optional.ofNullable method, which returns an empty Optional if the argument is null. option 2Optional&lt;Double&gt; price = Optional.ofNullable(getPrice(\"1111\")); Double x = price.orElse(getPrice(\"2222\")); option 3Optional&lt;Double&gt; price = Optional.ofNullable(getPrice(\"1111\")); Double y = price.orElseGet(()-&gt;getPrice(\"333\")); Optional’s orElseGet method takes a java.util.function.Supplier function as an argument and invokes that function to get a value if the Optional itself is empty. Just like the orElse method, this method does not throw any exception even if the Supplier returns null. It does, however, throw a NullPointerException if the Optional is empty and the supplier function itself is null. option 4Optional&lt;Double&gt; price = Optional.of(getPrice(\"1111\"), 10.0); This will not compile because Optional.of takes only one argument. option 5Optional&lt;Double&gt; price = Optional.of(getPrice(\"1111\")); Double z = price.orElseThrow(()-&gt;new RuntimeException(\"Bad Code\")); The orElseThrow method takes a Supplier function that returns an Exception. This method is useful when you want to throw a custom exception in case the Optional is empty.46.Whi of the following are correct definitions of a repeatable annotation? option 1@Repeatablepublic @interface Author { int id() default 0; String name;} @Repeatable requires the name of the container class. It cannot be empty. For example, @Repeatable(Authors.class) option 2@Repeatable(List.class)public @interface Author { int id() default 0; String name();} option 3@Repeatable(List&lt;Author&gt;)public @interface Author { int id() default 0; String name();} option 4public @interface Authors { Author[] value();}@Repeatable(Authors.class)public @interface Author { int id() default 0; String name();} The value of the @Repeatable meta-annotation, in parentheses, is the type of the container annotation that the Java compiler generates to store repeating annotations. Containing annotation type must have a value element with an array type. The component type of the array type must be the repeatable annotation type. option 5public class Authors { Author[] values;}@Repeatable(Authors.class)public @interface Author { int id() default 0; String name();} option 6public class Authors { List&lt;Author&gt; authors;}@Repeatable(Authors.class)public @interface Author { int id() default 0; String name();}48.Which of the following is correct regarding a HashSet? Elements are stored in a sorted order. TreeSet does that. It is immutable. No, you can add/remove elements to/from it. It only keeps unique elements. Elements can be accessed using a unique key. HashSet is a Set not a Map. Explanationpublic class HashSet extends AbstractSet implements Set, Cloneable, SerializableThis class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element.50.Given:public @interface Authors{ Author[] value();}@Repeatable(Authors.class)public @interface Author { int id() default 0; String value();}Identify correct usages of the above annotations.You had to select 2 options option 1@Author(1, \"bob\")@Author(2, \"alice\")public class Sample {} Must use name=value format for element values because more than one values are being specified. option 2@Authors(@Author(\"bob\"))void someMethod(int index) {} To make it easy to repeat annotations, Java does not require you to use the container annotation. You can just write @Author(“bob”) but, internally, Java converts it to @Authors(@Author(“bob”)). option 3@Authors(@Author(\"bob\"))@Authors(@Author(\"alice\"))void someMethod(int index) {} The @Author annotation is repeatable, @Authors is not! option 4@Author(\"bob\")@Authors(@Author(\"alice\"))void someMethod(int index) {} option 5@Author(\"bob\")@Author(1)void someMethod(int index) {} The two annotations are different. Their values are not additive. So, while @Author(“bob”) is valid @Author(1) is not because it does not include a value for the value element. option 6@Author(\"bob\")@Author(id=1, value=null)void someMethod(int index) {} @Author(id=1, value=null) is invalid because you cannot set an element value to null. The value must be a constant non-null value.54.Given the following code:RandomAccessFile raf = new RandomAccessFile(\"c:\\\\temp\\\\test.txt\", \"rwd\");raf.writeChars(\"hello\");raf.close();Which of the following statements are correct?(Assuming that the code has appropriate security permissions.) If the file test.txt does not exist, an attempt will be made to create it. If the file test.txt does not exist, an exception will be thrown. If the file test.txt exists, an exception will be thrown. If the file test.txt, it will be overwritten and all the existing data will be lost. Only the initial 5 characters (i.e. 10 bytes) of the file will be overwritten. Any existing data beyond 10 bytes will be left untouched. If the file test.txt exists, the given characters will be appended to the end of the existing data. When you open the file, the pointer is at the first position. So the given characters will be written at the beginning of the file. ExplanationThe permitted values for the access mode and their meanings are:“r”: Open for reading only. Invoking any of the write methods of the resulting object will cause an IOException to be thrown.“rw”: Open for reading and writing. If the file does not already exist then an attempt will be made to create it.“rws”: Open for reading and writing, as with “rw”, and also require that every update to the file’s content or metadata be written synchronously to the underlying storage device.“rwd”: Open for reading and writing, as with “rw”, and also require that every update to the file’s content be written synchronously to the underlying storage device.55.Given the following code:enum Title{ MR(\"Mr. \"), MRS(\"Mrs. \"), MS(\"Ms. \"); private String title; private Title(String s){ title = s; } public String format(String first, String last){ return title+\" \"+first+\" \"+last; }}//INSERT CODE HEREIdentify valid code snippets ..(Assume that Title is accessible wherever required.)You had to select 4 options option 1class TestClass { void someMethod() { System.out.println(Title.format(\"Rob\", \"Miller\")); }} You cannot call format method directly on Title because format is not a static method. You must call it on Title instances. For example, Title.MR.format(). option 2class TestClass { void someMethod() { System.out.println }} option 3class TestClass { void someMethod() { System.out.println(MR.format(\"Rob\", \"Miller\")); }} It must be Title.MR.format(“Rob”, “Miller”). option 4enum Title2 extends Ttile{ DR(\"Dr. \");} An enum cannot extend another enum or class. It may implement an interface though. option 5class TestClass { void someMethod() { Title.DR dr = new Title.DR(\"Dr. \"); }} Enum constants cannot be instantiated/created using the new keyword. option 6enum Title2{ DR; private Title t;} option 7enum Title2{ DR; private Title t = Title.MR;} option 8enum Title2{ DR; private Title t = Title.MR; public String format(String s) { return t.format(s, s); };}ExplanationYou need to know the following facts about enums: Enum constructor is always private. You cannot make it public or protected. If an enum type has no constructor declarations, then a private constructor that takes no parameters is automatically provided. An enum is implicitly final, which means you cannot extend it. You cannot extend an enum from another enum or class because an enum implicitly extends java.lang.Enum. But an enum can implements interfaces. Since enum maintains exactly one instance of its constants, you cannot clone it. You cannot even override the clone method in an enum because java.lang.Enum makes it final. Compiler provides an enum with two public static methods automatically - values() and valueOf(String). The values() method returns an array of its constants and valueOf() method tries to match the String argument exactly (i.e. case sensitive) with an enum constant and returns that constant if successful otherwise it throws java.lang.IllegalArgumentException. By default, an enum’s toString() prints the enum name but you can override it to print anything you want.The following are a few more important facts about java.lang.Enum which you should know: It implements java.lang.Comparable (thus, an enum can be added to sorted collections such as SortedSet, TreeSet, and TreeMap). It has a method ordinal(), which returns the index (starting with 0) of that constant i.e. the position of that constant in its enum declaration. It has a method name(), which returns the name of this enum constant, exactly as declared in its enum declaration.57.Given:module abc.print{ requires org.pdf; provides org.pdf.Print with com.abc.print.PrintImpl;}Identify correct statements about the above module. org.pdf.Print must be an interface. org.pdf.Print must be an interface or an abstract class. Ideally, Print should be an interface or an abstract class but there is no such technical restriction. As per JLS Section 7.7.4: The service must be a class type, an interface type, or an annotation type. It is a compile-time error if a provides directive specifies an enum type as the service. com.abc.print.PrintImpl must have a no-args constructor. This is not necessary. It could also have a provider method. com.abc.print.PrintImpl must implement(or extend) org.pdf.Print. This is not necessary. If PrintImpl has a provider method, then that method could return any sub-type of Print. PrintImpl does not have to be a sub-type of Print. None of the above are correct.ExplanationHere are the rules for a service provider: If a service provider explicitly declares a public constructor with no formal parameters, or implicitly declares a public default constructor, then that constructor is called the provider constructor. If a service provider explicitly declares a public static method called provider with no formal parameters, then that method is called the provider method. If a service provider has a provider method, then its return type must (i) either be declared in the current module, or be declared in another module and be accessible to code in the current module; and (ii) be a subtype of the service specified in the provides directive; or a compile-time error occurs. While a service provider that is specified by a provides directive must be declared in the current module, its provider method may have a return type that is declared in another module. Also, note that when a service provider declares a provider method, the service provider itself need not be a subtype of the service. If a service provider does not have a provider method, then that service provider must have a provider constructor and must be a subtype of the service specified in the provides directive, or a compile-time error occurs.58.Which of the following statements are correct regarding synchronization and locks? A thread shares the intrinsic lock of an object with other threads between the time the threads enter a synchronized method and exit the method. Just the opposite is true. An intrinsic lock is never shared. Once a thread acquires an intrinsic lock, it owns the lock exclusively until it releases the lock. When a synchronized method ends with a checked exception, the intrinsic lock held by the thread is released automatically. A thread will retain the intrinsic lock if the return from a synchronized method is caused due to an uncaught unchecked exception. The intrinsic lock is released when the method ends. Irrespective of how it ends. Every object has an intrinsic lock associated with it and that lock is automatically acquired by a thread when it executes a method on that object. A thread acquires the intrinsic lock of an object when it enters synchronized method on that object or when it enter a synchronized block that uses that object. The lock is not acquired when a thread enters a non-synchronized method. ExplanationPlease go through this link that explains synchronization and intrinsic locks. You will find questions in the exam that use statements given in this trail: https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html59.What will the following code print when compiled and run?import java.io.Serializable;class Booby{ int i; public Booby(){ i = 10; System.out.print(\"Booby\"); }}class Dooby extends Booby implements Serializable { int j; public Dooby(){ j = 20; System.out.print(\"Dooby\"); }}class Tooby extends Dooby{ int k; public Tooby(){ k = 30; System.out.print(\"Tooby\"); }}public class TestClass { public static void main(String[] args) throws Exception{ Tooby t = new Tooby(); t.i = 100; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"c:\\\\temp\\\\test.ser\")); oos.writeObject(t); oos.close(); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"c:\\\\temp\\\\test.ser\")); t = (Tooby) ois.readObject();ois.close(); System.out.println(t.i+\" \"+t.j+\" \"+t.k); }} Booby Dooby Tooby 100 20 30 Booby Dooby Tooby Booby Dooby Tooby 10 20 30 Booby Dooby Tooby Booby 10 20 30 Booby Dooby Tooby Booby 0 20 30 Booby Dooby Tooby Booby 100 20 30 Booby Dooby Tooby Booby Dooby Tooby 100 20 30ExplanationObjects of a class that is not marked Serializable cannot be serialized. In this question, class Booby does not implement Serializable and so, its objects cannot be serialized. Class Dooby implements Serializable and since Tooby extends Dooby, it is Serializable as well.Now, when you serialize an object of class Tooby, only the data members of Dooby and Tooby will be serialized. Data members of Booby will not be serialized. Thus, the value of i (which is 100) at the time of serialization will not be saved in the file.When reading the object back (i.e. deserializing), the constructors of serializable classes are not called. Their data members are set directly from the values present in serialized data. Constructor for unserializable classes is called. Thus, in this case, constructors of Tooby and Dooby are not called but the constructor of Booby is called. Therefore, i is set in the constructor to 10 and j and k are set using the data from the file to 20 and 30 respectively.60.Given:@Target(ElementType.TYPE)public @interface DBTable { public String value(); public String[] primarykey(); public String surrogateKey() default \"id\";}Identify correct usages of the above annotation.You had to select 2 options option 1@DBTable(\"person\", primarykey={\"name\"})interface Person {} Must use value=”person” because you are specifying values for more than one elements. option 2@DBTable(value=\"person\" primarykey={\"name\"})interface Person {} option 3@DBTable(\"person\", {\"name\"}, \"pid\")class Person {} Must use elementName=elementValue format for specifying element values because you are specifying values for more than one element. option 4@DBTable(value=\"DAYS\", primarykey=\"name\")enum DAYS { MON, TUE, WED, THU, FRI, SAT, SUN;} Since the target of @DBTable annotation is specified as ElementType.TYPE, this annotation can be used on a class, an interface, or an enum. option 5@DBTable(\"DAYS\", {\"name\"})enum DAYS { MON, TUE, WED, THU, FRI, SAT, SUN;}ExplanationThere are two rules that you need to remember while specifying values for annotation elements: You can omit the element name while specifying a value only when the name of the element is value and only when you are specifying just one value. In other words, if you are specifying values for more than one elements, you need to use the elementName=elementValue format for each element. The order of the elements is not important. If an element expects an array, you can specify the values by enclosing them in { }. But if you want to specify an array of length 1, you may omit the { }.62.What will the following code fragment print?Path p1 = Paths.get(\"x\\\\y\");Path p2 = Paths.get(\"z\");Path p3 = p1.relativize(p2);System.out.println(p3); x\\y\\z Observe what happens when you append this path to p1:x\\y + \\x\\y\\z =&gt; x\\y\\x\\y\\zThis is not same as z \\z Observe what happens when you append this path to p1:x\\y + \\z =&gt; x\\y\\zThis is not same as z ..\\z Observe what happens when you append this path to p1:x\\y + ..\\z =&gt; x\\zThis is not same as z ..\\..\\z Observe what happens when you append this path to p1:x\\y + ..\\..\\z =&gt; x + ..\\z =&gt; zThis is what we want. So this is the correct answer. A “..” implies parent folder, therefore imagine that you are taking off one “..” from the right side of the plus sign and removing the last name of the path on the left side of the plus sign.For example, .. appended to y makes it y\\.., which cancels out. ExplanationYou need to understand how relativize works for the purpose of the exam. The basic idea of relativize is to determine a path, which, when applied to the original path will give you the path that was passed. For example, “a/c” relativize “a/b” is “../b” because “/a/c/../b” is “/a/b” Notice that “c/..” cancel out.Please go through the following description of relativize() method, which explains how it works in more detail.Note that in Java 11, the paths are first normalized before relativizing.public Path relativize(Path other)Constructs a relative path between this path and a given path. Relativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is “/a/b” and the given path is “/a/b/c/d” then the resulting relative path would be “c/d”.Where this path and the given path do not have a root component, then a relative path can be constructed.A relative path cannot be constructed if only one of the paths have a root component.Where both paths have a root component then it is implementation dependent if a relative path can be constructed.If this path and the given path are equal then an empty path is returned.For any two normalized paths p and q, where q does not have a root component,p.relativize(p.resolve(q)).equals(q)When symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is “/a/b” and the given path is “/a/x” then the resulting relative path may be “../x”. If “b” is a symbolic link then is implementation dependent if “a/b/../x” would locate the same file as “/a/x”.63.What will the following code fragment print?Path p1 = Paths.get(\"\\\\personal\\\\readme.txt\");Path p2 = Paths.get(\"\\\\index.html\");Path p3 = p1.relativize(p2);System.out.println(p3); \\index.html Observe what happens when you append this path to p1:\\personal\\readme.txt + \\index.html =&gt;\\personal\\readme.txt\\index.htmlThis is not same as \\index.html \\personal\\index.html Observe what happens when you append this path to p1:\\personal\\readme.txt + \\personal\\index.html =&gt;\\personal\\readme.txt\\personal\\index.htmlThis is not same as \\index.html personal\\index.html Observe what happens when you append this path to p1:\\personal\\readme.txt + personal\\index.html =&gt;\\personal\\readme.txt\\personal\\index.htmlThis is not same as \\index.html ..\\..\\index.html Observe that if you append this path to p1, you will get p2. Therefore, this is the right answer.p1 + ....\\index.html=&gt;\\personal\\readme.txt + ....\\index.html=&gt;\\personal + ..\\index.html=&gt;\\index.html A “..” implies parent folder, therefore imagine that you are taking off one “..” from the right side of the plus sign and removing the last name of the path on the left side of the plus sign.For example, .. appended to personal makes it personal.., which cancels out. ExplanationYou need to understand how relativize works for the purpose of the exam. The basic idea of relativize is to determine a path, which, when applied to the original path will give you the path that was passed. For example, “a/c” relativize “a/b” is “../b” because “/a/c/../b” is “/a/b” Notice that “c/..” cancel out.Note that in Java 11, the paths are first normalized before computing relativizing.Please go through the following description of relativize() method, which explains how it works in more detail.public Path relativize(Path other)Constructs a relative path between this path and a given path. Relativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is “/a/b” and the given path is “/a/b/c/d” then the resulting relative path would be “c/d”.Where this path and the given path do not have a root component, then a relative path can be constructed.A relative path cannot be constructed if only one of the paths have a root component.Where both paths have a root component then it is implementation dependent if a relative path can be constructed.If this path and the given path are equal then an empty path is returned.For any two normalized paths p and q, where q does not have a root component,p.relativize(p.resolve(q)).equals(q)When symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is “/a/b” and the given path is “/a/x” then the resulting relative path may be “../x”. If “b” is a symbolic link then is implementation dependent if “a/b/../x” would locate the same file as “/a/x”.65.What will the following code print when compiled and run?interface Boiler{ public void boil(); private static void log(String msg){ //1 System.out.println(msg); } public static void shutdown(){ log(\"shutting down\"); }}interface Vaporizer extends Boiler{ public default void vaporize(){ boil(); System.out.println(\"Vaporized!\"); }}public class Reactor implements Vaporizer{ public void boil() { System.out.println(\"Boiling...\"); } public static void main(String[] args) { Vaporizer v = new Reactor(); //2 v.vaporize(); //3 v.shutdown(); //4 }} option 1Boiling...Vaporized!shutting down Compilation failure at //1. Since Java 9, an interface is allowed to have private (but not protected) static as well as instance methods. Fields of an interface are still always implicitly public, static, and final. Compilation failure at //2. Compilation failure at //4. option 5If code at //4 is changed to Vaporizer.shutdown();, it will print Boiling...Vaporized!shutting down Definition of interface Vaporizer will cause compilation to fail. Definition of interface Vaporizer is fine. ExplanationRemember that static method of an interface can only be accessed by using the name of that interface. i.e. Boiler.shutdown() in this case. This is unlike a static method of a class, which can be accessed using a subclass name or a variable name as well.66.Given:@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface DebugInfo { String value(); String[] params(); String date(); int depth();}Which of the following options correctly uses the above annotation? option 1@DebugInfo(value=\"applyLogic\", date = \"2019\", depth = 10, params = \"index\")void applyLogic(int index) {}The date element is defined as String. So, it doesn’t really have to be a date. Any string value will be valid. params is defined as a String[]. So, you can either use a single string such as used in this option or a String array such as params={\"index\"} or params={\"index1\", \"whatever\"}. option 2@DebugInfo(value=\"applyLogic\", date = \"01/01/2019\", depth = \"10\", params = \"index\" )void applyLogic(int index) {}Since depth is defined as int, you can’t pass “10”, You must pass 10 (i.e. without double quotes.) option 3@DebugInfo(value=\"applyLogic\", date=\"01/01/2019\", depth=\"10\", params = {\"index\"})void applyLogic(int index) {}Since depth is defined as int, you can’t pass “10”, You must pass 10 (i.e. without double quotes.) option 4@DebugInfo(value=\"applyLogic\", date=\"01/01/2019\")@DebugInfo(depth = 10, params = {\"index\"})void applyLogic(int index) {}Since @DebugInfo is not annotated with @Repeatable, you can use this annotation only once at any place.69.Identify the correct statements about the following code:import java.util.*;class Person { private static int count = 0; private String id = \"0\"; private String interest; public Person(String interest){ this.interest = interest; this.id = \"\" + ++count; } public String getInterest(){ return interest; } public void setInterest(String interest){ this.interest = interest; } public String toString(){ return id; }}public class StudyGroup{ String name = \"MATH\"; TreeSet&lt;Person&gt; set = new TreeSet&lt;Person&gt;(); public void add(Person p) { if(name.equals(p.getInterest())) set.add(p); } public static void main(String[] args) { StudyGroup mathGroup = new StudyGroup(); mathGroup.add(new Person(\"MATH\")); System.out.println(\"A\"); mathGroup.add(new Person(\"MATH\")); System.out.println(\"B\"); System.out.println(mathGroup.set); }} It will print : A, B, and then the contents of mathGroup.set. It will compile with a warning. It will NOT throw an exception at runtime. It will compile without warning but will throw an exception at runtime. It will only print : A It will print : A and B.ExplanationNote that TreeSet is an ordered set that keeps its elements in a sorted fashion. When you call the add() method, it immediately compares the element to be added to the existing elements and puts the new element in its appropriate place. Thus, the foremost requirement of a TreeSet is that the elements must either implement Comparable interface (which has the compareTo(Object) method) and they must also be mutually comparable or the TreeSet must be created with by passing a Comparator (which has a compare(Object, Object) method). For example, you might have two classes \\\\\\A\\\\\\ and \\\\\\B\\\\\\ both implementing Comparable interface. But if their compareTo() method does not work with both the types, you cannot add both type of elements in the same TreeSet.In this question, Person class does not implement Comparable interface. Ideally, when you add the first element, since there is nothing to compare this element to, there should be no exception. But when you add the second element, TreeSet tries to compare it with the existing element, thereby throwing ClassCastException because they don’t implement Comparable interface. However, this behavior was changed in the TreeSet implementation recently and it throws a ClassCastException when you add the first element itself.The compiler knows nothing about this requirement of TreeSet since it is an application level requirement and not a language level requirement. So the program compiles fine without any warning.70.java.util.Locale allows you to do which of the following?You had to select 2 options Provide country specific formatting for fonts. Provide country and language specific for HTML pages. Provide country and language specific formatting for Dates. Provide country specific formatting for Currencies. Provide country and language specific formatting for properties files. The objective of Localization is not to format properties files but to format the data that is displayed to the user in country/language specific manner. Resource Bundles, which are nothing but appropriately named properties files, are used along with the Locale (i.e. country and language) information to format Date, Currencies, and text messages in Locale specific manner. 73.Identify valid statements. Locale myLocal = System.getDefaultLocale(); There is no such method in System class. Locale myLocale = Locale.getDefaultLocale(); Locale myLocale = Locale.getDefault(); Locale myLocale = Locale.US; Locale class has several static constants for standard country locales. Locale myLocale = Locale.getInstance(); There is no getInstance() method in Locale. Locale myLocale = new Locale(“ru”, “RU”); You don’t have to worry about the actual values of the language and country codes. Just remember that both are two lettered codes and country codes are always upper case. 74.Consider the following classes:class Boo { public Boo(){ System.out.println(\"In Boo\"); }}class BooBoo extends Boo { public BooBoo(){ System.out.println(\"In BooBoo\"); }}class Moo extends BooBoo implements Serializable { int moo = 10; { System.out.println(\"moo set to 10\"); } public Moo(){ System.out.println(\"In Moo\"); }}First, the following code was executed and the file moo1.ser was created successfully: Moo moo = new Moo(); moo.moo = 20; FileOutputStream fos = new FileOutputStream(\"c:\\\\temp\\\\moo1.ser\"); ObjectOutputStream os = new ObjectOutputStream(fos); os.writeObject(moo); os.close();Next, the following code was executed. FileInputStream fis = new FileInputStream(\"c:\\\\temp\\\\moo1.ser\"); ObjectInputStream is = new ObjectInputStream(fis); Moo moo = (Moo) is.readObject(); is.close(); System.out.println(moo.moo);Which of the following will be a part of the output of the second piece of code? In Boo In BooBoo In Moo 10 20 moo set to 10ExplanationDuring deserialization, the constructor of the class (or any static or instance blocks) is not executed. However, if the super class does not implement Serializable, its constructor is called. So here, BooBoo and Boo are not Serializable. So, their constructor is invoked.75.What will the following code print when compiled and run?import java.util.*;interface Birdie { void fly();}class Dino implements Birdie { public void fly(){ System.out.println(\"Dino flies\"); } public void eat(){ System.out.println(\"Dino eats\");}}class Bino extends Dino { public void fly(){ System.out.println(\"Bino flies\"); } public void eat(){ System.out.println(\"Bino eats\");}}public class TestClass { public static void main(String[] args) { List&lt;Birdie&gt; m = new ArrayList&lt;&gt;(); m.add(new Dino()); m.add(new Bino()); for(Birdie b : m) { b.fly(); b.eat(); } }} option 1Dino fliesDino eatsBino fliesBino eats option 2Bino fliesBino eats option 3Dino fliesBino eats The code will not compile. Note that in the for loop b has been declared to be of type Birdie. But Birdie doesn’t define the method eat(), so the compiler will not allow b.eat() even though the actual class of the object referred to by b does have an eat() method. Exception at run time.76.Consider the following program:import java.io.FileReader;import java.io.FileWriter;public class ClosingTest { public static void main(String[] args) throws Exception { try(FileReader fr = new FileReader(\"c:\\\\temp\\\\license.txt\"); FileWriter fw = new FileWriter(\"c:\\\\temp\\\\license2.txt\") ) { int x = -1; while( (x = fr.read()) != -1){ fw.write(x); } } }}Identify the correct statements. The FileWriter object will always be closed before the FileReader object. Resources are closed automatically at the end of the try block in reverse order of their creation. The order of the closure of the FileWriter and FileReader objects is platform dependent and should not be relied upon. The order is defined. They are always closed in the reverse order. The FileWriter object will not be closed if an exception is thrown while closing the FileReader object. The close method is called on all the resources one by one even if any resource throws an exception in its close method. This is not a fail safe approach to managing resources because in certain situations one or both of the resources may be left open after the end of the try block. This is the right approach. The close method will be called automatically on all the resources that were opened even if any exception is thrown any where. 77.Given:class Book{ private String title; private double price; public Book(String title, double price){ this.title = title; this.price = price; } //getters/setters not shown}What will the following code print?List&lt;Book&gt; books = Arrays.asList(new Book(\"Thinking in Java\", 30.0), new Book(\"Java in 24 hrs\", 20.0), new Book(\"Java Recipies\", 10.0));double averagePrice = books.stream().filter(b-&gt;b.getPrice()&gt;10) .mapToDouble(b-&gt;b.getPrice()) .average().getAsDouble();System.out.println(averagePrice); It will not compile. It will thrown an exception at runtime. 0.0 25.0 10.0ExplanationThis is a straight forward code that chains three operations to a stream. First, it filters out all the element that do not satisfy the condition b.getPrice()&gt;10, which means only two elements are left in the stream, second, it maps each Book element to a double using the mapping function b.getPrice(), which means, the stream now contains two doubles - 20.0 and 30.0. Finally, the average() method computes the average of all the elements. Therefore, the code will print 25.0.This is a straight forward code that chains three operations to a stream. First, it filters out all the element that do not satisfy the condition b.getPrice()&gt;10, which means only two elements are left in the stream, second, it maps each Book element to a double using the mapping function b.getPrice(), which means, the stream now contains two doubles - 20.0 and 30.0. Finally, the average() method computes the average of all the elements. Therefore, the code will print 25.0.79.Your group has an existing application (reports.jar) that uses a library (analytics.jar) from another group in your company. Both - the application and the library - use a JDBC driver packaged in ojdbc8.jar.Which of the following options describes the steps that will be required to modularize your application? option 11. Convert analytics.jar and ojdbc8.jar into automatic modules 2. Convert reports.jar into a named module. 3. Add requires clauses for analytics and ojdbc8 in reports.jar in its module-info.java. option 21. Modularize analytics.jar and ojdbc8.jar into modules by adding module-info.java to these jars. 2. Convert reports.jar into a named module. 3. Add requires clauses for all packages contained in analytics.jar and ojdbc8.jar that are directly referred to by classes in reports.jar in its module-info.java. option 31. Convert reports.jar into a named module. 2. Add requires clauses for analytics and ojdbc8 modules in reports.jar in its module-info.java. 3. Use analytics.jar and ojdbc8.jar as unnamed modules. option 41. Convert ojdbc8.jar into automatic module. 2. Convert analytics.jar into a named module by adding module-info.java to it. In this module-info, export all packages that are used by reports.jar and add requires clauses for all packages of ojdbc.jar that are used by analytics.jar. 3. Convert reports.jar into a named module. Add requires clause for analytics module in reports's module-info.java.ExplanationIf a module directly uses classes from another jar, then that jar has to be converted into a module (either named or automatic).So, if you want to modularize reports.jar, then analytics.jar and ojdbc8.jar must also be converted into a module. Since these two jars are not controlled by you, they can be converted into automatic modules.module-info for reports.jar must have requires clauses for the two automatic modules (whose names will be analytics and ojdbc8).Since an automatic module is allowed to access classes from all other modules, nothing special needs to be done for analytics.jar. It will be able to access all classes from ojdbc.jar.80.Which of the given options if put at //1 will correctly instantiate objects of various classes defined in the following code?public class TestClass{ public class A{ } public static class B { } public static void main(String args[]){ class C{ } //1 }} new TestClass().new A(); new TestClass().new B(); new TestClass.A(); A is not static. So on outer instance of TestClass is necessary. new C(); new TestClass.C();Explanationclass A is not static inner class of TestClass. So it cannot exist without an outer instance of TestClass. So, option 1 is the right way to instantiate it. class B is static inner class and can be instantiated like this: new TestClass.B(). But new TestClass().new B() is not correct.Although not related to this question, unlike popular belief, anonymous class can never be static. Even if created in a static method.81.Consider the following code:Statement stmt = null;try(Connection c = DriverManager.getConnection(\"jdbc:derby://localhost:1527/sample\", \"app\", \"app\")){ stmt = c.createStatement(); ResultSet rs = stmt.executeQuery(\"select * from STUDENT\"); while(rs.next()){ System.out.println(rs.getString(1)); }}catch(SQLException e){ System.out.println(\"Exception \"+e);}Which objects can be successfully used to query the database after the try block ends without any exception? stmt c rs stmt as well c None of them.ExplanationThere are a few things to note in the question: Once a Connection object is closed, you cannot access any of the subsequent objects such as Statement and ResultSet that are retrieved from that Connection. The references declared in the try block (in this case, c and ResultSet) are not visible outside the try block. Not even in the catch block. When a resource is created in the try-with-resources block ( in this case, c), it is closed at the end of the try block irrespective of whether there is an exception in the try block or not.Based on the above, it is easy to see that only stmt is visible after the try block but it cannot be successfully used because the Connection object from which it was retrieved has already been closed." }, { "title": "第11章练习回顾", "url": "/2020/03/22/chapter11-exam-review/", "categories": "", "tags": "Java, OCP", "date": "2020-03-22 18:42:00 +0800", "snippet": "1. Which of the following is an advantage of the Java Platform Module System? BA. A central repository of all modulesB. Encapsulating packagesC. Encapsulating objectsD. No defined typesE. Platform independence2. Which statement is true of the following module? Dzoo.staff|---zoo|-- staff|-- Vet.javaA. The directory structure shown is a valid module.B. The directory structure would be a valid module if module.java were added directly underneath zoo.staff.C. The directory structure would be a valid module if module.java were added directly underneath zoo.D. The directory structure would be a valid module if module-info.java were added directly underneath zoo.staff.E. The directory structure would be a valid module if module-info.java were added directly underneath zoo.F. None of these changes would make this directory structure a valid module.解释： Modules are required to have a module-info.java file at the root directory of the module. Option D matches this requirement.3. B4. D -&gt; G The -m or –module option is used to specify the module and class name. The -p or -module-path option is used to specify the location of the modules. Option D would be correct if the rest of the command were correct. However, running a program requires specifying the package name with periods (.) instead of slashes. Since the command is incorrect, option G is correct.5. AF -&gt; AFG Options C and D are incorrect because there is no use keyword. Options A and F are correct because opens is for reflection and uses declares an API that consumes a service. Option G is also correct as the file can be completely empty. This is just something you have to memorize.6. BDF -&gt; BC Packages inside a module are not exported by default, making option B correct and option A incorrect. Exporting is necessary for other code to use the packages; it is not necessary to call the main() method at the command line, making option C correct and option D incorrect. The module-info.java file has the correct name and compiles, making options E and F incorrect.7. EF -&gt; DG Options A, B, E, and F are incorrect because they refer to keywords that don’t exist. The requires transitive keyword is used when specifying a module to be used by the requesting module and any other modules that use the requesting module. Therefore, dog needs to specify the transitive relationship, and option G is correct. The module puppy just needs to require dog, and it gets the transitive dependencies, making option D correct.8. ABCD -&gt; ABD Options A and B are correct because the -p (–module-path) option can be passed when compiling or running a program. Option D is also correct because jdeps can use the –module-path option when listing dependency information.9. AEF -&gt; AB The -p specifies the module path. This is just a directory, so all of the options have a legal module path. The -m specifies the module, which has two parts separated by a slash. Options E and F are incorrect since there is no slash. The first part is the module name. It is separated by periods (.) rather than dashes (-), making option C incorrect. The second part is the package and class name, again separated by periods. The package and class names must be legal Java identifiers. Dashes (-) are not allowed, ruling out option D. This leaves options A and B as the correct answers.10. B11. ABD -&gt; BDEF This is another question you just have to memorize. The jmod command has five modes you need to be able to list: create, extract, describe, list, and hash. The hash operation is not an answer choice. The other four are making options B, D, E, and F correct.12. A -&gt; B The java command uses this option to print information when the program loads. You might think jar does the same thing since it runs a program too. Alas, this parameter does not exist on jar.13. AD -&gt; E There is a trick here. A module definition uses the keyword module rather than class. Since the code does not compile, option E is correct. If the code did compile, options A and D would be correct.14. A15. AD -&gt; BD The java command has an –add-exports option that allows exporting a package at runtime. However, it is not encouraged to use it, making options B and D the answer.16. BC17. D -&gt; E18. AC19. BC20. BE21. G" }, { "title": "RSocket与Spring Security简单整合", "url": "/2020/03/10/spring-tips-rsocket-spring-security/", "categories": "", "tags": "RSocket, Spring Security, Authentication", "date": "2020-03-10 21:00:00 +0800", "snippet": "创建工程 greetings-service 在 start.spring.io 选择 2.3.0 M2 版本 Spring Boot，依赖项如下 Lombok RSocket Spring Security greetings-client 客户端的依赖项也是 Lombok RSocket Spring Security 服务端应用GreetingsServiceApplication.java // 省略导入// 一个简单的，基于用户名和密码的“问候”应用// 简单起见，所有类都写在一个文件里@SpringBootApplicationpublic class GreetingsServiceApplication { public static void main(String[] args) { SpringApplication.run(GreetingsServiceApplication.class, args); }}@Configuration@EnableRSocketSecurityclass RSocketSecurityConfiguration { @Bean RSocketMessageHandler messageHandler(RSocketStrategies strategies) { RSocketMessageHandler mh = new RSocketMessageHandler(); mh.getArgumentResolverConfigurer() .addCustomResolver(new AuthenticationPrincipalArgumentResolver()); mh.setRSocketStrategies(strategies); return mh; } // 授权 @Bean PayloadSocketAcceptorInterceptor authorization(RSocketSecurity security) { return security .authorizePayload(spec -&gt; spec .route(\"greetings\") .authenticated() .anyExchange() .permitAll()) .simpleAuthentication(Customizer.withDefaults()) .build(); } // 用户认证 Authentication @Bean MapReactiveUserDetailsService authentication() { UserDetails jlong = User.withDefaultPasswordEncoder().username(\"jlong\") .password(\"pw\").roles(\"USER\").build(); UserDetails rwinch = User.withDefaultPasswordEncoder().username(\"rwinch\") .password(\"pw\").roles(\"ADMIN\", \"USER\").build(); return new MapReactiveUserDetailsService(jlong, rwinch); }}// DTO@Data@AllArgsConstructor@NoArgsConstructorclass GreetingResponse { private String message;}@Controllerclass GreetingController { @MessageMapping(\"greetings\") Flux&lt;GreetingResponse&gt; greet(@AuthenticationPrincipal Mono&lt;UserDetails&gt; user) { return user .map(UserDetails::getUsername) .flatMapMany(GreetingController::greet); } private static Flux&lt;GreetingResponse&gt; greet(String name) { return Flux.fromStream( Stream.generate(() -&gt; new GreetingResponse(\"Hello \" + name + \" @ \" + Instant.now().toString()))) .delayElements(Duration.ofSeconds(1)); }}服务端的配置文件：application.propertiesspring.rsocket.server.port=8888客户端应用GreetingsClientApplication.java@SpringBootApplication@Log4j2public class GreetingsClientApplication { @SneakyThrows public static void main(String[] args) { SpringApplication.run(GreetingsClientApplication.class, args); System.in.read(); // 让程序不要结束 } private final MimeType mimeType = MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString()); private final UsernamePasswordMetadata credentials = new UsernamePasswordMetadata(\"jlong\", \"pw\"); // 配置所用编码器 @Bean RSocketStrategiesCustomizer rSocketStrategiesCustomizer() { return strategies -&gt; strategies.encoder(new SimpleAuthenticationEncoder()); } // 相当于客户端 @Bean RSocketRequester rSocketRequester(RSocketRequester.Builder builder) { return builder //.setupMetadata(this.credentials, this.mimeType) .connectTcp(\"localhost\", 8888) .block(); } // 应用就绪时通过RSocket向localhost:8888/greetings发起请求 // 并将响应消息通过日志输出到控制台 @Bean ApplicationListener&lt;ApplicationReadyEvent&gt; ready(RSocketRequester greetings) { return event -&gt; greetings .route(\"greetings\") .metadata(this.credentials, this.mimeType) .data(Mono.empty()) .retrieveFlux(GreetingResponse.class) .subscribe(gr -&gt; log.info(\"secured response: \" + gr.toString())); }}// DTO@Data@AllArgsConstructor@NoArgsConstructorclass GreetingResponse { private String message;}结束感觉直接看代码也挺好理解的，就不勉强添加太多文字说明了。有什么不明白的，可以看视频讲解。" }, { "title": "OCP-1Z0-816 模拟测试1回顾", "url": "/2020/02/26/ocp-mock-test1-review/", "categories": "", "tags": "Java, 1Z0-816, 认证考试", "date": "2020-02-26 15:15:00 +0800", "snippet": "4. Given:Path p1 = Paths.get(\"c:\\\\temp\\\\test1.txt\");Path p2 = Paths.get(\"c:\\\\temp\\\\test2.txt\");Which of the following code fragments moves the file test1.txt to test2.txt, even if test2.txt exists? Files.move(p1, p2); This will throw a java.nio.file.FileAlreadyExistsException if the file already exists. Files.move(p1, p2, StandardCopyOption.REPLACE_EXISTING); try(Files.move(p1, p2)) { } Files.move returns a Path object (of the destination file), which is not a resource that can be closed because it does not implement AutoCloseable interface. So this will not compile. try(Files.copy(p1, p2, StandardCopyOption.REPLACE_EXISTING)) { Files.delete(p1); } Files.copy(p1, p2, StandardCopyOption.REPLACE_EXISTING); Files.delete(p1);ExplanationFiles.copy method will copy the test1.txt into test2.txt. If test2.txt doesn’t exist, it will be created. However, Files.isSameFile method doesn’t check the contents of the file. It is meant to check if the two path objects resolve to the same file or not. In this case, they are not, and so, it will return false.The following is brief JavaDoc description for both the methods:public static Path copy(Path source, Path target, CopyOption... option) throws IOException Copy a file to a target file.This method copies a file to the target file with the options parameter specifying how the copy is performed. By default, the copy fails if the target file already exists or is a symbolic link, except if the source are the same file, in which case the method completes without copying the file.File attributes are not required to be copied to the target file. If symbolic links are supported, and the file is a symbolic link, then the final target of the link is copied. If the file is a directory in the target location(entries in the directory are not copies).The options parameter may include any of the following:REPLACE_EXISTING If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced.COPY_ATTRIBUTES Attempts to copy the file attributes associated with this file to the target file. The exact file attributes that are copied is platform and file system dependent and therefore unspecified. Minimally, the last-modified-time is copied to the target file if supported by both the source and target file store. Copying of file timestamps may result in precision loss.NOFOLLOW_LINKS Symbolic links are not followed. If the file is a symbolic link, then the symbolic link itself, not the target of the link, is copied. It is implementation specific if file attributes can be copied to the new link. In other words, the COPY_ATTRIBUTES option may be ignored when copying a symbolic link.An implementation of this interface may support additional implementation specific options.Copying a file is not an atomic operation. If an IOException is thrown then it possible that the target file is incomplete or some of its file attributes have not been copied from the source file. When the REPLACE_EXISTING option is specified and the target file exists, then the target file is replaced. The check for the existence of the file and the creation of the new file may not be atomic with respect to other file system activities.public static Path move(Path source, Path target, CopyOption... options) throws IOExceptionMove or rename a file to a target file.By default, this method attempts to move the file to the target file, failing if the target file exists except if the source and target are the same file, in which case this method has no effect. If the file is a symbolic link then the symbolic link itself, not the target of the link, is moved. This method may be invoked to move an empty directory. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. When invoked to move a directory that is not empty then the directory is moved if it does not require moving the entries in the directory. For example, renaming a directory on the same FileStore will usually not require moving the entries in the directory. When moving a directory requires that its entries be moved then this method fails (by throwing an IOException). To move a file tree may involve copying rather than moving directories and this can be done using the copy method in conjunction with the Files.walkFileTree utility method.The options parameter may include any of the following:REPLACE_EXISTING If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced.ATOMIC_MOVE The move is performed as an atomic file system operation and all other options are ignored. If the target file exists then it is implementation specific if the existing file is replaced or this method fails by throwing an IOException. If the move cannot be performed as an atomic file system operation then AtomicMoveNotSupportedException is thrown. This can arise, for example, when the target location is on a different FileStore and would require that the file be copied, or target location is associated with a different provider to this object. An implementation of this interface may support additional implementation specific options.Where the move requires that the file be copied then the last-modified-time is copied to the new file. An implementation may also attempt to copy other file attributes but is not required to fail if the file attributes cannot be copied. When the move is performed as a non-atomic operation, and a IOException is thrown, then the state of the files is not defined. The original file and the target file may both exist, the target file may be incomplete or some of its file attributes may not been copied from the original file.5. Consider the following code:class LowBalanceException extends ____ { // 1 public LowBalanceException(String msg) { super(msg); }}class WithdrawalException extends ____ { // 2 public WithdrawalException(String msg) { super(msg); }}class Account { double balance; public void withdraw(double amount) throws WithdrawalException { try { throw new RuntimeException(\"Not Implemented\"); } catch (Exception e) { throw new LowBalanceException( e.getMessage()); } } public static void main(String[] args) { try { Account a = new Account(); a.withdraw(100.0); } catch(Exception e) { System.out.println(e.getMessage()); } }}What can be inserted at // 1 and // 2 so that the above code will prints Not Implemented? Exception Exception Exception LowBalanceException WithdrawalException Exception WithdrawalException RuntimeExceptionExplanation1. The withdraw method declares that it throws WithdrawalException. This means that the only exceptions that can come out of this method are WithdrawalExceptions (which means WithdrawalException or its subclasses) or RuntimeExceptions.2. The try block in withdraw method throws a RuntimeException. It will be caught by the catch(Exception) block because RuntimeException is-a Exception. The code in the catch block throws a LowBalanceException, which is not caught. Thus, it will be thrown out of this method, which means LowBalanceException must either be a RuntimeException or be a WithdrawalException (i.e. must extend WithdrawalException) to satisfy the throws clause of the withdraw method.3. The main() method does not have a throws clause but the call to withdraw() is enclosed within a try block with catch(Exception). Thus, WithdrawalException can extend either Exception or RuntimeException.6. Which of the following lines will cause the compilation to fail?public enum EnumA{ A, AA, AAA}; //1public class TestClass //2{ public enum EnumB { B, BB, BBB }; //3 public static enum EnumC { C, CC, CCC }; //4 public TestClass() { enum EnumD { D, DD, DDD } //5 } public void methodX() { public enum EnumE{ E, EE, EEE } //6 } public static void main(String[] args) //7 { enum EnumF {F, FF, FFF }; //8 }} 1,2, or both depending on the file name. Since both EnumA and TestClass are public, they must be defined in a file with a name of EnumA.java and TestClass.java respectively. 3 A public (or non-public) enum can be defined inside any class. 4 A enum can be defined as a static member of any class. You can also have multiple public enums with in the same class. 5 An enum cannot be defined inside any method or constructor 6 An enum cannot be defined inside any method or constructor 7 There is nothing wrong with this line. 8 An enum cannot be defined inside any method or constructor ExplanationYou need to know the following facts about enums:1. Enum constructor is always private. You cannot make it public or protected. If an enum type has no constructor declarations, then a private constructor that takes no parameters is automatically provided.2. An enum is implicitly final, which means you cannot extend it.3. You cannot extend an enum from another enum or class because an enum implicitly extends java.lang.Enum. But an enum can implement interfaces.4. Since enum maintains exactly one instance of its constants, you cannot clone it. You cannot even override the clone method in an enum because java.lang.Enum makes it final.5. Compiler provides an enum with two public static methods automatically - values() and valueOf(String). The values() method returns an array of its constants and valueOf() method tries to match the String argument exactly (i.e. case sensitive) with an enum constant and returns that constant if successful otherwise it throws java.lang.IllegalArgumentException.6. By default, an enum’s toString() prints the enum name but you can override it to print anything you want.The following are a few more important facts about java.lang.Enum which you should know:1. It implements java.lang.Comparable (thus, an enum can be added to sorted collections such as SortedSet, TreeSet, and TreeMap).2. It has a method ordinal(), which returns the index (starting with 0) of that constant i.e. the position of that constant in its enum declaration.3. It has a method name(), which returns the name of this enum constant, exactly as declared in its enum declaration.8. Which statements about the following code are correct?interface House{ public default String getAddress() { return \"101 Main Str\"; }}interface Office { public static String getAddress() { return \"101 Smart Str\"; }}interface WFH extends House, Office { private boolean isOffice() { return true; }}class HomeOffice implements House, Office { public String getAddress() { return \"R No 1, Home\"; }}public class TestClass { public static void main(String[] args) { Office off = new HomeOffice(); //1 System.out.println(off.getAddress()); //2 }} Code for class HomeOffice will cause compilation to fail. Code for interface WFH will cause compilation to fail. Since Java 9, an interface is allowed to have private(but not protected) static as well as instance methods. It will compile fine and print R No 1, Home when run. Line at //1 will cause compilation to fail. Line at //2 will cause compilation to fail. Since the declared type of variable off is Office, compiler will check the call to getAddress against Office interface. However, getAddress in Office is static and Java 8 requires static interface method to be invoked using the interface name instead of a reference variable. That is why, the compiler will raise the following error message:TestClass.java:26 error: illegal static interface method call System.out.println(h.getAddress()); //2the receiver expression should be replaced with the type qualifier ‘Office’1 error 9. Given:class Booby {}class Dooby extends Booby {}class Tooby extends Dooby {}and the following declarations: List&lt;? super Booby&gt; bV = null;List&lt;? extends Tooby&gt; tV = null;Which of the following statements will compile without any error?11.14.15.17.20.21.25.27.29.30.31.32.33.34.35.36.39.41.42.43.45.46.48.49.50.51.53.57.58.60.61.63.64.65.66.67.70.71.73.78.80.81.82.83.How many methods have to be provided by a class that is not abstract and that implements Serializable interface? 0 Serializable interface does not declare any methods. That is why is also called as a “marker” interface. 1 2 3Given that a code fragment has just created a JDBC Connection and has executed an update statement, which of the following statements is correct? Changes to the database are pending a commit call on the connection. Changes to the database will be rolled back if another update is executed without committing the previous update. Changes to the database will be committed right after the update statement has completed execution. A Connection is always in auto-commit mode when it is created. As per the problem statement, an update was fired without explicitly disabling the auto-commit mode, the changes will be committed right after the update statement has finished execution. Changes to the database will be committed when another query (update or select) is fired using the connection.ExplanationWhen a connection is created, it is in auto-commit mode. i.e. auto-commit is enabled. This means that each individual SQL statement is treated as a transaction and is automatically committed right after it is completed. (A statement is completed when all of its result sets and update counts have been retrieved. In almost all cases, however, a statement is completed, and therefore committed, right after it is executed.)The way to allow two or more statements to be grouped into a transaction is to disable the auto-commit mode. Since it is enabled by default, you have to explicitly disable it after creating a connection by calling con.setAutoCommit(false); Which interfaces does java.util.NavigableMap extend directly or indirectly? java.util.SortedSet java.util.Map java.util.SortedMap java.util.TreeMap TreeMap is a class that implements NavigableMap interface. ConcurrentSkipListMap is the other such class. java.util.ListExplanationA NavigableMap is a SortedMap (which in turn extends Map) extended with navigation methods returning the closest matches for given search targets. Methods lowerEntry, floorEntry, ceilingEntry, and higherEntry return Map. Entry objects associated with keys respectively less than, less than or equal, greater than or equal, and greater than a give key, returning null if there is no such key. Similarly, methods lowerKey, ceilingKey, and higherKey return only the associated keys.All of these methods are designed for locating, not traversing entries.A NavigableMap may be accessed and traversed in either ascending or descending key order. The descendingMap method returns a view of the map with the senses of all relational and directional methods inverted. The performance of ascending operations and views is likely to be faster than that of descending ones. Methods subMap, headMap, and tailMap differ from the like-named SortedMap methods in accepting additional arguments describing whether lower and upper bounds are inclusive versus exclusive. Submaps of any NavigableMap must implement the NavigableMap interface.This interface additionally defines methods firstEntry, pollFirstEntry, lastEntry, and pollLastEntry that return and/or remove the least and greatest mapping, if any exist, else returning null.Implementations of entry-returning methods are expected to return Map.Entry pairs representing snapshots of mappings at the time they were produced, and thus generally do not support the optional Entry.setValue method. Note however that it is possible to change mappings in the associated map using method put.Methods subMap(K, K), headMap(K), and tailMap(K) are specified to return SortedMap to allow existing implementations of SortedMap to be compatibly retrofitted to implement NavigableMap, but extensions and implementations of this interface are encouraged to override these methods to return NavigableMap. Similarly, SortedMap.keySet() can be overridden to return NavigableSet.In which of the following cases can the Console object be acquired? When the JVM is started from an interactive command line with explicitly redirecting the standard input and output streams to Console. When the JVM is started from an interactive command line without redirecting the standard input and output streams. When the JVM is started in the background with the standard input and output streams directed to Console. When the JVM is started in the background without redirecting the standard input and output streams.ExplanationWhether a virtual machine has a console is dependent upon the underlying platform and also upon the manner in which the virtual machine is invoked. If the virtual machine is started from an interactive command line without redirecting the standard input and output streams then its console will exist and will typically be connected to the keyboard and display from which the virtual machine was launched. If the virtual machine is started automatically, for example by a background job scheduler, then it will typically not have a console.If this virtual machine has a console then it is represented by a unique instance of this class which can be obtained by invoking the System.console() method. If no console device is available then an invocation of that method will return null.Which of the following are wrapper classes for primitive types? java.lang.String java.lang.Void There is Void class but it does not wrap any primitive type. java.lang.Null There is no Null class in java. java.lang.Object None of the aboveExplanationFrequently it is necessary to represent a value of primitive type as if it were an object. There are following wrapper classes for this purpose:Byte, Char, Character, Short, Integer, Long, Float, and Double.Note that Byte, Short, Integer, Long, Float and Double extend from Number which is an abstract class. An object of type Double, for example, contains a field whose type is double, representing that value in such a way that a reference to it can be stored in a variable of reference type. These classes also provide a number of methods for converting among primitive values, as well as supporting such standard methods as equals and hasCode.It is important to understand that objects of wrapper classes are immutable.Which of the following standard functional interface returns void? Supplier It takes no argument and returns an object.T get() Function Represents a function that accepts one argument and produces a result.R apply(T t)Applies this function to the given argument. Predicate It takes and argument and returns a boolean:boolean test(T t)Evaluates this predicate on the given argument. Consumer Its functional method is:void accept(T t)Performs this operation on the given argument.It also has the following default method:default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after)Returns a composed Consumer that performs, in sequence, this operation followed by the after operation. UnaryOperator Represents an operation on a single operand that produces a result of the same type as its operand. This is a specialization of Function for the case where the operand and result are of the same type. ExplanationYou should go through the description of all the functional interfaces given hereWhich of the following switches is/are used for controlling the execution of assertions at run time? -ua -da It is a short form for ‘disable assertions’. -enableassertions -assert -keepassertionsExplanationAlthough not explicitly mentioned in the exam objectives, OCP Java 11 Part 2 Exam requires you to know about the switches used to enable and disable assertions. Here are a few important points that you should know:Assertions can be enabled or disabled for specific classes and/or packages. To specify a class, use the class name. To specify a package, use the package name followed by “…“(three dots also known as ellipses):java -ea:&lt;class&gt; myPackage.myProgramjava -da:&lt;package&gt;... myPackage.myProgramYou can have multiple -ea/-da flags on the command line. For example, multiple flags allow you to enable assertions in general, but disable them in a particular package.java -ea -da:com.xyz... myPackage.myProgramThe above command enables assertions for all classes in all packages, but then the subsequent -da switch disables them for the com.xyz package and its subpackages.To enable assertion for one package and disable for other you can use:java -ea:&lt;package1&gt;... -da:&lt;package2&gt;... myPackage.myProgramYou can enable or disable assertions in the unnamed root package (i.e. the default package) using the following commands:java -ea:... myPackage.myProgramjava -da:... myPackage.myProgramNote that when you use a package name in the ea or da flag, the flag applies to that package as well as its subpackages. For example,java -ea:com... -da:com.enthuware... com.enthuware.MainThe above command first enables assertions for all the classes in com as well as for the classes in the subpackages of com. It then disables assertions for classes in package com.enthuware and its subpackages.Another thing is that -ea/-da do not apply to system classes. For system classes (i.e. the classes that com bundled with the JDK/JRE), you need to use -enablesystemassertions/-esa or -disablesystemassertions/-dsaNote that * and ** are not valid wildcards for including subpackages.Which of these statements concerning the use of standard collection interfaces are true? None of the standard collection classes are thread safe. Vector and Hashtable are. class HashSet implements SortedSet. Collection classes implementing List cannot have duplicate elements. List is meant for ordering of elements. Duplicates are allowed. ArrayList can only accommodate a fixed number of elements. It grows as more elements are added. Some operations may throw an UnsupportedOperationException.ExplanationSome operations may throw an UnsupportedOperationException. This exception type is unchecked, and code calling these operations is not required to explicitly handle exceptions of this type.Which of the following are standard annotations used to suppress various warnings generated by the compiler? @SuppressWarning(\"rawtypes\") @SuppressWarning( {\"deprecation\", \"unchecked\"} ) @SuppressWarning(\"deprecation\", \"unchecked\") Syntax is incorrect because this annotation takes only one value type String array. So, if you want to pass multiple string values, you must pass an array containing those values. @SafeVarargs This can be used on a constructor or a method. If a constructor or a method tries to perform unsafe operations involving a var args parameter and a parameterized collection, a warning is generated. This annotation suppresses that warning. Example: @SafeVarargs // Not actually safe but still suppresses the warningstatic void m(List&lt;String&gt;... stringList) { Object[] array = stringLists; List&lt;Integer&gt; temList = Arrays.asList(42); array[0] = temList; // Semantically invalid, but compiles without warnings because of the annotation String s = stringLists[0].get(0); // Oh no, ClassCastException at runtime!} @Override This annotation is used only on methods. It causes a warning to be generated if a method does not actually override any method from the base class. It does not suppress any warning. @Deprecated This annotation causes a warning to be generated. It does not suppress any warning. ExplanationAs per JLS 11 section 9.6.4.5, @SuppressWarning must support three values: unchecked, deprecation, and removal. However, it is not an error if you use a value that is not supported by the compiler. A compiler simply ignores it.Different compilers may support more values. For example, Oracle’s javac compiler supports a large number of values (https://docs.oracle.com/en/java/javase/11/tools/javac.html). The ones that you should be aware of for the exam are: none, rawtypes, serial, and varargs.This annotation is not repeatable. Therefore, you cannot use it twice on the same type. However, you can specify multiple values like this: @SuppressWarning({ \"deprecation\", \"unchecked\"} )You are implementing a special sorting algorithm that can sort objects of different classes. Which of the following class declarations will you use? javapublic class SpecialSorter&lt;&gt; { ...} javapublic class SpecialSorter&lt;K&gt; { ...} This is the correct way to define a generic class. Within the class, you can use K as a type, for example: public class SpecialSorter&lt;K&gt; { public void sort(ArrayList&lt;K&gt; items) { K item = items.get(0); // ... }} javapublic class &lt;SpecialSorter&gt; { ...} javapublic class SpecialSorter(K) { ...} Code that uses generic collection classes can interoperate with code that uses raw collections classes because of? type erasure Type erasure means that a compiled java class does not contain any of the generic information that is present in the java file. In other words, the compiler removes the generic information from a java class when it compile it into byte code. For example, List&lt;String&gt; list; and List list; are compiled to the same byte code. Therefore, at run time, it does not matter whether you’ve used generic classes or not and this kinds of classes to interoperate because they are essentially the same class to the JVM.Type erasure ensure that no new classes are created for parameterized types; consequently, generics incur no runtime overhead. reification This is just the opposite of type erasure. Here, all the type information is preserved in the byte code. In Java, arrays are reified. For example, ArrayList[] alArray = new ArrayList[1];Collection[] cArray = alArray;cArray[0] = new HashSet(); The above code will compile fine. But it will throw an java.lang.ArrayStoreException at run time because the byte code contains the information that cArray actually points to an array of ArrayLists and not of HasSets. just in time compilation byte code instrumentation字节码操作好像有点意思。Which of the following is/are valid functional interface? javainterface F { default void m() {}} It is not a valid functional interface because it does not have an abstract method. javainterface F { default void m() {} static void n() {}} It is not a valid functional interface because it does not have an abstract method. javainterface F { void m(); void n();} It is not a valid functional interface because it has more than one abstract methods. javainterface F { default void m() { } abstract void n();} The use of abstract keyword is redundant here, but it legal. javainterface F { void m() {}} This will not compile because the method has a body but it lacks the keyword default.ExplanationA functional interface is an interface that contains exactly one abstract method. It may contain zero or more default methods and/or static methods in addition to the abstract method. Because a functional interface contains exactly one abstract method, you can omit the name of that method when you implement it using a lambda expression. For example, consider the following interface -interface Predicate&lt;T&gt; { boolean test(T t);}The purpose of this interface is to provide a method that operates on an object of class T and return a boolean.You could have a method that takes an instance of class that implements this interface defined like this -public void printImportantData(ArrayList&lt;Data&gt; dataList, Predicate&lt;Data&gt; p) { for (Data d: dataList) { if (p.test(d)) System.out.println(d); }}where Data class could be as simple as public class Data { public int value; }Now, you can call the above method as follows:printImportantData(al, (Data d) -&gt; { return d.value &gt; 1; } );Notice the lack of method name here. This is possible because the interface has only one abstract method so the compiler can figure out the name. This can be shortened to:printImportantData(al, d -&gt; d.value &gt; 1);Notice that there is no declaration of d! The compiler can figure out all information it needs because the interface has only one abstract method and that method has only one parameter. So you don’t need to write all those things in your code.Compare the above approach to the old style using an inner class that does the same thing -printImportantData(al, new Predicate&lt;Data&gt;() { public boolean test(Data d) { return d.value &gt; 1; }});The Predicate interface described above can be used anywhere there is a need to “do something with an object and return a boolean” and is actually provided by the standard java library in java.util.function package. This package provides a few other useful functional interfaces.Predicate&lt;T&gt; Represents a predicate (boolean-valued function) of one argument of type T.Consumer&lt;T&gt; Represents an operation that accepts a single input argument of type T and returns no result.Function&lt;T, R&gt; Represents a function that accepts one argument of type T and produces a result of type RSupplier&lt;T&gt; Represents a supplier of results of type T.Please see http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html for learning Lambda expressions in Java.看段代码，判断输出：import java.util.HashSet;enum SIZE { TALL, GRANDE, JUMBO;}public class CoffeeMug { public static void main(String[] args) { HashSet&lt;SIZE&gt; hs = new HashSet&lt;&gt;(); hs.add(SIZE.TALL); hs.add(SIZE.JUMBO); hs.add(SIZE.GRANDE); hs.add(SIZE.TALL); hs.add(SIZE.TALL); hs.add(SIZE.JUMBO); for(SIZE s: hs) System.out.println(s); }}There are two concepts involved in this question: A Set (such as a HashSet) does not allow duplicate elements. If you add a duplicate element, it is ignored. Thus, only three unique SIZE elements are stored.It is important to understand how the add() method of a Set works :boolean add(E o) Adds the specified element to this set if it is not already present (optional operation). More formally, adds the specified element, o, to this set if this set contains no element e such that (o==null ? e==null : o.equals(e)). If this set already contains the specified element, the call leaves this set unchanged and returns false. In combination with the restriction on constructors, this ensures that sets never contain duplicate elements. The order of elements is not defined in HashSet. So while retrieving elements, it can return them in any order.Remember that, TreeSet does store elements in their natural sorted order.Also remember that the order of Enums is the order in which they are defined. It is not necessarily same as alphabetical order of their names.Which of the following annotations are retained for run time? @SuppressWarnings It is defined with @Retention(SOURCE) @Override It is defined with @Retention(SOURCE) @SafeVarargs It is defined with @Retention(RUNTIME) @FunctionalInterface It is defined with @Retention(RUNTIME) @Deprecated It is defined with @Retention(RUNTIME) Your application needs to load a set of key value pairs from a database table which never changes. Multiple threads need to access this information but none of them changes it. Which class would be the most appropriate to store such data if the values need not be keep in a sorted fashion? Hashtable HashMap Set TreeMap ListExplanationYou should know that all Hashtable methods are synchronized and this compromises its performance for simultaneous reads.Since no thread modifies the data, it is not efficient to use a Hashtable.A HashMap is perfect choice because its methods are not synchronized and so it allows efficient multiple reads. TreeMap is used to keep the keys sorted which makes it a little bit slower than HashMap.Set and List can’t be used since we need to store Key-value pairs.A programmer has written the following code to ensure that the phone number is not null and is of 10 characters:public void processPhoneNumber(String number) { assert number != null &amp;&amp; number.length() == 10 : \"Invalid phone number\"; ...}Which of the given statements regarding the above code are correct? This is an appropriate use of assertions. This code will not work in all situations. It will not work if assertions are disabled. The given code is syntactically correct. Constrains on input parameters should be enforced using assertions.ExplanationAs a rule, assertions should not be used to assert the validity of input parameters of a public method. Since assertions may be disabled at the wish of the user of the program, input validation will not occur when assertions are disabled. A public method should ensure in all situations(whether assertions are enabled or disabled) that the input parameters are valid before proceeding with the rest of the code. For this reason, input validation should always be done using the standard exception mechanism:if(number == null || number.length() != 10) throw new RuntimeException(\"Invalid phone number\");However, assertions may be used to validate the input parameters of a private method. This is because private methods are called only by the developer of the class. Therefore, if a private method is called with an invalid parameter, this problem should be rectified at the development stage itself. It cannot occur in the production stage, so there is not need to throw an explicit exception.NIO 2 Files class文件操作， Files.copy方法However, Files.isSameFile method doesn’t check the contents of the file. It is meant to check if the two path objects resolve to the same file or not. In this case, they are not, and so, it will return false.public static Path copy(Path source, Path target, CopyOption... options) throws IOException选项参数（options parameter)可以包括以下：REPLACE_EXISTING​ If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced.COPY_ATTRIBUTES​ Attempts to copy the file attributes associated with this file to the target file. The exact file attributes that are copied is platform and file system dependent and therefore unspecified. Minimally, the last-modified-time is copied to the target file if supported by both the source and target file store. Copying of file timestamps may result in precision loss.NOFOLLOW_LINKS​ Symbolic links are not followed. If the file is a symbolic link, then the symbolic link itself, not the target of the link, is copied. It is implementation specific if file attributes can be copied to the new link. In other words, the COPY_ATTRIBUTES option may be ignored when copying a symbolic link.An implementation of this interface may support additional implementation specific options.Coping a file is not an atomic operation. If an IOException is thrown then it’s possible that the target file is incomplete or some of its file attributes have not been copied from the source file. When the REPLACE_EXISTING option is specified and the target file exists, then the target file is replaced. The check for the existence of the creation of the new file may not be atomic with respect to other file system activities.public static Path move(Path source, Path target, CopyOption... options) throws IOExceptionMove or rename a file to a target file.By default, this method attempts to move the file to the target file, failing if the target file exists except if the source and target are the same file, in which case this method has no effect. If the file is a symbolic link then the symbolic link itself, not the target of the link, is moved. This method may be invoked to move an empty directory. In some implementations a directory has entries for special files or links that are created when the directory is created. In such implementations a directory is considered empty when only the special entries exist. When invoked to move a directory that is not empty then the directory is moved if it does not require moving the entries in the directory. For example, renaming a directory on the same FileStore will usually not required moving the entries in the directory. When moving a directory requires that its entries be moved then this method fails (by throwing an IOException). To move a file tree may involve copying rather than moving directories and this can be done using the copy method in conjunction with the Files.walkFileTree utility method.The options parameter may include any of the following:REPLACE_EXISTING If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced.ATOMIC_MOVE The move is performed as an atomic file system operation and all other options are ignored. If the target file exists then it is implementation specific if the existing file is replaced or this method fails by throwing an IOException. If the move cannot be performed as an atomic file system operation then AtomicMoveNotSupportedException is thrown. This can arise, for example, when the target location is on a different FileStore and would require that the file be copied, or target location is associated with a different provider to this object. An implementation of this interface may support additional implementation specific options.Where the move requires that the file be copied then the last-modified-time is copied to the new file. An implementation may also attempt to copy other file attributes but is not required to fail if the file attributes cannot be copied. When the move is performed as a non-atomic operation, and an IOException is thrown, then the state of the files is not defined. The original file and the target file may both exist, the target file may be incomplete or some of its file attributes may not been copied from the original file." }, { "title": "816考点速记", "url": "/2020/02/26/ocp-816-learning-points/", "categories": "", "tags": "Java, 1Z0-816, 认证考试", "date": "2020-02-26 01:15:00 +0800", "snippet": "1. Unmodifiable collections using of/copyOf and Collections.unmodifiableXXX methodsjava.util.List and java.util.Set have of and copyOf static factory methods that provide a convenient way to create unmodifiable lists/sets.The of methods accept either an array or multiple individual parameters. If you pass it a collection, it will be treated as a regular object i.e. it will return a list/set containing the same collection object instead of returning a list/set containing the objects that the passed collection contains.The copyOf, on the other hand, accepts only a Collection. It iterates through the passed Collection and adds all the elements of that Collection in the returned list/set. Here are a few important points about these methods: They return unmodifiable copies of the original List/Set. Thus, any operation that tries to modify the returned list throws an java.lang.UnsupportedOperationException. The list/set returned by the of/copyOf methods is completely independent of the original collection. Thus, if you modify the original collection after passing it to of/copyOf methods, those changes will not be reflected in the list returned by the of/copyOf methods. They do not support null elements. Thus, if your array contains a null and if you try to create a List using List.of, it will throw a NullPointerException.Collections.unmodifiableXXX methodsjava.utils.Collections class also has several variations of unmodifiableXXX static methods (such as unmodifiableList(List ), unmodifiableSet(Set ), and unmodifiableMap(Map ) ). These method return an unmodifiable view of the underlying collection. The fundamental difference between Collections.unmodifiableXXX and List.of/copyOf methods is that Collections.unmodifiableList returns a view (instead of a copy) into the underlying list. Which means, if you make any changes to the underlying list after creating the view, those changes will be visible in the view. Further, Collections.unmodifiableList has no problem with nulls.The word unmodifiable in unmodifiableXXX method name refers to the fact that you cannot modify the view using a reference to view.2. Top Down Approach for modularizing an applicationWhile modularizing an app in a top-down approach, you need to remember the following points - Any jar file can be converted into an automatic module by simply putting that jar on the module-path instead of the classpath. Java automatically derives the name of this module from the name of the jar file. Any jar that is put on classpath (instead of module-path) is loaded as a part of the “unnamed” module. An explicitly named module (which means, a module that has an explicitly defined name in its module-info.java file) can specify dependency on an automatic module just like it does for any other module i.e. by adding a requires &lt;module-name&gt;; clause in its module info but it cannot do so for the unnamed module because there is no way to write a requires clause without a name. In other words, a named module can access classes present in an automatic module but not in the unnamed module. Automatic modules are given access to classes in the unnamed module (even though there is no explicitly defined module-info and requires clause in an automatic module). In other words, a class from an automatic module will be able to read a class in the unnamed module without doing anything special. An automatic module exports all its packages and is allowed to read all packages exported by other modules. Thus, an automatic module can access: all packages of all other automatic modules + all packages exported by all explicitly named modules + all packages of the unnamed module (i.e. classes loaded from the classpath). Thus, if your application jar A directly uses a class from another jar B, then you would have to convert B into a module (either named or automatic). If B uses another jar C, then you can leave C on the class path if B hasn’t yet been migrated into a named module. Otherwise, you would have to convert C into an automatic module as well.Note:There are two possible ways for an automatic module to get its name: When an Automatic-Module-Name entry is available in the manifest, its value is the name of the automatic module. Otherwise, a name is derived from the JAR filename (see the ModuleFinder JavaDoc for the derivation algorithm) - Basically, hyphens are converted into dots and the version number part is ignored. So, for example, if you put mysql-connector-java-8.0.11.jar on module path, its module name would be mysql.connector.java3. Bottom Up Approach for modularizing an applicationWhile modularizing an app using the bottom-up approach, you basically need to convert lower level libraries into modular jars before you can convert the higher level libraries. For example, if a class in A.jar directly uses a class from B.jar, and a class in B.jar directly uses a class from C.jar, you need to first modularize C.jar and then B.jar before you can modularize A.jar.Thus, bottom up approach is possible only when the dependent libraries are modularized already.4. Java Module Execution OptionsYou need to know about three command line options for running a class that is contained in a module: –module-path or -p: This option specifies the location(s) of the module(s) that are required for execution. This option is very versatile. You can specify exploded module directories, directories containing modular jars, or even specific modular or non-modular jars here. The path can be absolute or relative to the current directory. For example, –module-path c:/javatest/output/mathutils.jar or –module-path mathutils.jarYou can also specify the location where the module’s files are located. For example, if your module is named abc.math.utils and this module is stored in c:\\javatest\\output, then you can use: –module-path c:/javatest/output. Remember that c:\\javatest\\output directory must contain abc.math.utils directory and the module files (including module-info.class) must be present in their appropriate directory structure under abc.math.utils directory.You can specify as many jar files or module locations separated by path separator (; on windows and : on *nix) as required.NOTE: -p is the short form for –module-path.(Observe the single and double dashes). –module or -m: This option specifies the module that you want to run. For example, if you want to run abc.utils.Main class of abc.math.utils module, you should write –module abc.math.utils/abc.utils.MainIf a module jar specifies the Main-Class property its MANIFEST.MF file, you can omit the main class name from –module option.For example, you can write, –module abc.math.utils instead of –module abc.math.utils/abc.utils.Main.NOTE: -m is the short form for –module.(Observe the single and double dashes).Thus,java --module-path mathutils.jar --module abc.math.utils/abc.utils.Main is same asjava -p mathutils.jar -m abc.math.utils/abc.utils.MainNOTE: It is possible to treat modular code as non-modular by ignoring module options altogether. For example, if you want to run the same class using the older classpath option, you can do it like this:java -classpath mathutils.jar abc.utils.Main -classpath: Remember that modular code cannot access code present on the -classpath but “automatic modules” are an exception to this rule. When a non-modular jar is put on –module-path, it becomes an “automatic module” but it can still access all the modular as well as non-modular code. In other words, a class from an automatic module can access classes present on –module-path as well as on -classpath without having any “requires” clause (remember that there is no module-info in automatic modules).Thus, if your modular jar A depends on a non-modular jar B, you have to put that non-modular jar B on –module-path. You must also add appropriate requires clause in your module A’s module-info otherwise compilation of your module will not succeed. Further, if the non-modular jar B depends on another non-modular jar C, then the non-modular jar C may be put on the classpath or module-path. 5. Java Module Compilation OptionsFor compiling a Java class that is part of a module, you need to remember the following five command line options: –module-source-path: This option is used to specify the location of the module source files. It should point to the parent directory of the directory where module-info.java of the module is stored. For example, if your module name is moduleA, then the module-info.java for this module would be in moduleA directory and if moduleA directory exists in src directory, then –module-source-path should contain the src directory i.e. –module-source-path srcIf moduleA depends on another module named moduleB, and if moduleB directory exists in src2 directory, you can add this directory in –module-source-path as well i.e. –module-source-path src;src2. javac will compile the required files of src2 as well if the source code of moduleB is organized under src2 correctly. -d: This option is required when you use the –module-source-path option. It is used to specify the output directory. This is the directory where javac will generate the module’s package driven directory structure and the class files for the sources. For example, if you specify out as the output directory, javac will create a directory under out with the same name as the name of the module and will create class files with appropriate package driven directory structure under that directory. –module or -m: This option is used when you want to compile all the source files of a particular module. This option is helpful when you want to compile all the files at once without listing any of the source files of a module individually in the command.For example, if you have two java files in moduleA, stored under moduleA\\a\\A1.java and moduleA\\a\\A2.java, you can compile both of them at the same time using the command: java –module-source-path src -d out –module moduleAJavac will find out all the java source files under moduleA and compile all of them. It will create the class files under the output directory specified in -d option i.e. out. Thus, the out directory will now have two class files - moduleA/a/A1.class and moduleA/a/A2.class. –module-path or -p: This option specifies the location(s) of any other module upon which the module to be compiled depends and is very versatile. You can specify the exploded module directories, directories containing modular jars, or specific modular jars here. For example, if you want to compile moduleA and it depends on another module named abc.util packaged as utils.jar located in thirdpartymodules directory then your module-path can be thirdpartymodules or thirdpartymodules/utils.jar. That both the following two commands will work:javac --module-source-path src --module-path thirdpartymodules -d out --module moduleA andjavac --module-source-path src --module-path thirdpartymodules\\utils.jar -d out --module moduleANote:If your module depends on a non-modular third party jar, you need to do two things -Put that third party jar in –module-path.Putting a non-modular jar in –module-path causes that jar to be loaded as an “automatic module”. The name of this module is assumed to be same as the name of the jar minus any version numbers. For example, if you put mysql-driver-6.0.jar in –module-path, it will be loaded as an automatic module with name mysql.driver. Name derivation is explained in detail in java.lang.module.ModuleFinder JavaDoc but for the exam, just remember that hyphens are converted into dots and the version number and extension part is removed.It is also possible for a non-modular jar to specify its module name using Automatic-Module-Name: &lt;module name&gt; entry to the jar’s MANIFEST.MF.Add a requires &lt;module-name&gt;; clause in module-info of your module. -classpath: This option is used for compilation of non-modular code. If you are compiling regular non-modular code but that code depends on some classes, then you can put those classes or jars on the classpath using -classpath option.Note: This option is not helpful for compilation of modular code because classes of a modular cannot see classes on classpath. Modular code can only see other modular code. That is why, non-modular classes have to be converted into “automatic modules” and put on –module-path as explained above.6. enum pointsYou need to know the following facts about enums: Enum constructor is always private. You cannot make it public or protected. If an enum type has no constructor declarations, then a private constructor that takes no parameters is automatically provided. An enum is implicitly final, which means you cannot extend it. You cannot extend an enum from another enum or class because an enum implicitly extends java.lang.Enum. But an enum can implement interfaces. Since enum maintains exactly one instance of its constants, you cannot clone it. You cannot even override the clone method in an enum because java.lang.Enum makes it final. Compiler provides an enum with two public static methods automatically - values() and valueOf(String). The values() method returns an array of its constants and valueOf() method tries to match the String argument exactly (i.e. case sensitive) with an enum constant and returns that constant if successful otherwise it throws java.lang.IllegalArgumentException. By default, an enum’s toString() prints the enum name but you can override it to print anything you want.The following are a few more important facts about java.lang.Enum which you should know: It implements java.lang.Comparable (thus, an enum can be added to sorted collections such as SortedSet, TreeSet, and TreeMap). It has a method ordinal(), which returns the index (starting with 0) of that constant i.e. the position of that constant in its enum declaration. It has a method name(), which returns the name of this enum constant, exactly as declared in its enum declaration.7. AutoCloseable pointsYou need to know the following points regarding try-with-resources statement for the exam: The resource class must implement java.lang.AutoCloseable interface. Many standard JDK classes such as implement java.io.Closeable interface, which extends java.lang.AutoCloseable. AutoCloseable has only one method - public void close() throws Exception. Resources are closed at the end of the try block and before any catch or finally block. Resources are not even accessible in the catch or finally block. For example: try(Device d = new Device()){ d.read();}finally{ d.close(); //This will not compile because d is not accessible here.} Note that the try-with-resource was enhanced in Java 9 and it now allows you to use a variable declared before the try statement in the try-with-resource block. In this case, of course, the variable is accessible after the try block but the object referred to by it has been closed. For example, the following is valid since Java 9: Device d = new Device();try(d){ //valid since Java 9 ...}finally{ d.close(); //this will compile but may not work correctly because the object referred to by d has already been closed.} Resources are closed in the reverse order of their creation. Resources are closed even if the code in the try block throws an exception. java.lang.AutoCloseable’s close() throws Exception but java.io.Closeable’s close() throws IOException. If code in try block throws exception and an exception also thrown while closing is resource, the exception thrown while closing the resource is suppressed. The caller gets the exception thrown in the try block.8. JDBC URLThe format of a JDBC URL is : jdbc:&lt;subprotocol&gt;:&lt;subname&gt;where subprotocol defines the kind of database connectivity mechanism that may be supported by one or more drivers. The contents and syntax of the subname will depend on the subprotocol.Here are a few examples of commonly used urls for connecting to derby db (the Java database that comes bundled with various IDEs such as NetBeans) and MySQL: jdbc:derby:samplejdbc:derby://localhost:1527/samplejdbc:mysql://localhost:1527/samplejdbc:mysql://192.168.0.100:3306/testdbObserve that a JDBC url always starts with jdbc: and has at least three components separated by a two colons.It also usually includes the hostname or address and the port number on which the database is listening for the requests but that is not necessary.Most drivers allow adding more options to the URL in the subname part, for example the following JDBC url for Oracle DB specifies the type of the jdbc driver :jdbc:oracle:thin:@localhost:1521:testdbUserid and password are usually supplied separately from the URL but some drivers allow them to be specified in the URL itself. For example:jdbc:oracle:thin:scott/mypassword@//myhost:1521/orcl9. Command Line Switches for AssertionsAlthough not explicitly mentioned in the exam objectives, OCP Java 11 Part 2 Exam requires you to know about the switches used to enable and disable assertions. Here are a few important points that you should know:Assertions can be enabled or disabled for specific classes and/or packages. To specify a class, use the class name. To specify a package, use the package name followed by “…” (three dots also known as ellipses):java -ea:&lt;class&gt; myPackage.myProgramjava -da:&lt;package&gt;... myPackage.myProgramYou can have multiple -ea/-da flags on the command line. For example, multiple flags allow you to enable assertions in general, but disable them in a particular package.java -ea -da:com.xyz... myPackage.myProgramThe above command enables assertions for all classes in all packages, but then the subsequent -da switch disables them for the com.xyz package and its subpackages.To enable assertion for one package and disable for other you can use:java -ea:&lt;package1&gt;... -da:&lt;package2&gt;... myPackage.myProgramYou can enable or disable assertions in the unnamed root package (i.e. the default package) using the following commands:java -ea:... myPackage.myProgramjava -da:... myPackage.myProgramNote that when you use a package name in the ea or da flag, the flag applies to that package as well as its subpackages. For example,java -ea:com... -da:com.enthuware... com.enthuware.MainThe above command first enables assertions for all the classes in com as well as for the classes in the subpackages of com. It then disables assertions for classes in package com.enthuware and its subpackages.Another thing is that -ea/-da do not apply to system classes. For system classes (i.e. the classes that come bundled with the JDK/JRE), you need to use -enablesystemassertions/-esa or -disablesystemassertions/-dsaNote that ** and * are not valid wildcards for including subpackages." }, { "title": "816基准测试回顾", "url": "/2020/02/15/foundation-test-review/", "categories": "", "tags": "Java 11, OCP 11, 1Z0-816", "date": "2020-02-15 22:10:00 +0800", "snippet": "1. Which of the following annotations are retained for run time? @SuppressWarnings It is defined with @Retention(SOURCE) @Override It is defined with @Retention(SOURCE) @SafeVarargs It is defined with @Retention(RUNTIME) @FunctionalInterface It is defined with @Retention(RUNTIME) @Deprecated It is defined with @Retention(RUNTIME) 2. Your application needs to load a set of key value pairs from a database table which never changes. Multiple threads need to access this information but none of them changes it.Which class would be the most appropriate to store such data if the values need not be kept in a sorted fashion? Hashtable HaspMap Set TreeMap ListExplanationYou should know that all Hashtable methods are synchronized and this compromises its performance for simultaneous reads.Since not thread modifies the data, it is not efficient to use a Hashtable.A HashMap is a perfect choice because its methods are not synchronized and so it allows efficient multiple reads. TreeMap is used to keep the keys sorted which makes it a little bit slower than HashMap.Set and List can’t be used since we need to store Key-value pairs. 3. A programmer has written the following code to ensure that the phone number is not null and is of 10 characters:public void processPhoneNumber(String number) { assert number != null &amp;&amp; number.length() == 10 : \"Invalid phone number\"; ...}Which of the given statements regarding the above code are correct? This is an appropriate use of assertions. This code will not work in all situations. It will not work if assertions are disabled. The given code is syntactically correct. Constrains on input parameters should be enforced using assertions.ExplanationAs a rule, assertions should not be used to assert the validity of the input public method. Since assertions may be disabled at wish of the user of the program, input validation will not occur when assertions are disabled. A public method should ensure in all situations(whether assertions are enabled or disabled) that the input parameters are valid before proceeding with the rest of the code. For this reason, input validation should always be done using the standard exception mechanism:if(number == null || number.length() != 10) throw new RuntimeException(\"Invalid phone number\");However, assertions may be used to validate the input parameters of a private method. This is because private methods are called only by the developer of the class. Therefore, if a private method is called with an invalid parameter, this problem should be rectified at the development stage itself. It cannot occur in the production stage, so there is no need to throw an explicit exception.8. Which is/are the root interface(s) for all collection related interfaces? BaseCollection Collection List Set MapExplanationAll name-value maps such as java.util.HashMap and java.util.TreeMap implement java.util.Map and all collections such as java.util.ArrayList, and java.util.LinkedList implement java.util.Collection.9. You have a collection (say, an ArrayList) which is read by multiple reader threads and which is modified by a single writer thread. The collection allows multiple concurrent reads but does not tolerate concurrent read and write. Which of the following strategies will you use to obtain best performance? synchronize all access to the collection. While this is a valid approach, if you do this then even the reader threads will not be able to read concurrently. This will drastically reduce performance. make the collection variable final. make the collection variable final and volatile. Making it final and volatile will only ensure that all threads access the same collection object but it will not prevent simultaneous access by reader and writer threads. Wrap the collection into its synchronized version using Collections.synchronizedCollection(). This is same as option 1 and has the same issue. Encapsulate the collection into another class and use ReadWriteLock to manage read and write access.ExplanationSince the collection allows multiple simultaneous reads, it is ok for multiple threads to access the collection simultaneously if they are not modifying the collection. On the other hand, a writer thread must get sole custody of the collection before modifying. This can be easily achieved by using a ReadWriteLock. For example:public class MultipleReadersSingleWriter { private final ArrayList&lt;String&gt; theList = new ArrayList&lt;String&gt;(); //Note that ReadWriteLock is an interface. private final ReadWriteLock rwl = new ReentrantReadWriteLock(); private final Lock r = rwl.readLock(); private final Lock w = rwl.writeLock(); public String read(){ r.lock(); try{ System.out.println(\"reading\"); if(theList.isEmpty()) return null; else return theList.get(0); }finally{ r.unlock(); } } public void write(String data){ w.lock(); try{ System.out.println(\"Written \"+data); theList.add(data); }finally{ w.unlock(); } }}11. Which variables of the encapsulating class can an inner class access, if the inner class is defined in a instance method of the encapsulating class? All static variables. All final instance variables. All instance variables. All automatic variables. All final and effectively final automatic variables.Explanation Consider the following code:public class TestClass{ static int si = 10; int ii = 20; public void inner() { int ai = 30; // automatic variable ai = 31; // ai is not effectively final anymore final int fai = 40; // automatic final variable class Inner { public Inner() { System.out.println(si\" \"+ii+\" \"+fai); } } new Inner(); } public static void main(String[] args) { ne TestClass().inner(); }}As method inner() is an instance method(i.e. non-static method), si, ii, and fai are accessible in class Inner. Note that ai is not accessible because it is not effectively final. If the line ai = 31; did not exist, ai would have been accessible. If method inner() were a static method, ii would have been inaccessible. Prior to Java 8, only final local variables were accessible to the inner class but in Java 8, event effectively final local variables of the method are accessible to the inner defined in that method as well.12. Which interface would you use to represent a collection having non-unique objects in the order of insertion? Listjava.util.ListExplanationjava.util.List interface is implemented by collections that maintain sequences of possibly non-unique elements. Elements retain their ordering in the sequence. Collection classes implementing SortedSet maintain their elements sorted in the set.14. Identify the correct statement about i18n. I18N class allows you to port your code from multiple regions and/or languages. There is no class named I18N. You should use Locale and formatter objects such as NumberFormat and DateFormat to generate locale specific output. The i18n method of NumberFormat and DateFormat allows you to generate locale specific output. Using default locale for NumberFormat and DateFormat automatically ensures that the formatted text will be localized to the location - [ ] setting of the machine on which the code is run.(Assuming the default locale hasn’t been explicitly changed by any means.) When not passed to the getInstance() method, the default Locale is used, which is same as the one set by the operating system. If you want to change it,(for example, if you want to generate French format on a US machine), you must create a new Locale(\"fr\", \"FR\") object and use the following methods to get an appropriate NumberFormat or DateFormat instance -NumberFormat: NumberFormat getInstance(Locale locale)DateFormat: DateFormat getDateInstance(int style, Locale locale)Note that DateFormat does not have getInstance(Locale locale) method. i18n stands for Internationalization and it is handled automatically by Java.15. Which of the following statements are correct regarding abstract classes and interfaces? An abstract class can have private as well as static methods while an interface can not have static methods. Interfaces can have static methods(public as well as private). Interfaces cannot have protected methods. It cannot have non-public fields and instance fields. An abstract class cannot implement multiple interfaces while an interface can extend multiple interfaces. An abstract class(or any class for that matter) can implement any number of interfaces. Abstract classes can have abstract methods but interface cannot. Both abstract classes and interfaces can have abstract as well as non-abstract methods. The difference is that by default(i.e. when no modifier is specified), the methods of an abstract class have “default” access and are non-abstract(i.e. must have a body), while the methods of an interface are public and abstract. Abstract classes can have instance fields but interfaces can’t Fields of an interface are always public, static, and final. An abstract class can have final methods but an interface cannot.16. Which of the following statements are correct? Assertions can be enabled or disabled on a class basis. Yes, it can be enabled/disabled for class as well as package basis using -ea or -da flags. Assertions are appropriate to check whether method parameters are valid. Since it does not say which kind of methods (public or private), you should assume all methods. Conditional compilation is used to allow an application that uses assertions to run with maximum performance. Assertion can be disabled without recompiling the code. When an assertion fails, a programmer may either throw an exception or simply return from the method. When an assertion fails, a programmer should always throw the exception. ExplanationAn assertion signifies a basic assumption made by the programmer that he/she believes to be true at all times. It is never a wise idea to try to recover when an assertion fails because that is the whole purpose of assertions: that the program should fail if that assumption fails.17. Complete the code so that the user can enter a password on the command line.import java.io.Console;public class TestClass { public static void main(String[] args) throws Exception { Console c = System.console(); char[] cha = c.readPassword(\"Please enter password:\"); String pwd = new String(cha); System.out.println(\"pwd = \"+pwd); }}Explanation1. Console class is in java.io package.2. Correct way to retrieve the Console object is System.console(); There is only one Console object so new Console(); doesn’t make sense. And therefore, Console’s constructor is not public.3. You can read user’s input using either readLine() or readPassword(). Here, since you are reading password, readPassword() should be used. readPassword() ensures that the keys typed by the user aren’t echoed to the command prompt.19. What will the following code print?ReentrantLock rlock = new ReentrantLock();boolean f1 = rlock.lock();System.out.println(f1);boolean f2 = rlock.lock();System.out.println(f2); truetrue truefalse true It will not compile. java.util.concurrent.locks.Lock interface’s lock() method returns void, while its tryLock() returns boolean.Had the code been: ReentrantLock rlock = new ReentrantLock();boolean f1 = rlock.tryLock();System.out.println(f1);boolean f2 = rlock.tryLock();System.out.println(f2);It would have printed: truetrueNote that java.util.concurrent.locks.ReentrantLock class implements java.util.concurrent.locks.Lock interface.21. Anonymous inner classes always extend directly from the Object class. True FalseExplanationWhen you create an anonymous class for an interface, it extends from Object. For example,button.addActionListener( new ActionListener() {  public void actionPerformed(ActionEvent ae) { } }  );But if you make an anonymous class from another class then it extends from that class. For example, consider the following class:class MyListener implements ActionListener { public void actionPerformed(ActionEvent ae) { System.out.println(\"MyListener class\"); }}button.addActionListener(new MyListener() { public void actionPerformed(ActionEvent ea) { System.out.println(\"Anonymous Listener class\"); }});Here the anonymous class actually extends from MyListener class and successfully overrides the actionPerformed() method.22. Consider the following code:Locale myLoc = new Locale(\"fr\", \"FR\");ResourceBundle rb = ResourceBundle.getBundle(\"appmessages\", myLoc);//INSERT CODE HEREWhich of the following lines of code will assign a ResourceBundle for a different Locale to rb than the one currently assigned?(Assume appropriate import statements) rb = ResourceBundle.getBundle(“appmessages”, new Locale(“ch”, “CH”)); rb = ResourceBundle.getBundle(“appmessages”, CHINA); In this question, the import statements are not specified. If appropriate imports are present (i.e. import static java.util.Locale.*; ), this will work fine. In the exam, you may see a couple of question that have such ambiguous options. In our opinion, it is best not to assume anything special or out of ordinary. Therefore, this option should not be selected. myLoc.setLocale(Locale.CHINA); There is no setLocale() method in Locale. myLoc.setLocale(new Locale(“ch”, “CH”)); rb = ResourceBundle.getBundle(“appmessages”, Locale.CHINA); rb.setLocale(Locale.CHINA); There is no setLocale() method in Locale. ExplanationNote that once a ResourceBundle is retrieved, changing the Locale will not affect the ResourceBundle. You have to retrieve a new ResourceBundle by passing in the new Locale and then assign it to the variable.23. Which of these methods are defined in the Map interface? contains(Object o) addAll(Collection c) remove(Object o) values() toArray()ExplanationThe Map interface defines the methods remove(Object) and values(). It does not define methods contains(), addAll() and toArray()Methods with these names are defined in the Collection interface, but Map does not extend from Collection.24. Insert appropriate methods so that the following code will produce expected output.import java.util.*;public class TestClass { public static void main(String[] args) { NavigableSet&lt;String&gt; myset = new TreeSet&lt;String&gt;(); myset.add(\"a\"); myset.add(\"b\"); myset.add(\"c\"); myset.add(\"aa\"); myset.add(\"bb\"); myset.add(\"c\"); System.out.println(myset.floor(\"a\")); System.out.println(myset.ceiling(\"aaa\")); System.out.println(myset.lower(\"a\")); System.out.println(myset.higher(\"bb\")); }}Expected output. abnullc25. Complete the following code so that it will print each line in the given file.import java.io.*;class Liner { public void dumper(File f) throws IOException { FileReader x1 = new FileReader(f); BufferedReader x2 = new BufferedReader(x1); String x3 = x2.readLine(); while (x3 != null) { System.out.println(x3); x3 = x2.readLine(); } }}26. Which of the following statements are correct? Assertions are usually enabled in the production environment. Assertions are usually disabled in the development and testing environment. Just the reverse is true. Assertions can be enabled selectively on per class basis but not on per package basis. Assertions can be enabled selectively on per class basis as well as on per package basis. Yes, it can be enabled/disabled on class as well as package basis -ea or -da flags. It is not a good practice to write code that recovers from an assertion failure.ExplanationAn assertion signifies a basic assumption made by the programmer that he/she believes to be true at all times. It is never a wise idea to try to recover when an assertion fails is the whole prupose of assertions: that the program should fail if that assumption fails.27. Which clause(s) are used by a module definition that implements a service? exports A service provider module is not read directly by a service user module. So, exports clause is not required. provides The provider module must specify the service interface and the implementing class that implements the service interface. For example,provides org.printservice.api.Print with com.myprinter.PrintImpl uses A uses clause is used by the module that uses a service. For example,uses org.printservice.api.Print; implements This is not a valid clause in module-info. requires The implementing module must require the module that defines the service interface. ExplanationFor example, if an abc.print module implements an org.printing.Print service interface defined in PrintServiceAPI module using com.abc.PrintImpl class, then this is how its module-info should look:module abc.print { requires PrintServiceAPI; //required because this module defines the service interface org.printing.Print uses org.printing.Print; //specifies that this module uses this service //observe that abc.print module is not required.}31. Which of the following statements regarding the assertion mechanism of Java is NOT correct? Assertions require changes at the JVM level. No change is required in the JVM for supporting assertions. Assertions require changes at the API level. Besides the ‘assert’ keyword, new methods are added in java.lang.Class and java.lang.ClassLoader classes. Assertions can be enabled or disabled through the command line at the time of execution of (i.e. starting) the program. By using the switches, -ea and -da or -enableassertions or -disableassertions Code that uses Assertions cannot be run on version below 1.4 Because of the ‘assert’ keyword. Code written for JDK version 1.3 cannot be compiled under JDK version 1.4 It can be compiled by using -source flag: javac -source 1.3 classname.java 32. Identify correct statements about annotations. @SuppressWarnings can be used only on a class, constructor, or a method. Actually, it can be used on several things. Its target can be a TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, and MODULE. @Override can only be used on instance methods. @SafeVarargs can only be used on methods. It can be used on constructors and methods. @Deprecated can be used only on a class, constructor, or a method. Actually, it can be used on serval things, Its target can be a CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE,PARAMETER,TYPE. @SuppressWarnings(“all”) can be used suppress all warnings from a method or a class. Although you can pass any string value to the SuppressWarnings annotation (unrecognized values are ignored), the Java specification mandates only three values - unchecked, deprecation, and removal. Different compilers and IDEs may support other values in addition to these three. There is no rule that says the value “all” has to suppress all warnings (although a compiler or an IDE may do that upon seeing this value.) 33. Which of the following is thrown when an assertion fails? AssertionError AssertionException RuntimeException AssertionFailedException ExceptionExplanationA java.lang.AssertionError is thrown.public class java.lang.AssertionError extends java.lang.Error { public java.lang.AssertionError(); public java.lang.AssertionError(java.lang.Object); public java.lang.AssertionError(boolean); public java.lang.AssertionError(char); public java.lang.AssertionError(int); public java.lang.AssertionError(long); public java.lang.AssertionError(float); public java.lang.AssertionError(double);}38. Which of the following are required to construct a Locale? language region country country is the second parameter that may be passed while creating a Locale. It is not required though. time zone state cultureExplanationLocale needs at least a language to be constructed. It has three constructor -Locale(String language)Construct a locale from a language code.Locale(String language, String country)Construct a locale from language, countryLocale(String language, String country, String variant)Construct a locale from language, country, variantFor example:new Locale(\"fr\", \"FR\"); // language is French, Country is France.new Locale(\"fr\", \"CA\"); // language is French, Country is Canada, so this means, you are trying to use Canadian dialect of French.new Locale(\"en\", \"IN\"); // language is English, COuntry is India, so this means, you are trying to use Indian dialect of English.40. Which of the following are standard Java annotations? @NonNull This is not a standard Java annotation.Although this annotation is officially not in scope for the OCP Java 11 exam, we have seen questions on the exam that require knowledge about this annotation. It exists in Spring framework as well as in Checker Framework, which is referred in an Oracle blogIt can be applied to a field, method parameter, or method return type.org.springframework.langAnnotation Type NonNull@Target(value={METHOD,PARAMETER,FIELD})@Retention(value=RUNTIME)@Documented @Nonnull@TypeQualifierNicknamepublic @interface NonNullA common Spring annotation to declare that annotated elements cannot be null.It can be used like this:1. @NonNull String getString(@NonNull String input){ return “adsf”; };2. @NonNull String name; //instance or class fields3. Function&lt;Integer, Integer&gt; fin =  (@NonNull var x) -&gt; 2*x;//lambda expressionYou may see the details of the NonNull annotation of the checker framework here @Interned @Interned is not a standard Java annotation.Although this annotation is officially not in scope for the OCP Java 11 exam, we have seen questions on the exam that require knowledge about this annotation. It exists in Spring framework as well as in Checker Framework, which is referred in an Oracle blog @Repeatable @Retention41. A programmer wants to rename all the files in a directory (just the files and not directories) to &lt;existing filename&gt;.checked.Complete the given code so that it works as required.import java.io.File;import java.util.*;public class ChangeFileNames { public static void main(String[] args) throws Exception { File dir = new File(args[0]); if(!dir.isDirectory()) { System.out.println(args[0]+\" is not a directory.\"); return; } File[] files = dir.listFiles(); for (File oldfile : files) { // process only if oldfile is a normal file and not a directory if(!oldfile.isDirectory()) { String oldfilename = oldfile.getName(); File newfile = new File(args[0]+File.separator+oldfilename+\".checked\"); boolean b = oldfile.renameTo(newfile); if(b) System.out.println(\"Changed: \"+oldfilename+\" To \"+newfile.getName()); else System.out.println(\"Not Changed: \"+oldfilename); } } }}ExplanationThis programs illustrates the usage of many important File class methods.1. The isDirectory() method returns true if the file object represents a directory.2 and 3. File class has two methods for returning the contents of a directory (although it has more but for the exam, you need to know only these two):String[] list()Returns an array of strings naming the files and directories in the directory denoted by this abstract pathname.File[] listFiles()Returns an array of abstract pathnames denoting the files in the directory denoted by this abstract pathname.The for loop is expecting ‘files’ to be an array or a Collection of File objects. Thus, 2nd and 3rd blanks should be File[] and listFiles respectively.4. isFile() method returns true if the file object represents a normal file.5. renameTo(File newfile) renames the file to newfile.46. What classes can a non-static nested class extend?(Provided that the class to be extended is visible and is not final.) Only the encapsulating class. Any top level class. Any class. It depends on whether the inner class is defined in a method or not. None of the above.ExplanationIn general, there is no restriction on what a nested class may or may not extend.FYI, a nested class is any class whose declaration occurs within the body of another class or interface. A top level class is a class that is not a nested class. An inner class is a nested class that is not explicitly or implicitly declared static.47. A JDBC driver implementation must provide implementation classes for which of the following interfaces? java.sql.Driver java.sql.Connection java.sql.Statement java.sql.SQLException This is a class and not an interface. It is provided by the JDBC API. java.sql.Date This is a class and not an interface. It is provided by the JDBC API. Explanationjava.sql.ResultSet is another important interface that a driver must provide.Besides these, there are several interfaces and methods that a driver must provide but they are not relevant for the exam. If you want to learn more, please refer JDBC Specification.49. Identify the correct statement regarding a JDBC Connection： When a JDBC Connection is created, it is in auto-commit mode. When a JDBC Connection is created, its commit mode depends on the parameters used while creating the connection. When a JDBC Connection is created, its auto-commit feature is disabled. When a JDBC Connection is created, it is in commit mode undetermined.ExplanationWhen a connection is created, it is in auto-commit mode. i.e. auto-commit is enabled. This means that each individual SQL statement is treated as a transaction and is automatically committed right after it is completed. (A statement is completed when all of its result sets and update counts have been retrieved. In almost all cases, however, a statement is completed, and therefore committed, right after it is executed.)The way to allow two or more statements to be grouped into a transaction is to disable the auto-commit mode. Since it is enabled by default, you have to explicitly disable it after creating a connection by calling con.setAutoCommit(false);51. Which of these statements are true? Non-static inner class cannot have static members. They can have final fields but the static fields have to be final constants. Objects of static nested classes can be created without creating instances of their Outer classes. Member variables in any nested class cannot be declared final. Nested classes can have final members (i.e. methods and fields) Anonymous classes cannot define constructors explicitly in Java code. Anonymous classes cannot be static.ExplanationNon-static inner classes can contain final static fields (but not methods).Anonymous classes cannot have explicitly defined constructors, since they have no names.Remember: A nested class is any class whose declaration occurs within the body of another class or interface. A top level class is a class that is not a nested class. An inner class is a nested class that is not explicitly or implicitly declared static. A class defined inside an interface is implicitly static.Consider the following nested class B which is static:public class A  //This is a standard Top Level class. {   class X { final int j = 10; //compiles fine! }   public static class B //This is a static nested class { }}You can create objects of B without having objects of A. For example: A.B b = new A.B(); Members in outer instances are directly accessible using simple names. There is no restriction that member variables in inner classes must be final. Nested classes define distinct types from the enclosing class, and the instanceof operator does not take of the outer instance into consideration.52. Which of these statements concerning nested classes and interfaces are true? An instance of a static nested class has an inherent outer instance. Because static nested class is a static class. A static nested class can contain non-static member variables. It is like any other normal class. A static nested interface can contain static member variables. Static nested interface is similar to top level interface. A static nested interface has an inherent outer instance associated with it. A static nested interface is a static interface and so does not have an associated outer instance. For each instance of the outer class, there can exist many instances of a non-static inner class.ExplanationNote the difference between an Inner class and a static nested class. Inner class means a NON STATIC class defined inside a class. Remember: A nested class is any class whose declaration occurs within the body of another class or interface. A top level class is a class that is not a nested class. An inner class is a nested class that is not explicitly or implicitly declared static. A class defined inside an interface is implicitly static. For example,public class A // outer class{ static public class B //Static Nested class . It can be used in other places: A.B b = new A.B(); There is no outer instance. { } class C //Inner class. It can only be used like this: A.C c = new A().new C(); Outer instance is needed. { }}One can define a class as a static member of any top-level class. Now consider the following contents of a file named I1.java …public interface I1{ public void mA(); public interface InnerI1 { int k = 10; public void innerA(); }}Here, interface InnerI1 is implicitly STATIC and so is called as static nested interface. ‘k’ is a static (&amp; final) member of this interface. If you do 'javap' on I1 it prints: Compiled from I1.javapublic interface I1 /* ACC_SUPER bit NOT set */{ public abstract void mA(); public static interface I1. InnerI1 /* ACC_SUPER bit NOT set */ { public static final int k; public abstract void innerA(); }}This interface can be referred to in other places like:class MyClass implements I1.InnerI1{...}This is similar to referring a Top Level class.55. Which of the following command line switches is required for the assert statements to be executed while running a Java class? ea ua a No switch is needed, they are on by default. No, assertions are turned off by default. sourceExplanationAlthough not explicitly mentioned in the exam objectives, OCP Java 11 Part 2 Exam requires you to know about the switches used to enable and disable assertions. Here are a few important points that you should know:Assertions can be enabled or disabled for specific classes and/or packages. To specify a class, use the class name. To specify a package, use the package name followed by “…“(three dots also known as ellipses):java -ea:&lt;class&gt; myPackage.myProgramjava -da:&lt;package&gt;... myPackage.myProgramYou can have multiple -ea/-da flags on the command line. For example, multiple flags allow you to enable assertions in general, but disable them in a particular package.java -ea -da:com.xyz... myPackage.myProgramThe above command enables assertions for all classes in all packages, but then the subsequent -da switch disables them for the com.xyz package and its subpackages.To enable assertion for one package and disable for other you can use:java -ea:&lt;package1&gt;... -da:&lt;package2&gt;... myPackage.myProgramYou can enable or disable assertions in the unnamed root package (i.e. the default package) using the following commands:java -ea:... myPackage.myProgramjava -da:... myPackage.myProgramNote that when you use a package name in the ea or da flag, the flag applies to that package as well as its subpackages. For example,java -ea:com... -da:com.enthuware... com.enthuware.MainThe above command first enables assertions for all the classes in com as well as for the classes in the subpackages of com. It then disables assertions for classes in package com.enthuware and its subpackages.Another thing is that -ea/-da do not apply to system classes. For system classes (i.e. the classes that com bundled with the JDK/JRE), you need to use -enablesystemassertions/-esa or -disablesystemassertions/-dsaNote that * and ** are not valid wildcards for including subpackages.56. Which variables declared in the encapsulating class or in the method, can an inner class access if the inner class is defined in a static method of encapsulating class? All static variables All final instance variables All instance variables All automatic variables All final or effectively final static or automatic variables An effectively final variable means even though it is not declared final, it is never assigned a value again throughout the code after being assigned a value at the time of declaration. ExplanationConsider the following code:public class TestClass{ static int si = 10; int ii = 20; public static void inner() { int ai = 30; // automatic variable ai = 31; // ai is not effectively final anymore. final int fai = 40; // automatic final variable class Inner { public Inner() { System.out.println(si+\" \"+fai); } } new Inner(); } public static void main(String[] args) { TestClass.inner(); }}Since method inner() is a static method, only si and fai are accessible in class Inner. Note that ai and ii are not accessible. If method inner() were a non-static, ii would have been accessible. If the line ai = 31; did not exist, ai would have been accessible.58. How will you initialize a SimpleDateFormat object to that the following code will print the full name of the month of the given date? SimpleDateFormat sdf = new SimpleDateFormat(\"MMMM\", Locale.FRANCE); Upper case M is for Month. For example, for February and December, the following will be printed:M =&gt; 2, 12MM =&gt; 02, 12MMM =&gt; févr., déc.MMMM =&gt; février, décembre SimpleDateFormat sdf = new SimpleDateFormat(\"M*\", Locale.FRANCE); M* will print the month number (i.e. 2 for Feb and 12 for Dec), followed by *. For example, 2* or 12* SimpleDateFormat sdf = new SimpleDateFormat(\"mmmm\", Locale.FRANCE); Lower case m is for minutes. So mmmm will print the current minute, where the first two digits will always be zero. For example, 0032 or 0002. SimpleDateFormat sdf = new SimpleDateFormat(\"mmm\", Locale.FRANCE); SimpleDateFormat sdf = new SimpleDateFormat(\"MM\", Locale.FRANCE);ExplanationFor the purpose of the exam, you need to know the basic codes for printing out a date. The important ones are m, M, d, D, e, y, s, S, h, H, and z.You should check the complete details of these patterns hereThe important point to understand is how the length of the pattern determines the output of text and numbers.Text: The text style is determined based on the number of pattern letters used. Less than 4 pattern letters will use the short form. Exactly 4 pattern letters will use the full form. Exactly 5 pattern letters will use the narrow form. Pattern letters ‘L’, ‘c’, and ‘q’ specify the stand-alone from of the text styles.Number: If the count of letters is one, then the value is output using the minimum number of digits and without padding. Otherwise, the count of digits is used as the width of the output field, with the value zero-padded as necessary. The following pattern letters have constrains on the count of letters. Only one letter of ‘c’ and ‘F’ can be specified. Up to two letters of ‘d’, ‘H’, ‘h’, ‘K’, ‘k’, ‘m’, and ‘s’ can be specified. Up to three letters of ‘D’ can be specified.Number/Text: If the count of pattern letters is 3 or greater, use the Text rules above. Otherwise use the Number rules above.59. Which of the following statements are true? Package member classes can be declared static. Classes declared as members of top-level classes can be declared static. Local classes can be declared static. Anonymous classes cannot be declared static. No type of class can be declared static.ExplanationThe modifier static pertains only to member classes, not to top level or local or anonymous classes. That is, only classes declared as member of top-level classes can be declared static. Package member classes, local classes (i.e. classes declared in methods) and anonymous classes cannot be declared static.60. Which of the following options can be a part of a correct inner class declaration or a combined declaration and instance initialization? (Assume that SimpleInterface and ComplexInterface are interfaces.) java private class C { } java new SimpleInterface() { // valid code } java new ComplexInterface(x) { // valid code } You cannot pass parameters when you implement an interface by anonymous class. java private final abstract class C { } A final class can never be abstract. java new ComplexClass() implements SimpleInterface { } ‘implements’ part comes only in class definition not in instantiation. 61. Which of the following statements are true? A nested class may be declared static. FYI, JLS defines the following terminology in Chapter 8:A top level class is a class that is not a nested class.A nested class is any class whose declaration occurs within the body of another class or interface.An inner class is a class that is not explicitly or implicitly declared static. Anonymous inner class may be declared public. Anonymous inner class may be declared private. Anonymous inner class may be declared protected. Anonymous inner class may extend an abstract class.Explanationabstract class SomeClass { public abstract void ml(); }public class TestClass{ public static class StaticInnetClass { } //option1 public SomeClass getSomeClass() { return new SomeClass() { public void ml() {} }; }}//Here, the anonymous class created inside the method extends the abstract class SomeClass.64. Complete the code so that a Portfolio object can be serialized and deserialized properly.import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class Bond { String ticker = \"bac\"; double coupon = 8.3;}class Portfolio implements Serializable { String accountName; transient Bond bond = new Bond(); private void writeObject(ObjectOutputStream os) throws Exception { os.defaultWriteObject(); os.writeObject(bond.ticker); os.writeDouble(bond.coupon); } private void readObject(ObjectInputStream os) throws Exception { os.defaultReadObject(); this.bond = new Bond(); bond.ticker = (String) os.readObject(); bond.coupon = os.readDouble(); }}Explanation1. Bond class does not implement Serializable. Therefore, for Portfolio to be serialized, ‘bond’ must be transient.2. writeObject method takes ObjectOutputStream as the only parameter, while readObject method takes ObjectInputStream.3. To serialize the object using the default behavior, you must call objectOutputStream.defaultWriteObject(); or objectOutputStream.writeFields();. This will ensure that instance field of Portfolio object are serialized.4. To deserialize the object using the default behavior, you must call objectInputStream.defaultReadObject(); or objectInputStream.readFields();. This will ensure that instance fields of Portfolio object are deserialized.5. The order of values to be read explicitly in readObject must be exactly the same as the order they were written in writeObject. Here, ticker was written before coupon and so ticker must be read before coupon.65. Which of the following collection implementations are thread-safe? ArrayList HashSet HashMap TreeSet None of the aboveExplanationOf all the collection classes of the java.util package, only Vector and Hashtable are Thread-safe. java.util.Collection class contains a synchronizedCollection method that creates thread-safe instances based on collections which are not.For example:Set s = Collections.synchronizedSet(new HashSet());From Java 1.5 onwards, you can also use a new Concurrent library available in java.util.concurrent package, which contains interfaces/classes such as ConcurrentMap/ConcurrentHashMap. Classes in this package offer better performance than objects returned from Collections.synchronizedXXX methods.66. Using a Callable would be more appropriate than using a Runnable in which of the following situations? When you want to execute a task directly in a separate thread. A Callable cannot be passed to Thread for Thread creation but a Runnable can be. i.e. new Thread(aRunnable); is valid. But new Thread(aCallable); is not. Therefore, if you want to execute a task directly in a Thread, a Callable is not suitable. You will need to use a Runnable. You can achieve the same by using an ExecutorService.submit(aCallable) , but in this case, you are not controlling the Thread directly. When your task might throw a checked exception and you want to execute it in a separate Thread. Callable.call() allows you to declare checked exceptions while Runnable.run() does not. So if your task throws a checked exception, it would be more appropriate to use a Callable. When your task does not return any result but you want to execute the task asynchronously. Both Callable and Runnable can be used to execute a task asynchronously. If the task does not return any result, neither is more appropriate than the other. However, if the task returns a result, which you want to collect asynchronously later, Callable is more appropriate. When you want to use ExecutorService to submit multiple instance of a task. Both can be used with an ExecutorService because has overloaded submit methods:&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)andFuture&lt;?&gt; submit(Runnable task) Observe that even though a Runnable’s run() method cannot return a value, the ExecutorService.submit(Runnable) returns a Future. The Future’s get method will return null upon successful completion. Explanationpublic interface Callable&lt;V&gt;A task that returns a result and may throw an exception. Implementers define a single method with no arguments called call -V call() throws ExceptionThe Callable interface is similar to Runnable, in that both are designed for classes whose instances are potentially executed by another thread. A Runnable, however, does not return a result and cannot throw a checked exception.67. Identify correct statements about the Java module system. If a request is made to load a type whose package is not defined in any known module system will attempt to load it from the class path. The unnamed module can only access types present in the unnamed module. The unnamed module reads every other module. In other words, a class in an unnamed module can access all exported types of all modules. Code from a named module can access classes that are on the classpath. A named module cannot access any random class from the classpath. If your named module requires access to a non-modular class, you must put the non-modular class/jar on module-path and load it as an automatic module. Further, you must also put an appropriate “requires” clause in your module-info. If a package is defined in both a named module and the unnamed module then the package in the unnamed module is ignored. An automatic module cannot access classes from the unnamed module. Remember that named modules cannot access classes from the unnamed module because it is not possible for named module to declare dependency on the unnamed module.But what if a named module needs to access a class from a non-modular jar? Well, you can put the non-modular jar on the module-path, thereby making it an automatic module. A named module can declare dependency on an automatic module using the requires clause.Now, what if that jar in turn requires access to some other class from another third party non-modular jar? Here, the original modular jar doesn’t directly access the non-modular jar, so it may not be wise to create an automatic module out of all such third party jars. This is where the -classpath options is helpful.In addition to reading every other named module, an automatic module is also made to read the unnamed module. Thus, while running a modular application, the classpath option can be used to enable automatic modules to access third party non-modular jars. ExplanationBottom Up Approach for modularizing an applicationWhile modularizing an app using the bottom-up approach, you basically need to convert lower level libraries into modular jars before you can convert the higher level libraries. For example, if a class in A.jar directly uses a class from B.jar, and a class in B.jar directly uses a class from C.jar, you need to first modularize C.jar and then B.jar before you can modularize A.jar.Thus, bottom up approach is possible only when the dependent libraries are modularized already.Top Down Approach for modularzing an applicationWhile modularizing an app in a top-down approach, you need to remember the following points - Any jar file can be converted into an automatic module by simply putting that jar on the module-path instead of the classpath. Java automatically derives the name of this module from the jar file. Any jar that is put on classpath(instead of module-path) is loaded as part of the “unnamed” module. An explicitly named module (which means, a module that has an explicitly defined name in its module-info.java file) can specify dependency on an automatic module just like it does for any other module i.e. by adding a requires &lt;module-name&gt;; clause in its module info but it cannot do so for the unnamed module because there is no way to write a requires clause without a name. In other words, named module can access classes present in an automatic module but not in the unnamed module. Automatic modules are given access to classes in the unnamed module (even though there is no explicitly defined module-info and requires clause in an automatic module). In other words, a class from an automatic module will be able to read a class in the unnamed module without doing anything special. An automatic module exports all its packages and is allowed to read all packages exported by other modules. Thus, an automatic module can access: all packages of all other automatic modules + all packages exported by all explicitly named modules + all packages of the unnamed module (i.e. classes loaded from the classpath).Thus, if your application jar A directly uses a class from another jar B, then you would have to convert B into a module (either named or automatic). If B uses another jar C, then you can leave C on the class path if B hasn’t yet been migrated into a named module. Otherwise, you would have to convert C into an automatic module as well.Note:There are two possible ways for an automatic module to get its name: When an Automatic-Module-Name entry is available in the manifest, its value is the name of the automatic module. Otherwise, a name is derived from the JAR filename (see the ModuleFinder JavaDoc for the derivation algorithm) - Basically, hyphens are converted into dots and the version number part is ignored. So, for example, if you put mysql-connector-java-8.0.11.jar on module path, its module name would be mysql.connector.java70. Which of the following switches is/are used for controlling the execution of assertions at run time? -ua -da It is a short form for ‘disable assertions’. -enableassertions -assert -keepassertionsExplanationAlthough not explicitly mentioned in the exam objectives, OCP Java 11 Part 2 Exam requires you to know about the switches used to enable and disable assertions. Here are a few important points that you should know:Assertions can be enabled or disabled for specific classes and/or packages. To specify a class, use the class name. To specify a package, use the package name followed by “…“(three dots also known as ellipses):java -ea:&lt;class&gt; myPackage.myProgramjava -da:&lt;package&gt;... myPackage.myProgramYou can have multiple -ea/-da flags on the command line. For example, multiple flags allow you to enable assertions in general, but disable them in a particular package.java -ea -da:com.xyz... myPackage.myProgramThe above command enables assertions for all classes in all packages, but then the subsequent -da switch disables them for the com.xyz package and its subpackages.To enable assertion for one package and disable for other you can use:java -ea:&lt;package1&gt;... -da:&lt;package2&gt;... myPackage.myProgramYou can enable or disable assertions in the unnamed root package (i.e. the default package) using the following commands:java -ea:... myPackage.myProgramjava -da:... myPackage.myProgramNote that when you use a package name in the ea or da flag, the flag applies to that package as well as its subpackages. For example,java -ea:com... -da:com.enthuware... com.enthuware.MainThe above command first enables assertions for all the classes in com as well as for the classes in the subpackages of com. It then disables assertions for classes in package com.enthuware and its subpackages.Another thing is that -ea/-da do not apply to system classes. For system classes (i.e. the classes that com bundled with the JDK/JRE), you need to use -enablesystemassertions/-esa or -disablesystemassertions/-dsaNote that * and ** are not valid wildcards for including subpackages.72. Complete the following code so that it will print dick, harry, and tom in that order.public class TestClass { public static void main(String[] args) { Set&lt;String&gt; holder = new TreeSet&lt;&gt;(); holder.add(\"tom\"); holder.add(\"dick\"); holder.add(\"harry\"); holder.add(\"tom\"); printIt(holder); } public static void printIt(Collection&lt;String&gt; list) { for(String s : list) System.out.println(s); }}ExplanationThe output is expected to contain unique items. This implies that you need to use a Set. The output is also expected to be sorted. Thus, TreeSet is the only option.The printIt() method expects a Collection of Strings. Therefore, the reference type of holder can be Collection&lt;String&gt; or any subclass of Collection&lt;String&gt; such as Set&lt;String&gt;. It cannot be List or ArrayList because the object on the right hand side is TreeSet.75. Which of the following standard functional interfaces is most suitable to process a large collection of int primitives and return processed data for each of them? Function&lt;Integer&gt; IntFunction Consumer&lt;Integer&gt; IntConsumer Predicate&lt;Integer&gt;ExplanationUsing the regular functional interfaces by parameterizing them to Integer is inefficient as compared to using specially designed interfaces for primitives because they avoid the cost of boxing and unboxing the primitives.Now, since the problem statement requires something to be returned after processing each int, you need to use a Function instead of a Consumer or a Predicate.Therefore, IntFunction is most appropriate in this case.77. Which statements concerning the relation between a non-static inner class and its outer class instances are true? Member variables of the outer instance are always accessible to inner instances, regardless of their accessibility modifiers. Member variables of the outer instance can always be referred to using only the variable name within the inner instance. This is possible only if that variable is not shadowed by another variable in inner class. More than one inner instance can be associated with the same outer instance. An inner class can extend its outer classes. A final outer class cannot have any inner classes. There is no such rule. 80. Simple rule to determine sorting order: spaces &lt; numbers &lt; uppercase &lt; lowercase82. Which of the following statements are correct? A List stores elements in a Sorted Order. List just keeps elements in the order in which they are added. For sorting, you’ll need some other interface such as a SortedSet. A Set keeps the elements sorted and a List keeps the elements in the order they were added. A Set keeps unique objects without any order or sorting.A List keeps the elements in the order they were added. A List may have non-unique elements. A SortedSet keeps the elements in the order they were added. A SortedSet keeps unique elements in their natural order. An OrderedSet keeps the elements sorted. There is no interface like OrderedSet An OrderedList keeps the elements ordered. There is no such interface. The List interface itself is meant for keeping the elements in the order they were added. A NavigableSet keeps the elements sorted. A NavigableSet is a Sorted extended with navigation methods reporting closest matches for given search targets. Methods lower, floor, ceiling, and higher return elements respectively less than, or equal, greater than or equal, and greater than a given element, returning null if there is no such element.Since NavigableSet is a SortedSet, it keeps the elements sorted. 84. You want to execute your tasks after a given delay. Which ExecutorService would you use? FixedDelayExecutorService TimedExecutorService DelayedExecutorService ScheduledExecutorServiceThe following are the details of the interface ScheduledExecutorService:All Superinterfaces:Executor, ExecutorServiceAll Known Implementing Classes:ScheduledThreadPoolExecutorAn ExecutorService that can schedule commands to run after a given delay, or to execute periodically.The schedule methods create tasks with various delays and return a task object that can be used to cancel or check execution. The scheduleAtFixedRate and scheduleWithFixedDelay methods create and execute tasks that run periodically until cancelled.Commands submitted using the Executor.execute(java.lang.Runnable) and ExecutorService.submit methods are scheduled with a requested delay of zero. Zero and negative delays (but not periods) are also allowed in schedule methods, and are treated as requests for immediate execution.All schedule methods accept relative delays and periods as arguments, not absolute times or dates. It is a simple matter to transform an absolute time represented as a Date to the required form. For example, to schedule at a certain future date, you can use: schedule(task, date.getTime() - System.currentTimeMillis(), TimeUnit.MILLISECONDS). Beware however that expiration of a relative delay need not coincide with the current Date at which the task is enabled due to network time synchronization protocols, clock drift, or other factors. The Executors class provides convenient factory methods for the ScheduledExecutorService implementations provided in this package.ExplanationFollowing is a usage example that sets up a ScheduledExecutorService to beep every ten seconds for an hour:import java.util.concurrent.*;import static java.util.concurrent.TimeUnit.SECONDS;public class BeeperControl { private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); public void beepForAnHour() { final ScheduledFuture&lt;?&gt; beeperHandle = scheduler.scheduleAtFixedRate(() -&gt; System.out.println(\"beep\"), 0, 3, SECONDS); } public static void main(String[] args) { new BeeperControl().beepForAnHour(); }}" }, { "title": "Exercises for Inner class", "url": "/2020/02/15/inner-class-exercises/", "categories": "", "tags": "Java", "date": "2020-02-15 16:55:00 +0800", "snippet": " What is an inner class? Differentiate between member, local, and anonymous inner classes. An inner class declares inside a top-level class without a static modifier. Inner classes that declared at member level are called member inner classes, local to the method, or instance initialization block are local inner class. And local inner classes that have no name are anonymous inner classes. An inner class is a class declared inside the body of another class. A member inner class is declared inside a class. It can be declared as public, private, protected, or package-level. A local inner class is declared inside a block. Its scope is limited to the block in which it is declared. An anonymous inner class is the same as local inner class, but has no name. It is declared and an object of the class is created at the same time. What is the fully qualified name of the inner class B, which is declared as follows? // A.javapackage io.zwt.innerclasses.exercises; public class A { public class B { }} That will be : io.zwt.innerclasses.exercises.A.B Consider the following declaration for top-level class named Cup and a member inner class named Handle: // Cup.javapackage io.zwt.innerclasses.exercises; public class Cup { public class Handle { public Handle() { System.out.println(\"Created a handle for the cup\"); } } public Cup() { System.out.println(\"Created a cup\"); }} Compile the in the main() method for the following CupTest class that will create an instance of the Cup.Handle inner class: // CupTest.javapackage io.zwt.innerclasses.exercises;public class CupTest { public static void main(String[] args) { // Create a Cup Cup c = new Cup(); // Create a Handle // Cup.Handle h = / * You code goes here */; Cup.Handle h = c.new Handle(); }} What will be the output when the following Outer class is run? // Outer.javapackage io.zwt.innerclasses.exercises; public class Outer { private final int value = 19680112; public class Inner { private final int value = 19690919; public void print() { System.out.println(\"Inner: value = \" + value); System.out.println(\"Inner: this.value = \" + this.value); System.out.println(\"Inner: Inner.this.value = \" + Inner.this.value); System.out.println(\"Inner: Outer.this.value = \" + Outer.this.value); } } public void print() { System.out.println(\"Outer: value = \" + value); System.out.println(\"Outer: this.value = \" + this.value); System.out.println(\"Outer: Outer.this.value = \" + Outer.this.value); } public static void main(String[] args) { Outer out = new Outer(); Inner in = out.new Inner(); out.print(); in.print(); }} 19680112 19680112 19680112 19690919 19690919 19690919 19680112 The following declaration of an AnonymousTest class does not compile. Describe the reasons and steps you might take to fix the error. // AnonymousTestpackage io.zwt.innerclasses.exercises; public class AnonymousTest { public static void main(String[] args) { int x = 100; Object obj = new Object() { { System.out.println(\"Inside.x = \" + x); } }; x = 300; System.out.println(\"Outside.x = \" + x); }} x is not effectively final, make that effectively final by removing assignment x = 300; Consider the following declaration for a top-level class A and a member inner class B: package io.zwt.innerclasses.exercises; public class A { public class B { public B() { System.out.println(\"B is created.\"); } } public A() { System.out.println(\"A is created.\"); }} Consider the following incomplete declaration of class C, which inherits from the inner class A.B: // C.javapackage io.zwt.innerclasses.exercises; public class C extends A.B { /* Define a constructor for class C here */ public C(A a) { a.super(); System.out.println(\"C is created.\") } public static void main(String[] args) { C c = new C(new A())/* Your code goes here */; }} Add an appropriate constructor for class C and complete the statement in the main() method. When class C is run, it should print the following to the standard output: A is created.B is created.C is created. Which of the following is true about an anonymous inner class? a. It can inherit from one class and implement one interface. b. It can inherit from one class and implement multiple interfaces. c. It can inherit from one class or implement one interface. ✔ d. It can implement multiple interfaces, but inherits from only one class. How many class files will be generated when the following declaration of the Computer class is compiled? List the names of all generated class files. // Computer.javapackage io.zwt.innerclasses.exercises; public class Computer { public class Mouse { public class Button { } } public static void main(String[] args) { Object obj = new Object() { }; System.out.println(obj.hasCode()); }} 4 Computer.class Computer$Mouse.class Computer$Mouse.Button.class Computer$1.class The following declaration of class H does not compile. Point out the problem and suggest a solution. // H.javapackage io.zwt.innerclasses.exercises; public class H { private int x = 100; public static class J { private int y = x * 2; }} Declare x as static, or declare J as non-static. Consider the following declaration of a top-level class P and a nested static class Q: // P.javapackage io.zwt.innerclasses.exercises; public class P { public static class Q { { System.out.println(\"Hello from Q.\"); } }} Complete the main() method of the following PTest class that will create an object of the nested static class Q. When class PTest is run, it should print a message “Hello from Q.” to the standard output. // PTest.javapackage io.zwt.innerclasses.exercises; public class PTest { public static void main(String[] args) { P.Q q = /* Your code goes here */ new P.Q(); }} P served as namespace. " }, { "title": "Java 内部类", "url": "/2020/02/04/inner-class/", "categories": "", "tags": "Java, 语言特性", "date": "2020-02-04 22:34:00 +0800", "snippet": " 在这一篇文章，你将会学习到： 内部类是什么 如何声明内部类 如何声明成员、局部，以及匿名内部类 如何创建内部类的对象 什么是内部类？我们知道类（class）是包（package）的成员（member）。即顶层类，直接放在包下面的类。例如以下这段代码：// TopLevel.javapackage io.zwt.innerclasses;public class TopLevel { private int value = 101; public int getValue() { return value; } public void setValue(int value) { this.value = value; }}上面的 TopLevel 类是 io.zwt.innerclasses 包的成员。 这个里有三个成员： 一个实例变量（instance variable）：value 两个方法（method）：getValue() and setValue()一个类也可以声明在另一个类里面。这种类称为内部类。如果定义在另一个类中的类显式或隐式被声明为static，则它被称为嵌套类，而不是内部类。包含内部类的类称为外层类或外部类。看一下下面的 Outer 和 Inner 类声明：// Outer.javapakcage io.zwt.innerclasses;public class Outer {\tpublic class Inner {\t\t// 内部类的成员在这里\t}\t// 外部类的其它成员在这里}一个内部类实例只能存在于其外部类实例内。也就是说，你在创建内部类实例之前必须要有一个外部类的实例。这个规则在规范一个对象不能脱离另一个对象而存在这方面很有用。内部类可以完全访问到它的外部类的所有成员，包括私有成员。使用内部类的好处 可以将一个类定义在它的使用者附近。例如，一个计算机有处理器，所以最好将 Processor 类定义为 Computer 类的内部类。 它们提供了额外管理类结构的命名空间。例如，在未有内部类之前，一个类只能是包的成员。有了内部类，包含内部类的顶层类，提供了额外的命名空间。 某些设计模式用内部类实现更简单。例如，适配器模式，枚举模式，还有状态模式，都可以用内部类轻松实现。 用内部类实现回调机制优雅且方便。Java 8 的 Lambda 表达式是一种更好且更简洁的回调实现方式。 有助于在 Java 实现闭包。 使用内部类你可以体验一种类的多继承。一个内部类可以继承其它类。因此，内部类可以访问它的外部类成员，以及它的超类成员。注意，访问两个以上类的成员是多继承的目标之一，这可以通过使用内部类实现。然而，只是可以访问两个类的成员，并不是真正意义上的多继承。内部类的种类你可以在类的任意可以写 Java 语句的位置定义一个内部类，有三种内部类。它们的类型取决于声明所在的位置和声明的方式。 成员内部类 局部内部类 匿名内部类成员内部类成员内部类和成员字段或成员方法一样声明在一个类里面。可以声明为 public, private, protected 或者是包级别访问权限。其实例仅在外部类存在的条件下才存在。局部内部类局部内部类声明在块内。它的作用范围受限于它声明所在的块。由于它作用范围始终受限于块，它的声明不可以使用任何访问修饰符，例如 public, private 或 protected。 通常局部内部类定义在一个方法内。然而，它也可以被定义在静态初始化块，实例初始化块，以及构造器内。当只在块内使用一个类，你可以使用局部内部类。要在块外使用局部内部类，它必须符合以下至少一项： Implement a public interface 实现一个公有接口 继承自另一个公有类，并重写它的超类方法。匿名内部类匿名内部类跟局部内部类同样，除了一个区别：它没有名字。因为它没有名字，所以没有构造器。静态成员类不是内部类在另一个类中定义的成员类可以声明为 static。 以下代码声明了一个顶层类 A 和一个静态成员类 B：package io.zwt.innnerclasses;public class A {\t// A static member class\tpublic static class B {\t\t// The body of class B goes here\t}}一个静态成员类不是内部类。它被看作是顶层类。它亦被称为嵌套顶层类。因为它是一个顶层类，你不需要它的外层类的实例去创建它的对象。一个类 A 的实例和类 B 的实例可以独立地存在，因为它们都是顶层类。一个静态成员类可以声明为 public, protected，包访问级别，或者是 private 以限制它在外层类之外的访问权限。创建内部类对象创建局部内部类，匿名内部类，和静态成员类是非常直接的。局部内部类的对象在声明所在的内使用 new 创建对象。匿名内部类的对象在声明时候创建对象。静态成员类是另一类顶层类，其对象创建方式跟顶层类一样。访问外层类的成员局部变量访问的限制A local inner class is declared inside a block—typically inside a method of a class. A local inner class can access the instance variables of its enclosing class as well as the local variables, which are in scope. The instance of an inner class exists within an instance of its enclosing class. Therefore, accessing the instance variables of the enclosing class inside a local inner class is not a problem because they exist throughout the lifecycle of the instance of the local inner class. However, the local variables in a method exist only during the execution of that method. All local variables become inaccessible when method execution is over. Java makes a copy of the local variables that are used inside a local inner class and stores that copy along with the inner class object. However, to guarantee that the values of the local variables can be reproduced when accessed inside the local inner class code after the method call is over, Java puts a restriction that the local variables must be effectively final. An effectively final variable is a variable whose value does not change after it is initialized. One way to have an effectively final variable is to declare the variable final. Another way is not to change its value after it is initialized. Therefore, a local variable or an argument to a method must be effectively final if it is used inside a local inner class. This restriction also applies to an anonymous inner class declared inside a method. 提示 在 Java 8 以前，如果一个局部变量是被局部内部类，或者匿名内部类访问的，它必须被声明为 final。 Java 8 更改了这个规则：局部变量不需要被声明为 final， 但它应该是 effectively final 的。 什么意思呢？就是说，在变量声明前面添加个 final 修饰符，仍然能够通过编译，相当于 final，就是所谓的 “effective final” ，就等效于 final 嘛。内部类与继承An inner class can inherit from another inner class, a top-level class, or its enclosing class. For example, in the following snippet of code, inner class C inherits from inner class B; inner class D inherits from its enclosing top-level class A, and inner class F inherits from inner class A.B:public class A { public class B { } public class C extends B { } public class D extends A { }}public class E extends A { public class F extends B { }}public class G extends A.B { // This code won't compile // 这段代码不能通过编译！}内部类中不能有静态成员（除非是编译时常量）Java 里面的 static 关键字使得一个结构变成顶层结构。因此，你不能在一个内部类里边定义任何静态成员（字段、方法或者是初始化语句块）。以下代码不能通过编译，因为内部类 B 声明了一个静态字段 DAYS_IN_A_WEEK:public class A { public class B { // Cannot have the following declaration public static int DAYS_IN_A_WEEK = 7; // A compile-time error }}然而，内部类里面可以有性质为编译时常量的静态字段。什么意思？请看以下代码：public class A { public class B { // Can have a compile-time static constant field public final static int DAYS_IN_A_WEEK = 7; // OK // Cannot have the following declaration, because it is not // a compile-time constant, even though it is final public final static String str = new String(\"Hello\");\t\t// 可以用 public final static String str = \"Hello\"; 是常量 }} 注意 成员接口和成员枚举是隐式 static 的，因此不能声明在内部类里。内部类和编译器的魔法成员内部类和嵌套内部类：&lt;outer-class-name&gt;$&lt;member-or-nested-class-name&gt;局部内部类：&lt;outer-class-name&gt;$&lt;a-number&gt;&lt;local-inner-class-name&gt;匿名内部类：&lt;outer-class-name&gt;$&lt;a-number&gt;闭包与回调In functional programming, a higher order function is an anonymous function that can be treated as a data object. That is, it can be stored in a variable and passed around from one context to another. It might be invoked in a context that did not necessarily define it. Note that a higher order function is an anonymous function, so the invoking context does not have to know its name. A closure is a higher order function packaged with its defining environment. A closure carries with it the variables in scope when it was defined, and it can access those variables even when it is invoked in a context other than the context in which it was defined.在静态上下文定义内部类很少有用到，发现 static {} 里面可以放 {} 这样" }, { "title": "深入生成器设计模式", "url": "/2020/02/02/builder-pattern-in-depth/", "categories": "", "tags": "Design Pattern, 设计模式", "date": "2020-02-02 18:42:00 +0800", "snippet": "GoF 定义 Separate the construction of a complex object from its representation so that the same construction processes can create different representations. 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同表示。（中文版书里的翻译）Builder 在《设计模式》的中文版里边翻译为“生成器”，那我就按这个译法吧。生成器模式属于创建型模式（Creational patterns），它关注如何创建对象。当需要构建的对象比较复杂，由多个部分组成，也就说它的构造方法会有很多参数，就可以考虑使用这种模式。生成器模式认为对象的构建机制应该独立于它的组成部分（也就是属性），对象的构建过程不关注对象的组成部分。所以同一个构建过程可以构建出不同表示（属性）的对象（通过改变构建步骤）。在 GoF 书中的生成器模式 UML 类图如下：上图中，Product 是所要创建的复杂对象，ConcreteBuilder 类表示具体的生成器，它实现了 Builder 接口，负责组装构成最终对象的各部分。ConcreteBuilder 定义了构建过程和对象组装机制，就是如何用各部分、按照怎样的步骤去构造一个 Product 对象。ConcreteBuilder 还定义了 getResult() 方法，用于返回构建好的 Product 对象。然后 Director 则是负责通过使用 Builder 接口去构建最终所需的 Product 对象，就是做指挥的。以上是对经典的 GoF 生成器模式的解读，下面结合具体的例子加深理解。具体简单例子在这个例子里会有这些参与者：Builder, Car, MotorCycle, Product, 以及 Director。其中，Car, MotorCycle 是实现了 Builder 接口的具体类。Builder 用于构建 Product 对象的各部分，Product 则是要被创建的复杂对象（小车或摩托车）。因为 Car 和 MotorCycle 都实现了 Builder 接口，所以需要实现接口中的方法，即 startUpOperations(), buildBody(), insertWheels(), addHeadLights(), endOperations(), 和 getVehicle() 方法。前五个方法好理解，对应载具的构建过程，开始，构建车身，装轮子，装头灯，收尾。而 getVehicle() 方法，就是返回已构建好的载具。 然后还有 Director，它调用同一个 construct() 方法去构建不同类型的载具。这个具体例子的类图如下：代码实现import java.util.LinkedList;// 公共接口interface Builder {\tvoid startUpOperations();\tvoid buildBody();\tvoid insertWheels();\tvoid addHeadlights();\tvoid endOperations();\t/* 用于获取已经构建好的对象的方法。*/\tProduct getVehicle();}// Car 类class Car implements Builder {\tprivate String brandName;\tprivate Product product;\tpublic Car(String brand) {\t\tproduct = new Product();\t\tthis.brandName = brand;\t}\tpublic void startUpOperations() {\t\t// 开始就设置品牌名称\t\tproduct.add(String.format(\"Car model is :%s\", this.brandName));\t}\tpublic void buildBody() {\t\tproduct.add(\"This is a body of a Car\");\t}\tpublic void insertWheels() {\t\tproduct.add(\"4 wheels are added\");\t}\tpublic void addHeadlights() {\t\tproduct.add(\"2 Headlights are added\");\t}\tpublic void endOperations() { // Nothing in this case\t}\tpublic Product getVehicle() {\t\treturn product;\t}}// Motorcycle 类class MotorCycle implements Builder {\tprivate String brandName;\tprivate Product product;\tpublic MotorCycle(String brand) {\t\tproduct = new Product();\t\tthis.brandName = brand;\t}\tpublic void startUpOperations() { // Nothing in this case\t}\tpublic void buildBody() {\t\tproduct.add(\"This is a body of a Motorcycle\");\t}\tpublic void insertWheels() {\t\tproduct.add(\"2 wheels are added\");\t}\tpublic void addHeadlights() {\t\tproduct.add(\"1 Headlights are added\");\t}\tpublic void endOperations() {\t\t// 添加品牌名称作为收尾\t\tproduct.add(String.format(\"Motorcycle model is :%s\", this.brandName));\t}\tpublic Product getVehicle() {\t\treturn product;\t}}// Product 类 class Product {\t/*\t * 你可以使用任何数据结构，这里使用\t * LinkedList&lt;String&gt; \t */\tprivate LinkedList&lt;String&gt; parts;\tpublic Product() {\t\tparts = new LinkedList&lt;String&gt;();\t}\tpublic void add(String part) {\t\t// 添加部件\t\tparts.addLast(part);\t}\tpublic void showProduct() {\t\tSystem.out.println(\"\\nProduct completed as below :\");\t\tfor (String part : parts)\t\t\tSystem.out.println(part);\t}}// Director 类 class Director {\tBuilder builder;\t// Director 知道如何使用 builder 以及调用步骤。\tpublic void construct(Builder builder) {\t\tthis.builder = builder;\t\tbuilder.startUpOperations();\t\tbuilder.buildBody();\t\tbuilder.insertWheels();\t\tbuilder.addHeadlights();\t\tbuilder.endOperations();\t}}public class BuilderPatternExample {\tpublic static void main(String[] args) {\t\tSystem.out.println(\"***Builder Pattern Demo***\");\t\tDirector director = new Director();\t\tBuilder fordCar = new Car(\"Ford\");\t\tBuilder hondaMotorycle = new MotorCycle(\"Honda\");\t\t// 造小车 Car\t\tdirector.construct(fordCar);\t\tProduct p1 = fordCar.getVehicle();\t\tp1.showProduct();\t\t// 造摩托 MotorCycle\t\tdirector.construct(hondaMotorycle);\t\tProduct p2 = hondaMotorycle.getVehicle();\t\tp2.showProduct();\t}}输出结果：***Builder Pattern Demo***Product completed as below :Car model is :FordThis is a body of a Car4 wheels are added2 Headlights are addedProduct completed as below :This is a body of a Motorcycle2 wheels are added1 Headlights are addedMotorcycle model is :HondaQ &amp; A 使用生成器模式有什么好处? 你可以用生成器模式逐步构建复杂对象，并且可以改变构建步骤。通过隐藏构建复杂对象的细节（构建每部分的细节），加强了封装性。 Director 可以从 Builder 获取最终构建完成的 Product，在表面看了就好像只有一个方法（construct()）用于构建最终产品，其他的内部方法只是涉及构建具体的部分。 使用这种模式，同样的构建过程，可以产生不同的产品。 因为你可以改变构造步骤，所以你可以改变产品的内部表示。 生成器模式的坏处？ 不适用于处理可变对象（mutable object），即创建后可被修改的对象。 可能需要写些重复代码，例如不同的具体生成器有些代码类似或重复，某些情况下可能会有不好的影响，并可能成为反模式。 一个具体的生成器专用于产生某类产品，所以要生产另一类产品，就需要编写一个用于该类产品的具体生成器。 生成器模式只有在构建比较复杂的对象时用才有优势。 在上面例子中我可以使用抽象类而不是接口吗？ 可以的。你可以使用抽象类，而不是用接口。 如何确定应该使用抽象类还是接口？ 如果你想要一些集中的或是默认的行为，那么抽象类是更好的选择，因为这种情况下你可以提供一些默认的实现。另一方面，使用接口则需要从零开始实现，接口定义了某些规则/契约，强调应该做什么，但不强调怎么做。还有就是如果要考虑实现多继承，接口就更合适。 如果你要给接口添加一个新的方法，那么这个接口的所有实现都需要实现这个新方法，有点麻烦。但如果在抽象类中添加一个新方法，并有默认实现，那么旧代码不受影响。在 Java 8 引入了 default 关键字在接口的用法，可以在接口里提供默认方法。 下面是抽象类更适用的场景： 想要在多个联系紧密的类之间共享代码 被继承的抽象类有很多公共方法或字段，或者它们当中需要非公有访问修饰符。 你想使用非静态或非 final 字段，这样可以修改其所属对象的状态。 接下来是使用接口更合适的场景： 希望一些不相关的类实现你的接口。 指定某种数据类型的行为，但是不关心如何实现。 想要适用多继承。 上面例子中，在 Car 里，brand name 在第一步添加了，而在 MotorCycle 里， brand name 在最后一步添加，这是故意的吗？ 是的。这是为了说明，每种具体生成器可以自由决定如何产生最终产品。 为什么使用单独一个类作为 Director？应该可以使用客户端代码（client code）充当 Director 的角色啊。 这方面没有限制。上面的代码例子，将 Director 角色与客户端代码分离，但是接下来的例子会直接适用客户端代码做 Director。 客户端代码（client code）是什么意思？ 包含 main() 方法的类就是客户端代码（client code）。在 Effective Java 一书的第 4 页，有三段话讲了术语 exported API 以及 a client of the API. 引用如下： This book uses a few technical terms that are not defined in The Java Language Specification. The term exported API, or simply API, refers to the classes, interfaces, constructors, members, and serialized forms by which a programmer accesses a class, interface, or package. (The term API, which is short for application programming interface, is used in preference to the otherwise preferable term interface to avoid confusion with the language construct of that name.) A programmer who writes a program that uses an API is referred to as a user of the API. A class whose implementation uses an API is a client of the API. Classes, interfaces, constructors, members, and serialized forms are collectively known as API elements. An exported API consists of the API elements that are accessible outside of the package that defines the API. These are the API elements that any client can use and the author of the API commits to support. Not coincidentally, they are also the elements for which the Javadoc utility generates documentation in its default mode of operation. Loosely speaking, the exported API of a package consists of the public and protected members and constructors of every public class or interface in the package. In Java 9, a module system was added to the platform. If a library makes use of the module system, its exported API is the union of the exported APIs of all the packages exported by the library’s module declaration. 前面提到改变构建步骤。能否演示一下通过改变构建步骤产生不同的最终产品？ 下面的例子给出演示。 改进版例子改进版例子做了如下修改： 这次只关注 Car 作为最终产品。 定制 Car 的构建步骤包含这些： 开始的消息（startUpMessage)。 处理结束消息（endOperationsMessage） 确定车身材料（bodyType） 车轮数量（noOfWheels） 车头灯数量（noOfHeadLights） 客户端代码同时充当了 Director 的角色。 生成器的接口被重命名为 ModifiedBuilder， 除 constructCar() 和 getConstructedCar() 方法外，接口中的其他方法的返回类型都是 ModifiedBuilder，这样可以实现方法链（method chaining）。代码实现// 公共接口interface ModifiedBuilder {\t/*\t * 所有这些方法的返回值类型都是 ModifiedBuilder。这样可以做链式调用\t */\tModifiedBuilder startUpOperations(String startUpMessage);\tModifiedBuilder buildBody(String bodyType);\tModifiedBuilder insertWheels(int noOfWheels);\tModifiedBuilder addHeadlights(int noOfHeadLights);\tModifiedBuilder endOperations(String endOperationsMessage);\t/* 组合部件制造最终产品。 */\tProductClass constructCar();\t// 可选的方法：获取已构建的产品\tProductClass getConstructedCar();}//Car 类class CarBuilder implements ModifiedBuilder { // 默认起始消息\tprivate String startUpMessage = \"Start building the product\"; private String bodyType = \"Steel\"; // 默认车身类型\tprivate int noOfWheels = 4; // 默认车轮数量\tprivate int noOfHeadLights = 2; // 默认车头灯数量\t// 默认结束消息\tprivate String endOperationsMessage = \"Product creation completed\";\tProductClass product;\t@Override\tpublic ModifiedBuilder startUpOperations(String startUpMessage) {\t\tthis.startUpMessage = startUpMessage;\t\treturn this;\t}\t@Override\tpublic ModifiedBuilder buildBody(String bodyType) {\t\tthis.bodyType = bodyType;\t\treturn this;\t}\t@Override\tpublic ModifiedBuilder insertWheels(int noOfWheels) {\t\tthis.noOfWheels = noOfWheels;\t\treturn this;\t}\t@Override\tpublic ModifiedBuilder addHeadlights(int noOfHeadLights) {\t\tthis.noOfHeadLights = noOfHeadLights;\t\treturn this;\t}\t@Override\tpublic ModifiedBuilder endOperations(String endOperationsMessage) {\t\tthis.endOperationsMessage = endOperationsMessage;\t\treturn this;\t}\t@Override\tpublic ProductClass constructCar() {\t\tproduct = new ProductClass(this.startUpMessage, this.bodyType, this.noOfWheels, this.noOfHeadLights,\t\t\t\tthis.endOperationsMessage);\t\treturn product;\t} @Override\tpublic ProductClass getConstructedCar() {\t\treturn product;\t}}// Product 类 final class ProductClass {\tprivate String startUpMessage;\tprivate String bodyType;\tprivate int noOfWheels;\tprivate int noOfHeadLights;\tprivate String endOperationsMessage;\tpublic ProductClass(final String startUpMessage, String bodyType, int noOfWheels, int noOfHeadLights,\t\t\tString endOperationsMessage) {\t\tthis.startUpMessage = startUpMessage;\t\tthis.bodyType = bodyType;\t\tthis.noOfWheels = noOfWheels;\t\tthis.noOfHeadLights = noOfHeadLights;\t\tthis.endOperationsMessage = endOperationsMessage;\t}\t/*\t * 没有使用 setter 方法，加强不可以变性。因为属性是私有，且没有 setter 方法，\t * 所以不必要使用 final 关键字。\t */\t@Override\tpublic String toString() {\t\treturn \"Product Completed as:\\n startUpMessage=\" + startUpMessage + \"\\n bodyType=\" + bodyType + \"\\n noOfWheels=\" + noOfWheels + \"\\n noOfHeadLights=\" + noOfHeadLights + \"\\n endOperationsMessage=\" + endOperationsMessage;\t}}// Director 类 public class BuilderPatternModifiedExample {\tpublic static void main(String[] args) {\t\tSystem.out.println(\"***Modified Builder Pattern Demo***\");\t\t/*\t\t * 构造一个定制的小车（通过使用 builder），注意步骤：\t\t * 第1步：已必要的参数获取一个 builder 对象。\t\t * 第2步：使用类似 setter 的方法设置可选字段。\t\t * 第3步：调用 constructCar() 方法去获取最终生成的小车。\t\t */\t\tfinal ProductClass customCar1 = new CarBuilder() .addHeadlights(5) .insertWheels(5) .buildBody(\"Plastic\")\t\t\t.constructCar();\t\tSystem.out.println(customCar1);\t\tSystem.out.println(\"--------------\");\t\t/*\t\t * 用不同的步骤构造另一个定制小车（通过使用 builder）\t\t */\t\tModifiedBuilder carBuilder2 = new CarBuilder();\t\tfinal ProductClass customCar2 = carBuilder2 .insertWheels(7) .addHeadlights(6) .startUpOperations(\"I am making my own car\") .constructCar();\t\tSystem.out.println(customCar2);\t\tSystem.out.println(\"--------------\");\t\t/*\t\t * 错误，因为 customCar2 是 final 的 * customCar2 = carBuilder2.insertWheels(70)\t\t * .addHeadlights(6) .startUpOperations(\"I am making my own car\")\t\t * .constructCar(); System.out.println(customCar2);\t\t */\t\t\t\t// 验证 getConstructedCar() 方法 \t\tfinal ProductClass customCar3 = carBuilder2.getConstructedCar();\t\tSystem.out.println(customCar3);\t}}输出结果：***Modified Builder Pattern Demo***Product Completed as:startUpMessage=Start building the productbodyType=PlasticnoOfWheels=5noOfHeadLights=5endOperationsMessage=Product creation completed--------------Product Completed as:startUpMessage=I am making my own carbodyType=SteelnoOfWheels=7noOfHeadLights=6endOperationsMessage=Product creation completed--------------Product Completed as:startUpMessage=I am making my own carbodyType=SteelnoOfWheels=7noOfHeadLights=6endOperationsMessage=Product creation completed在改进版例子中，第 124 行，构建 customCar1，逐步调用了 addHeadLights(), insertWheels(), buildBody() 方法。 然后当构建 customCar2 时，方法的调用顺序不同了，而没调用的方法，会取默认值。Q &amp; A 改进版例子中客户端代码用到 final 关键字，但是 ProductClass 的属性却没有用 final 关键字，为什么？ 在客户端代码使用 final 关键字是为了提高不可修改性（immutability），但是在 ProductClass 属性已经是私有且那个类没有 setter 方法，所以已经是不可修改了，不需要使用 final 关键字。 不可修改的对象有什么好处？ 这样的对象一旦构建完成，就可以安全地共享，更重要的是它们是线程安全的（thread-safe），所以在多线程环境中省去了很多同步操作。 何时应该考虑使用生成器模式？ 当你需要创建一个复杂的对象，涉及到很多步骤，而且被创建的对象需要是不可修改的对象，可以考虑使用生成器模式。 补充静态嵌套类，链式调用这里补充 Effective Java 第三版里边 Item 2 所讲的 Consider a builder when faced with many constructor parameters 的代码例子，因为觉得这里面的例子稍微高级一点，应用到静态嵌套类（不知道这样翻译准不准确，英文是 Static nested class）。 在说完 Telescoping constructor pattern (does not scale well!) 和 JavaBeans Pattern (allows inconsistency, mandates mutability) 缺点之后，Joshua Bloch 给出了一种 Builder Pattern，代码如下：// Builder Patternpublic class NutritionFacts { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; // 钠 private final int carbohydrate; // 碳水化合物 // 用 Static nested class 作为 Builder // 放在这里面可以 convey 一种 ownership， // 说明这个 Builder 用于生成 NutritionFacts public static class Builder { // Required parameters 必须的参数 private final int servingSize; private final int servings; // Optional parameters - initialized to default values // 可选参数，初始化为默认值 private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public Builder(int servingSize, int servings) { this.servingSize = servingSize; this.servings = servings; } // 表示各个构造步骤，返回 Builder 自身引用，形成 fluent API 链式调用 public Builder calories(int val) \t{ calories = val; return this; } public Builder fat(int val) \t{ fat = val; return this; } public Builder sodium(int val) \t{ sodium = val; return this; } public Builder carbohydrate(int val) \t{ carbohydrate = val; return this; } // 返回最终产品 public NutritionFacts build() { return new NutritionFacts(this); } } // 私有构造函数 private NutritionFacts(Builder builder) { servingSize = builder.servingSize; servings = builder.servings; calories = builder.calories; fat = builder.fat; sodium = builder.sodium; carbohydrate = builder.carbohydrate; } }按上面的 Builder 实现，客户端代码可以这样写：NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8). calories(100).sodium(35).carbohydrate(27).build();这样的链式调用，易写、易读，模仿了像 Python 或 Scala 中的命名参数（named optional parameters).适用于类继承体系结构即抽象类有抽象 builder，具体类有具体的 builder，例如以下代码是一个抽象类，代表各种披萨：// Builder pattern for class hierarchiespublic abstract class Pizza { public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE } final Set&lt;Topping&gt; toppings; abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; { EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping) { toppings.add(Objects.requireNonNull(topping)); return self(); } abstract Pizza build(); // Subclasses must override this method to return \"this\" protected abstract T self(); } Pizza(Builder&lt;?&gt; builder) { toppings = builder.toppings.clone(); // See Item 50 }}上面的 Pizza.Builder 是带有递归类型参数的泛型，加上抽象的 self 方法，可以允许子类实现方法链式调用。因为 Java 没有 self 类型，这种做法是模仿 self 类型的习惯。(This workaround for the fact that Java lacks a self type is known as the simulated self-type idiom.)然后接下来是两个具体的 Pizza 子类：纽约披萨：public class NyPizza extends Pizza { public enum Size { SMALL, MEDIUM, LARGE } private final Size size; public static class Builder extends Pizza.Builder&lt;Builder&gt; { private final Size size; // covariant return typing public Builder(Size size) { this.size = Objects.requiresNonNull(size); } @Override public NyPizza build() { return new NyPizza(this); } @Override protected Builder self() { return this; } } private NyPizza(Builder builder) { super(builder); size = builder.size; }}意式披萨：public class Calzone extends Pizza { private final boolean sauceInside; public static class Builder extends Pizza.Builder&lt;Builder&gt; { private final boolean sanceInside = false; // Default // covariant return typing public Builder sauceInside() { sauceInside = true; return this; } @Override public Calzone build() { return new Calzone(this); } @Override protected Builder self() { return this; } } private Calzone(Builder builder) { super(builder); sauceInside = builder.sauceInside; }}然后客户端代码看起来是这样的：NyPizza pizza = new NyPizza.Builder(SAMLL) .addTopping(SAUSAGE).addTopping(ONION).buid();Calzone calzone = new Calzone.Builder() .addTopping(HAM).sauceInside().build();总结总的来说，当一个类的构造函数或者静态工厂有较多的参数时，生成器模式是一种好的选择，特别是有些参数是可选的，或者类型是相同的。【完结】参考 [Gamma95] Gamma, Erich, Richard Helm, Ralph Johnson, and John Vlissides. 1995. Design Patterns: Elements of Reusable Object-Oriented Software. Reading, MA: Addison-Wesley. ISBN: 0201633612 Sarcar, Vaskaran. Design Patterns in Java, Second Edition. Apress, 2019 Springframework guru: Builder Pattern Joshua Block. Effective Java, Third Edition. Addison-Wesley, 2018 设计模式杂谈——模式与反模式之争 更新记录： 2020年3月13日 下午3点13分 修正一些错别字，整理一下代码格式，和替换注释为中文。" }, { "title": "Spring Boot的类", "url": "/2020/02/01/spring-classes/", "categories": "", "tags": "Spring Boot, Notes", "date": "2020-02-01 15:54:00 +0800", "snippet": "常见类的用途SpringApplicationBuilderjava.lang.Object​\torg.springframework.boot.builder.SpringApplicationBuilderBuilder for SpringApplication and ApplicationContext instances with convenient fluent API and context hierarchy support. Simple example of a context hierarchy:new SpringApplicationBuider(ParentConfig.class).child(ChildConfig.class).run(args);Another common use case is setting active profiles and default properties to set up the environment for an application:new SpringApplicationBuilder(Application.class).profiles(\"server\") \t\t\t.properties(\"transport=local\").run(args);If your needs are simpler, consider using the static convenience methods in SpringApplication instead.(org.springframework.boot:spring-boot:2.2.4.RELEASE)这里就是Builder模式，顺便记录一下，先上图：GoF 对 Builder Pattern 的定义如下： Separate the construction of a complex object from its representation so that the same construction processes can create different representations. 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同表示。（中文版书里的翻译，另外注意，在书中 Builder 译作“生成器”）上图中，Product 是我们想要构建的复杂对象，ConcreteBuilder 通过实现抽象的 Builder 接口去构造和组合一个 product 的部件。具体的构造者，ConcreteBuilder 负责构建 product 的内部表现，和创造过程及组合机制。 Builder 也可以提供方法使得被创建的对象可以被使用。 Director 负责使用 Builder 取创建最终的 Product，也就是说 Director 是 Builder 的使用者。 构造者(Builders) 可以保持对所构造的对象(products)的引用，以便可以再次使用。SpringApplicationjava.lang.Object​\torg.springframework.boot.SpringApplicationClass that can be used to bootstrap and launch a Spring application from a Java main method. By default class will perform the following steps to bootstrap your application: Create an appropriate ApplicationContext instance (depending on your classpath) Register a CommandLinePropertySource to expose command line arguments as Spring properties Refresh the application context, loading all singleton beans Trigger any CommandLineRunner beansIn most circumstances the static run(Class, String[]) method can be called directly from you main method to bootstrap your application: @Configuration @EnableAutoConfiguration public class MyApplication { // ... Bean definitions public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } }For more advanced configuration a SpringApplication instance can be created and customized before being run:public static void main(String[] args) { SpringApplication application = new SpringApplication(MyApplication.class); // ... customize application settings here application.run(args) }SpringApplications can read beans from a variety of different sources. It is generally recommended that a single @Configuration class is used to bootstrap your application, however, you may also set sources from: The fully qualified class name to be loaded by AnnotatedBeanDefinitionReader The location of an XML resource to be loaded by XmlBeanDefinitionReader, or a groovy script to be loaded by GroovyBeanDefinitionReader The name of a package to be scanned by ClassPathBeanDefinitionScannerConfiguration properties are also bound to the SpringApplication. This makes it possible to set SpringApplication properties dynamically, like additional sources (“spring.main.sources” - a CSV list) the flag to indicate a web environment (“spring.main.web-application-type=none”) or the flag to switch off the banner (“spring.main.banner-mode=off”).org.springframework.boot.SpringApplicationpublic static org.springframework.context.ConfigurableApplicationContext run(Class &lt;?&gt; primarySource, String ... args)Static helper that can be used to run a SpringApplication from the specified source using default settings.Parameters:primarySource - the primary source to loadargs - the application arguments (usually passed from a Java main method)Returns:the running ApplicationContext" }, { "title": "Spring Boot 消息", "url": "/2020/02/01/spring-boot-messaging/", "categories": "", "tags": "Spring Boot, Messaging", "date": "2020-02-01 10:44:00 +0800", "snippet": "消息通信最简单的消息机制，从A点到B点，通过某种信道传递消息，可以使一个简单的函数调用，一个socket连接，或者是一个HTTP请求。主要目的是发送端发送消息给接收端消费。消息通信使用场景下面列出一些消息通信常见的使用场景：可靠送达通常需要一些消息确认机制，如果中间有个Broker，消息生产者要通过一些确认，了解Broker确实收到了消息。同理在消费者段也需要给Broker确认已经收到消息。通常支付、股票交易等系统会使用这种模式。解耦按照业务领域解耦，使用bounded context.扩展和高可用多个Broker扩展。异步异步消息确保响应性，responsiveness互操作性采用Broker架构，实现AMQP等协议。消息模式和设计模式点到点发布-订阅设计模式A design patterns is a solution to a commonly known problem in the software design. By the same token, messaging patterns attempt to solve problems with messaging designs.​\tYou will learn about the implementation of the following patterns during the course of this book, so I want to list them here with simple definitions to introduce them: Message type patterns: Describe different forms of messaging, such as string(maybe plain text, JSON and/or XML), byte array, object, etc. Message channel patterns: Determine what kind of a transport(channel) will be used to send a message and what kind of attributes it will have. The idea here is that the producer and consumer know how to connect to the transport(channel) and can send and receive the message. Possible attributes of this transport include a request-reply feature and a unidirectional channel, which you will learn about very soon. One example of this pattern is the point-to-point channel. Routing patterns: Describe a way to send message between producer and consumers by providing a routing mechanism(filtering that’s dependent on a set of conditions) in an integrated solution. That can be accomplished by programming, or in some cases, the messaging system(the broker) can have these capabilities(as with RabbitMQ). Service consumer patterns: Describe how the consumers will behave when messages arrive, such as adding a transactional approach when processing the message. There are frameworks that allow you to initiate this kind of behavior(like the Spring Framework, which you do by adding the @Transactional, a transaction-base abstraction). Contract patterns: Contracts between the producer and consumer to have simple communications, such as when you do some REST calls, where you call a JSON or XML message with fields. Message construction patterns: Describe how a message is created so it can travel within the messaging system. For example, you can create an “envelope” that can have a body(the actual message) and some headers(with a correlation ID or a sequence or maybe a reply address). With a simple web request, you can add parameters or headers and the actual message becomes the body of the request, making the whole request part of the construction pattern. The HTTP protocol allows for that kind of communication (messaging). Transformation patterns: Describe how to change the content of the message within the messaging system. Think about a message that requires some processing and needs to be enhanced on the fly, such as a content enricher.As you can see, these patterns not only describe the messaging process but some of them describe how to handle some of the common use cases you saw earlier. Of cause, there are a lot more messaging patterns." }, { "title": "Java线程间通信", "url": "/2020/01/30/java-thread-communication/", "categories": "", "tags": "Java, Thread", "date": "2020-01-30 09:35:00 +0800", "snippet": "生产者与消费者一种典型的线程间通信的例子是涉及到生产者线程与消费者线程之间的关系。生产者生产数据项被消费者消费，每个被生产出的数据项被存放在共享的变量中。想象线程以不同的速度运行，消费者可能来不及处理掉生产者之前生产出来并放到共享变量中的数据项。还有可能就是消费者消费速度太快了，未等到生产者产生数据就去取了。为了克服这类问题，生产者线程必须等到它被通知之前生产的数据项已经被消费掉了才继续生产，而消费者线程必须等到它被通知已经有新的数据项产生了才取消费。下面代码展示如何通过使用 wait() 和 notify() 完整这样的任务。package io.zwt;// PC stands for Producer and Consumerpublic class PC { public static void main(String[] args) { Shared s = new Shared(); // 共享变量 new Producer(s).start(); // 生产者线程 new Consumer(s).start(); // 消费者线程 }}// 表示共享数据的类class Shared { private char c; // 字符 private volatile boolean writable = true; // 是否可写入状态 // 一个同步方法，设置共享变量所保存的字符 c，这个方法对应生产者的操作 synchronized void setSharedChar(char c) { // 若不可写入，就在一个 while 循环中等待 while (!writable) try { wait(); } catch (InterruptedException ignored) { } this.c = c; // 写入数据 writable = false; // 改变状态 notify(); // 生产好了，通知消费者 } // 对应消费者的操作 synchronized char getSharedChar() { // 可写入状态则等待，说明在生产，所以要等待 while (writable) try { wait(); } catch (InterruptedException ignored) { } writable = true; notify(); // 消费完了，通知生产者 return c; // 读取到的字符 }}// 生产者线程class Producer extends Thread { private final Shared s; Producer(Shared s) { this.s = s; } @Override public void run() { for (char ch = 'A'; ch &lt;= 'Z'; ch++) { s.setSharedChar(ch); System.out.println(ch + \" produced by producer.\"); } }}// 消费者线程class Consumer extends Thread { private final Shared s; Consumer(Shared s) { this.s = s; } @Override public void run() { char ch; do { ch = s.getSharedChar(); System.out.println(ch + \" consumed by consumer.\"); } while (ch != 'Z'); }}" }, { "title": "水密舱壁模式", "url": "/2020/01/29/bulkhead-pattern/", "categories": "", "tags": "模式, 微服务", "date": "2020-01-29 08:46:00 +0800", "snippet": "水密舱壁模式是一类容错的应用程序设计。在水密舱壁模式架构中，应用程序的个组成元素被分隔到隔舱中，这样一旦其中一个出故障，其它部分仍能够运行。这是命名来自船体当中的分隔区域（水密舱壁）。如果一艘船的水密隔舱坏了，那么只是受损部位会进水（其它部分被隔开了），这样能够防止沉船。 场景与问题一个基于云的应用程序可能包括多个服务，每个服务可能有一个或者多个消费者。一个服务超负荷或者出故障会影响到这个服务的所有消费者。而且，一个消费者可能同时对多个服务发起请求，每个请求都占用着资源。当消费者向一个错误配置的服务或无反应的服务发起请求，那么客户端请求所占用的资源可能不能及时地释放。随着对服务的请求继续发起，此类资源可能会被耗尽。例如，客户端连接池可能会耗尽。在那情况下，消费者对于其它服务的请求会受到影响。最终导致消费者不仅没法再对原来无响应的服务发起请求，而且也不能对其它服务发起请求了。同样的资源耗尽问题也影响着有多个消费者的服务。来自一个客户端的大量请求可能会耗尽服务可用的资源。其它消费者就没有办法再消费服务，导致雪崩故障效应。解决方案将服务实例按照消费者的负载和可用性要求分为不同的组。 这种设计有助于隔离故障，并允许你在即使是故障情况下仍能为部分消费者维持服务功能。一个消费者同样也可以分区资源，服务调用间资源互不影响。（即调用某个服务的资源不会影响到用于调用另一个服务的资源。 ） 例如，一个需要调用多个服务的消费者可能会为每个服务指定一个连接池。如果一个服务开始出故障，那只会影响到指定给那个服务的连接池，而消费者仍然可以继续使用其它服务。这种模式的好处有以下几点： 将消费者和服务从雪崩故障中隔离开来。一个影响到一个消费者或服务的问题可以被隔离在它自己的水密舱壁里，防止解决方案整体失败。 能让你在发生故障的情况下保留部分功能。其它服务和应用程序功能能够继续运行。 可以让你部署能为消费者应用提供不同服务质量的服务。优先级高的消费者池可以配置使用高优先级的服务。下面的图展示围绕调用独立服务的连接池构造的水密舱壁。如果服务A（Service A）出故障或者其它毛病，它的连接池已经隔开了，所以只有使用了指派给服务A的线程池的工作负荷（workload）会受到影响。而使用服务B和C的工作负荷没受影响，能够继续不间断运行。下一个图展示了多个客户端调用一个服务。每个客户端分别被指派一个服务实例。 客户端 1（Client 1）发起太多请求了并且压垮了它的服务实例。因为每个服务实例都是分别隔离开的，其它的客户端可以继续发起请求。问题与思考 根据业务以及应用程序的技术性需求定义分区。 当将服务或消费者分区到水密舱壁，应考虑技术上能提供的隔离级别，也要考虑开销成本，性能以及可维护性。 考虑将水密舱壁模式与重试、断路器还有节流模式结合起来实现更加周密的故障处理机制。 当将消费者分区到水密舱壁，考虑使用进程，线程池以及信号量。像Netflix Hystrix还有Polly的项目提供了框架用于创建消费者水密舱壁。 当将服务分区到水密舱壁，考虑将它们部署到独立的虚拟机，容器或进程。容器在资源隔离和相对低开销方面提供了一个好的平衡点。 使用异步消息通信的服务可以通过不同的队列隔离开来。每个队列可以有一组专用的实例处理消息，或者一个单组实例，使用算法出队和分发处理。 确定水密舱壁的粒度级别。例如，如果你想在分区上放租户，你可以将每个租户放到独立的分区，或者将几个租户放到一个分区。 监控每个分区的性能和服务水平协议（Service Level Agreement）何时使用这种模式这种模式适用于： 隔离用于消费一系列后端服务的资源，尤其是即使其中一个服务无响应，应用程序能够提供某些级别的功能的情况。 将重要的消费者与普通消费者隔离开。 防止应用程序发生雪崩故障。这种模式不适用于： 项目中不能接受对资源的低效利用。 没有必要增加复杂度的情况。例子下面的Kubernetes配置文件创建了一个隔离的容器用于运行单个服务，定义了它自己的CPU和内存资源以及限额。apiVersion: v1kind: Podmetadata: name: drone-managementspec: containers: - name: drone-management-container image: drone-service resources: requests: memory: \"64Mi\" cpu: \"250m\" limits: memory: \"128Mi\" cpu: \"1\"" }, { "title": "Java Streams vs. Reactive Streams", "url": "/2020/01/25/java-streams-vs-reative-streams/", "categories": "", "tags": "Java", "date": "2020-01-25 23:52:00 +0800", "snippet": "Java: imperative + object-orientedMichael Feather:​\t“In OPP we encapsulate the moving parts; in FP we eliminate the moving parts.”List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);//double of even numbersList&lt;Integer&gt; doubled = new ArrayList&lt;&gt;();for (int i = 0; i &lt; numbers.size(); i++) {\tif (numbers.get(i) % 2 == 0) {\t\tdoubled.add(numbers.get(i) * 2);\t}}System.out.println(doubled);System.out.println(\tnumbers.stream()\t\t\t.filter( e -&gt; e % 2 == 0)\t\t.map( e -&gt; e * 2)\t\t.collect(toList()));functional programming == functional composition + lazy evaluationCollection Pipeline PatternStream is not a data structure it is an abstraction of functionsbucket vs pipelineList/Set\t Streamdataflow computingServerless" }, { "title": "Java虚方法调用", "url": "/2020/01/24/java-virtual-method-invocation/", "categories": "", "tags": "Java", "date": "2020-01-24 20:04:00 +0800", "snippet": "先回顾基本概念 Overloading and Overriding主要需要总结的是:​\tWhen multiple overloaded methods are present, Java looks for the closest match first. It tries to find the following: Exact match by type Matching a superclass type Converting to larger primitive type Converting to an autoboxed type VarargsFor overriding, the overridden method has a few rules: The access modifier must be the same or more accessible. The return type must be the same or a more restrictive type, also known as covariant return types. If any checked exceptions are thrown, only the same exceptions or subclasses of those exceptions are allowed to be thrown.The method must not be static. (If they are, the method is hidden and not overridden.)关于 instanceof 操作符，null 的情况，null 不是 Object.instanceof 不能比较没有任何继承关系的类。 而接口可以，因为接口可以被实现。然后入正题:Understanding Virtual Method Invocation先看代码：abstract class Animal {\tpublic abstract void feed();}class Cow extends Animal {\tpublic void feed() { addHay(); }\tprivate void addHay() { }}class Bird extends Animal { public void feed() { addSeed(); } private void addSeed() { }}class Lion extends Animal { public void feed() { addMeat(); } private void addMeat() { }}The Animal class is abstract, and it requires that any concrete Animal subclass have a feed() method. The three subclasses that we defined have a one-line feed() method that delegates to the class-specific method. A Bird still gets seed, a Cow still gets hay, and so forth. Now the method to feed the animals is really easy. We just call feed() and the proper subclass’s version is run.​\tThis approach has a huge advantage. The feedAnimal() method doesn’t need to change when we add a new Animal subclass. We could have methods to feed the animals all over code. Maybe the animals get fed at different times on different days. No matter. feed() still gets called to do the work.public void feedAnimal(Animal animal) {\tanimal.feed();}​\tWe’ve just relied on virtual method invocation. We actually saw virtual methods on the OCA. They are just regular non-static methods. Java looks for an overridden method rather than necessarily using the one in the class that the compiler says we have. The only thing new about virtual methods on OCP is that Oracle now calls them virtual methods in the objectives. You can simply think of them as methods.​\tIn the above example, we have an Animal instance, but Java didn’t call feed on the Animal class. Instead Java looked at the actual type of animal at runtime and called feed on that.​\tNotice how this technique is called virtual method invocation. Instance variables don’t work this way. In this example, the Animal class refers to name. It uses the one in the superclass and not the subclass.abstract class Animal { String name = \"???\"; public void printName() { System.out.println(name); }}class Lion extends Animal { String name = \"Leo\";}public class PlayWithAnimal { public static void main(String[] args) { Animal animal = new Lion(); animal.printName(); }}​\tThis outputs ???. The name declared in Lion would only be used if name was referred to from Lion (or a subclass of Lion.) But no matter how you call printName(), it will use the Animal’s name, not the Lion’s name.​\tAside from the formal sounding name, there isn’t anything new here. Let’s try one more example to make sure that the exam can’t trick you. What does the following print?abstract class Animal { public void careFor() { play(); } public void play() { System.out.println(\"pet animal\"); }}class Lion extends Animal { public void play() { System.out.println(\"toss in meat\"); }}public class PalyWithAnimal { public static void main(String[] args) { Animal animal = new Lion(); animal.careFor(); }}​\tThis correct answer is toss in meat. The main method creates a new Lion and calls careFor. Since only the Animal superclass has a careFor method, it executes. That method calls play. Java looks for overridden methods, and it sees that Lion implements play. Even though the call is from the Animal class, Java still looks at subclasses, which is good because you don’t want to pet a Lion!" }, { "title": "Java模块化", "url": "/2020/01/22/java-modules/", "categories": "", "tags": "Java 11", "date": "2020-01-22 00:14:00 +0800", "snippet": "为了准备 1Z0-816，要学习一下 Java 11 的基础部分。模块描述符语法ModuleDeclaration:\t{Annotation} [open] module Identifier {. Identifier}\t\t{{ModuleDirective}}ModuleDirective: requires {RequiresModifier} ModuleName ; exports PackageName [to ModuleName {, ModuleName}] ; opens PackageName [to ModuleName {, ModuleName}] ; uses TypeName ; provides TypeName with TypeName {, TypeName} ;RequiresModifier: (one of) transitive static创建模块module-info.java 是模块描述符。最简单的一个模块如下：module io.zwt.common {}定义模块间依赖模块的访问控制服务消费者与服务提供者" }, { "title": "响应式Spring Boot系列教程10", "url": "/2020/01/09/reactive-spring-boot-part10-spring-profiles-to-switch-clients/", "categories": "", "tags": "JavaFX, Spring Boot, Reactive, 教程", "date": "2020-01-09 11:12:00 +0800", "snippet": " 原文由 Trisha Gee 在当地时间2019年12月16日发布在 INTELLIJ IDEA BLOG在这一节，我们使用Spring Profiles让应用程序决定使用哪个客户端（使用服务端发送事件的 WebClient，或 RSocket）连接到Kotlin Spring Boot股票价格服务。现在我们有了一个RSocket客户端，可以让我们连接到我们的RSocket服务器，我们想在我们的JavaFX应用程序中使用它。创建 RSocketStockClient Bean我们特意创建两种StockClient实现，一个通过RSocket连接，然后另一个是用WebClient。我们的ClientConfiguration仅将其中一个Bean暴露，即WebClientStockClient，如果我们希望应用程序能够使用RSocket客户端，则也需要添加一个RSocketClient Bean。 在stock-client模块的ClientConfiguration创建一个新的@Bean方法，命名为rSocketStockClient，其返回值类型为StockClient。 这个方法体需要返回一个新的RSocketStockClient，所以需要一个rSocketRequester作为构造函数参数。 给rSocketStockClient方法添加一个RSocketRequester作为参数。 （提示：我们可以让IntelliJ IDEA添加适当的方法参数，如果我们传入一个未知变量rSocketRequester到RSocketStockClient的构造器，在未知变量按下Alt+Enter并选择“Create parameter”） （提示：IntelliJ IDEA Ultimate会警告你说这个参数不能自动注入，因为没有类型匹配的Beans） 创建另一个名为rSocketRequester的@Bean方法，返回RSocketRequester。 给方法声明一个类型为RSocketRequester.Builder的参数builder 这应该会被Spring自动注入。 使用builder的connectTcp方法，并给它 “localhost” 和端口 7000(这是Spring Boot的RSocket运行地址)。调用block()方法完成这次连接。 @Configurationpublic class ClientConfiguration { // WebClientStockClient bean 方法... @Bean public StockClient rSocketStockClient(RSocketRequester rSocketRequester) { return new RSocketStockClient(rSocketRequester); } @Bean public RSocketRequester rSocketRequester(RSocketRequester.Builder builder) { return builder.connectTcp(\"localhost\", 7000).block(); } // WebClient bean 方法...}选择使用哪个 Bean如果我们回到JavaFX的ChartController（在stock-ui 模块），这个类就是用了StockClient去连接到价格服务，并在图表上显示价格的。IntelliJ IDEA 旗舰版在这个类显示警告，说这里边有多于一个Bean符合 StockClient 类型，也就是我们的rSocketStockClient和webClientStockClient。我们需要配置一种方式，指定我们实际想要使用哪个客户端。一种做法是使用Spring profiles。 添加一个@Profile注解到webClientStockClient方法，传入一个值 sse（表示 Server-Sent Events)。 给rSocketStockClient添加一个@Profile注解，值为rsocket@Bean@Profile(\"sse\")public StockClient webClientStockClient(WebClient webClient) { return new WebClientStockClient(webClient);} @Bean@Profile(\"rsocket\")public StockClient rSocketStockClient(RSocketRequester rSocketRequester) { return new RSocketStockClient(rSocketRequester);}选择激活的配置如果我们使用的是IntelliJ IDEA旗舰版，当我们在ChartController里面，我们可以看到错误已经消失了。但我们还是需要指定想要使用哪个配置(profile)。 去到stock-ui模块的application.properties文件 设置 spring.profiles.active属性的值为sse这应该会给我们同样的Bean和之前同样的功能。# web-application and application title properties here...spring.profiles.active=sse 重新运行应用程序，程序应该按预期启动，并像之前那样显示两组价格数据。 注意到在运行窗口，JavaFX应用程序已经以sse配置启动。调试日志如果我们想更加确认我们所使用的Bean，我们可以回到客户端并添加一些日志功能。 在WebClientStockClient里面的pricesFor方法添加一个info等级的日志信息表示当前使用的是 WebClient stock client。public Flux&lt;StockPrice&gt; pricesFor(String symbol) { log.info(\"WebClient stock client\"); return // 在这里创建Flux} 在RSocketStockClient也做类似的操作public Flux&lt;StockPrice&gt; pricesFor(String symbol) { log.info(\"RSocket stock client\"); return // 在这里创建Flux} 重新运行应用程序，我们应该看到两个日志消息，表示我们当前使用的是WebClient stock client。通过 RSocket 获取价格最后让我们使用RSocket去获取股票价格并显示到JavaFX的折线图上吧。 回到stock-ui的application.properties文件，并将活动的配置改为rsocket。 重新运行应用程序，所有东西应该按预期运行。这次我们使用的是rsocket配置，并通过RSocketStockClient连接到RSocket价格服务器。#这里是 web-application 和 application title 的属性...spring.profiles.active=rsocket所以就是这样子。一个完整的带有JavaFX折线图，并订阅到一个Kotlin Spring Boot应用程序的响应式数据流的价格数据的端到端应用程序。而且我们能够配置通过服务端发送事件或新的RSocket协议获取这些股票价格。全部代码在 GitHub：https://github.com/zwt-io/rsb/" }, { "title": "响应式Spring Boot系列教程9", "url": "/2020/01/09/reactive-spring-boot-part9-java-rsocket-client/", "categories": "", "tags": "JavaFX, Spring Boot, RSocket", "date": "2020-01-09 10:10:00 +0800", "snippet": " 原文由 Trisha Gee 在2019年12月13日发布在 INTELLIJ IDEA BLOG在这一节，我们添加一个RSocket客户端，用来连接上一节创建的RSocket服务器。现在，我们有了一个使用Spring WebClient的端到端应用程序。在上一节中，我们介绍了一个新的RSocket服务器，在这节，我们将看到如何创建一个客户端来连接它创建一个集成测试与WebClientStockClient一样，我们将通过集成测试来驱动RSocket客户端，测试看起来与WebClientStockClientIntegrationTest几乎相同。 所以让我们复制这个测试并将其重命名为RSocketStockClientIntegrationTest。 将变量WebClientStockClient改为RSocketStockClient并重命名为rSocketStockClient。 （提示：使用IntelliJ IDEA的rename refactoring来重命名，会将其余地方用到的这个变量都重命名了，不需要查找和替换）。 我们知道这不需要WebClient，因为WebClientStockClient才需要的。移除构造函数参数和字段声明。class RSocketStockClientIntegrationTest { @Test void shouldRetrieveStockPricesFromTheService() { // given RSocketStockClient rSocketStockClient = new RSocketStockClient(); // when Flux&lt;StockPrice&gt; prices = rSocketStockClient.pricesFor(\"SYMBOL\"); // then Assertions.assertNotNull(prices); Flux&lt;StockPrice&gt; fivePrices = prices.take(5); Assertions.assertEquals(5, fivePrices.count().block()); Assertions.assertEquals(\"SYMBOL\", fivePrices.blockFirst().getSymbol()); }}（注意：这代码现在还未能通过编译）创建 RSocket 客户端 RSocketStockClient还不存在，让我们创建一个空类。 （提示：在红色的RSocketStockClient代码按下 Alt+Enter会给我们选择创建这个类） 测试假定要一个pricesFor方法，所以在RSocketStockClient里面创建这个缺少的方法。 （提示：在RSocketStockClient里红色的pricesFor方法按下Alt+Enter会给我们创建这个方法的选择，并且有正确的方法签名。)public class RSocketStockClient { public Flux&lt;StockPrice&gt; pricesFor(String symbol) { return null; }}引入 StockClient 接口当然方法声明看起来跟在WebClientStockClient里面的一样，所以这是引入接口的好时机，让两个客户端都实现同样的接口。 创建一个接口StockClient我们希望pricesFor方法出现在接口上，因为这个方法在两个客户端类的方法签名一样的。 （提示：在WebClientStockClient上使用IntelliJ IDEA的Extract Interface 功能，可以自动地创建一个带有 pricesFor方法的接口。）public interface StockClient { Flux&lt;StockPrice&gt; pricesFor(String symbol);} 确保WebClientStockClient已经更新为实现新的StockClient接口了，并且添加了@Override注解到pricesFor方法上。public class WebClientStockClient implements StockClient { // 这里进行初始化... @Override public Flux&lt;StockPrice&gt; pricesFor(String symbol) { // 这里是实现 }} 对RSocketStockClient也是同样的操作public class RSocketStockClient implements StockClient { @Override public Flux&lt;StockPrice&gt; pricesFor(String symbol) { return null; }} 目前测试能通过编译，运行它看到不能通过测试。它失败的原因应该是在assertNotNull断言上，因为我们从pricesFor方法返回null。实现RSocket链接通常 在测试驱动开发中，我们会采取一些小步骤来使测试通过，然后再有更详细的测试。在本课程中我们将直接进入并实现能用的RSocket客户端。 在stock-client模块添加一个spring-boot-starter-rsocket依赖到pom.xml文件&lt;dependencies&gt;\t&lt;dependency&gt;\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t&lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;\t&lt;/dependency&gt;\t&lt;dependency&gt;\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\t\t&lt;artifactId&gt;spring-boot-starter-rsocket&lt;/artifactId&gt;\t&lt;/dependency&gt;\t&lt;!-- more dependencies... --&gt; 添加一个类型为RSocketRequester的字段rSocketRequester到RSocketStockClient。 为它添加一个构造函数参数 （提示：IntelliJ IDEA可以为字段自动生构造函数参数）public class RSocketStockClient implements StockClient { private RSocketRequester rSocketRequester; public RSocketStockClient(RSocketRequester rSocketRequester) { this.rSocketRequester = rSocketRequester; } // pricesFor 方法...} 在pricesFor方法，调用rSocketRequester.route。 对于路由，我们想要使用跟在后端RSocket服务定义的相同，在我们的例子中是“stockPrices”。 通过data方法向服务器发送一个股票代号。 我们期望调用返回一个股票价格的Flux，所以将StockPrice.class传入到retrieveFlux方法。 返回这些调用pricesFor方法的结果，而不是null。public class RSocketStockClient implements StockClient { private RSocketRequester rSocketRequester; public RSocketStockClient(RSocketRequester rSocketRequester) { this.rSocketRequester = rSocketRequester; } @Override public Flux&lt;StockPrice&gt; pricesFor(String symbol) { return rSocketRequester.route(\"stockPrices\") .data(symbol) .retrieveFlux(StockPrice.class); }}创建一个 RSocketRequester测试代码不能通过编译，因为我们添加了一个rSocketRequester到构造函数参数，然而在测试里我们没有RSocketRequester实例。 在测试里创建一个名为createRSocketRequester的私有方法，放在上方靠近其它对象初始化的位置。 为RSocketRequester.Builder创建一个字段。如果我们添加@Autowired注解，Spring将会为我们的测试注入一个实例。 要让Spring管理我们的测试，我们需要将它注解为@SpringBootTest。 在createRSocketRequester里面，使用rSocketRequester通过TCP连接到我们的RSocket服务器，它运行在localhost的7000端口。 调用block直到连接上。@SpringBootTestclass RSocketStockClientIntegrationTest { @Autowired private RSocketRequester.Builder builder; private RSocketRequester createRSocketRequester() { return builder.connectTcp(\"localhost\", 7000).block(); } @Test void shouldRetrieveStockPricesFromTheService() { // implementation... }}通过集成测试我们期待这个测试能运行，但我们错过了一些重要的东西。我们发现个错误，说missing a SpringBootConfiguration看起来可能有点令人费解。实际上，这个模块并没有任何SpringBootApplication。因为这是用于作为一个库，给其它应用代码共享代码的，它本身不是一个应用程序。让我们看一种解决方案让测试跑起来。 在test目录里创建一个类TestApplication。 将它注解为@SpringBootApplication。 重新运行集成测试，所有东西应该按预期启动，并且测试应该通过了。@SpringBootApplicationpublic class TestApplication {}使用 StepVerifier 进行测试一旦测试通过了，我们可以假设客户端已经成功地通过RSocket连接到了服务器，获取一个Flux的StockPrice对象，可以去其中的前五个，然后检查第一个是否有正确的股票代码。这是稍微简单的测试响应式应用程序的方式。还有其它的方式，其中一种就是使用StepVerifier使用这种方式，我们可以编写我们期望看到的事件。 创建一个新的StepVerifier从prices Flux里面取5个价格。 使用expectNextMatches检查所有5个股票价格对应的股票代码是正确的。 调用去检查不仅这些期望达到了，并且在这5个之后没有更多的StockPrice对象了。 删除旧的断言（StepVerifier将它们全部替换了）。@Testvoid shouldRetrieveStockPricesFromTheService() { // given RSocketStockClient rSocketStockClient = new RSocketStockClient(createRSocketRequester()); // when Flux&lt;StockPrice&gt; prices = rSocketStockClient.pricesFor(\"SYMBOL\"); // then StepVerifier.create(prices.take(5)) .expectNextMatches(stockPrice -&gt; stockPrice.getSymbol().equals(\"SYMBOL\")) .expectNextMatches(stockPrice -&gt; stockPrice.getSymbol().equals(\"SYMBOL\")) .expectNextMatches(stockPrice -&gt; stockPrice.getSymbol().equals(\"SYMBOL\")) .expectNextMatches(stockPrice -&gt; stockPrice.getSymbol().equals(\"SYMBOL\")) .expectNextMatches(stockPrice -&gt; stockPrice.getSymbol().equals(\"SYMBOL\")) .verifyComplete();}This approach can support much more than this simple example, and is also very useful for testing time-based publishers like ours. 这种方式可以支持比这个简单例子更多的操作，而且对于测试像我们这种基于时间的发布者很有用。添加重试退避已经错误处理策略我们还有最后一件事要考虑。我们的WebClientStockClient定义了一个退避重试策略，以及简单的错误处理方法。实际上我们对于RSocketStockClient也采取同样的方式。 从WebClientStockClient复制retryBackoff和doOnError步骤并粘贴到 RSocketStockClient.pricesFor里面。 重新运行测试，它应该还能通过的。@Log4j2public class RSocketStockClient implements StockClient { private RSocketRequester rSocketRequester; public RSocketStockClient(RSocketRequester rSocketRequester) { this.rSocketRequester = rSocketRequester; } @Override public Flux&lt;StockPrice&gt; pricesFor(String symbol) { return rSocketRequester.route(\"stockPrices\") .data(symbol) .retrieveFlux(StockPrice.class) .retryBackoff(5, Duration.ofSeconds(1), Duration.ofSeconds(20)) .doOnError(IOException.class, e -&gt; log.error(e.getMessage())); }}现在我们在后端有了发送股票价格的RSocket服务器，以及能够连接到它并查看价格的RSocket客户端。在下一节，我们会看一下如何从使用WebClientStockClient切换到RSocketStockClient。全部代码在 GitHub：https://github.com/zwt-io/rsb/" }, { "title": "响应式Spring Boot系列教程8", "url": "/2020/01/09/reactive-spring-boot-part8-kotlin-rsocket-server/", "categories": "", "tags": "RSocket, Kotlin, Spring Boot, Reactive", "date": "2020-01-09 09:49:00 +0800", "snippet": " 原文由 Trisha Gee 在当地时间2019年12月9日发布在 INTELLIJ IDEA BLOG在这一节，我们将给Kotlin后端添加一个新的服务，这次是通过RSocket，一种为响应式数据流而生的协议，发送价格数据。目前为止，我们以及成功地创建了一个端到端的应用程序，从Kotlin Spring Boot后端发送价格数据，并且将它们展示到一个JavaFX折线图上。那用的是HTTP的服务器发送事件。 但是，既然我们这个是响应式应用程序，我们可能想要选择一种更加适合流式数据的协议。在这一步，我们要创建一个通过RSocket协议发送价格数据的服务创建一个RSocket控制器我们要对在本教程第一部分当中创建的Kotlin Spring Boot应用程序做一些更改，我们的 StockServiceApplication.kt文件。我们已存在的服务有一个REST控制器，我们将为RSocket创建一个类似的类。 在StockServiceApplication.kt内，创建一个新的类RSocketController。 将其注解为Spring的Controller。 创建一个新的需要一个参数的Kotlin函数。 （提示：我们可以使用 fun1 Live模板去让 IntelliJ IDEA给我们创建这个函数的轮廓）。 将这个函数命名为prices就跟RestController函数里的一样。 它需要一个String类型的参数symbol并且返回一个Flux的StockPrice。@SpringBootApplicationclass StockServiceApplication // main 函数在这里... @RestControllerclass RestController() { // 控制器主体在这里...} @Controllerclass RSocketController() { fun prices(symbol: String): Flux&lt;StockPrice&gt; { }} // 这里是StockPrice数据类（注意：这些代码还未能通过编译，函数需要返回某些东西）。引入价格服务这里的prices函数看起来会跟RestController里面的prices函数非常像，因为它们实际上是干同样的事情。唯一不同之处是它们以不同的方式发布价格数据。为了减少冗余，让我们引入一个价格服务包含它们共享的逻辑。 添加一个类型为PriceService的构造函数参数priceService。 （提示：如果我们在prices方法体输入priceService，我们可以在红色的文字按下Alt+Enter，让IntelliJ IDEA 为构造函数参数创建属性priceService)。 在同一个文件中创建一个PriceService类。 （提示：在StockServiceApplication.kt文件，我们可以在构造函数里面红色的PriceService按下Alt+Eneter，然后让 IntelliJ IDEA 创建类PriceService）。 用@Service将PriceService注解。@SpringBootApplicationclass StockServiceApplication // main函数在这里 // @RestController在这里 @Controllerclass RSocketController(val priceService: PriceService) { fun prices(symbol: String): Flux&lt;StockPrice&gt; { }} @Serviceclass PriceService { } // StockPrice数据类在这里将共享代码移入 PriceService 在service类创建一个函数generatePrices。 （提示：如果我们在RSocketController的prices函数内调用 pricesService.generatePrices ，我们可以在红色的函数上按 Alt + Enter ，让IntelliJ IDEA为我们生成函数）。 这个函数需要一个类型为String的股票代号（symbol)，并返回一个StockPrice的Flux，跟我们的prices函数一样。 这样的逻辑以及存在于RestController.prices，所以将那个函数体复制到新的generatePrices 函数里。 这也需要randomStockPrice函数，所以从RestController复制这个到PriceService。 确保RSocketController里面的prices方法调用generatePrices并返回结果。@SpringBootApplicationclass StockServiceApplication // main函数在这里... // @RestController在这里 @Controllerclass RSocketController(val priceService: PriceService) { fun prices(symbol: String): Flux&lt;StockPrice&gt; { return priceService.generatePrices(symbol) }} @Serviceclass PriceService { fun generatePrices(symbol: String): Flux&lt;StockPrice&gt; { return Flux .interval(Duration.ofSeconds(1)) .map { StockPrice(symbol, randomStockPrice(), now()) } } private fun randomStockPrice(): Double { return ThreadLocalRandom.current().nextDouble(100.0) }} // StockPrice数据类在这里减少重复代码现在这里所有东西都能通过编译，我们可以从RestController里移除冗余的代码。 在RestController的构造函数参数引入priceService。 从RestController.prices里面调用generatePrices而不是在那里调用。 移除RestController里面的randomStockPrice函数，因为没有用到。 （提示：我们可以在灰色的randomStockPrices函数名上按下Alt+Enter，并选择Safe delete去将它移除。 或者我们可以函数名上使用 Alt + Delete/⌘⌦）。@RestControllerclass RestController(val priceService: PriceService) { @GetMapping(value = [\"/stocks/{symbol}\"], produces = [MediaType.TEXT_EVENT_STREAM_VALUE]) fun prices(@PathVariable symbol: String): Flux&lt;StockPrice&gt; { return priceService.generatePrices(symbol) }} @Controllerclass RSocketController(val priceService: PriceService) { fun prices(symbol: String): Flux&lt;StockPrice&gt; { return priceService.generatePrices(symbol) }} @Serviceclass PriceService { fun generatePrices(symbol: String): Flux&lt;StockPrice&gt; { return Flux .interval(Duration.ofSeconds(1)) .map { StockPrice(symbol, randomStockPrice(), now()) } } private fun randomStockPrice(): Double { return ThreadLocalRandom.current().nextDouble(100.0) }}重构减少模板代码在RestController和RSocketController上的prices函数现在都只是直接调用PriceService所有所有通用的代码都在要给地方了。Kotlin让我们可以进一步简化代码。 将prices函数转化为一个表达式体（expression body），并移除声明的返回值类型。 （提示：如果我们在函数的花括号上按下 Alt + Enter，IntelliJ IDEA 会提供选项”Convert to expression body” 完成这个操作之后，返回值类型会被高亮，然后我们可以轻松将它删除）。 对prices函数进行这样的操作。@RestControllerclass RestController(val priceService: PriceService) { @GetMapping(value = [\"/stocks/{symbol}\"], produces = [MediaType.TEXT_EVENT_STREAM_VALUE]) fun prices(@PathVariable symbol: String) = priceService.generatePrices(symbol) } @Controllerclass RSocketController(val priceService: PriceService) { fun prices(symbol: String) = priceService.generatePrices(symbol)}Because this function is a simple delegation, this might be a more useful, and certainly shorter, way to write it. 因为这个函数是一个简单的委派，这可能更有用，肯定是更加简短，便于编写。设置好消息映射那个RestController是用@GetMapping注解的，用于设置客户端连接到价格数据流的URL。 对于 RSocketController函数我们也需要类型的东西。 给RSocketController.prices添加一个@MessageMapping注解。 添加spring-boot-starter-rsocket依赖到pom.xml文件。 （提示：IntelliJ IDEA能帮我们在pom.xml里面进行代码补全，或者生成一个依赖）。&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-rsocket&lt;/artifactId&gt;&lt;/dependency&gt; 回到我们的StockServiceApplication文件，我们可以为@MessageMapping添加一个导入。 给@MassageMapping注解添加一个字符串路由，以便客户端能够连接。@Controllerclass RSocketController(val priceService: PriceService) { @MessageMapping(\"stockPrices\") fun prices(symbol: String) = priceService.generatePrices(symbol)}设置好一个 RSocket 服务器现在如果我们启动应用程序，我们可以看到哪个服务器已经被启动。目前，我们应该只能看到8080端口的 Netty。我们想RSocket服务器也启动。去到application.properties文件并定义一个RSocket服务端口为 7000spring.rsocket.server.port=7000只需要在这里定义端口就足以让Spring Boot为我们启动一个RSocket服务器，因此我们只需要重启应用程序，我们会看到一个Netty RSocket服务器启动在7000端口（例子可以看配套视频的最后）。现在我们在7000端口有了一个价格服务准备好给客户端通过RSocket去连接获取价格数据了。下一节，我们将连接到这个服务器，并消费价格数据。全部代码在 GitHub：https://github.com/zwt-io/rsb/" }, { "title": "响应式Spring Boot系列教程7", "url": "/2020/01/09/reactive-spring-boot-part7-subscribing-multiple-consumers/", "categories": "", "tags": "JavaFX, Tutorial, Spring Boot, Reactive", "date": "2020-01-09 09:49:00 +0800", "snippet": " 原文由 Trisha Gee 在当地时间2019年12月2日发布在 INTELLIJ IDEA BLOG在这一节，我们更新实时更新图表显示多于一种股票价格，也就意味着订阅多于一个消费者到我们的响应式价格数据流。在上一步，我们让JavaFX折线图订阅到来自响应式Spring Boot的服务，并实时显示它们。在这一步，我们要更新图表，让它能多次订阅并在同一个图表显示多组数据。引入价格订阅器那个ChartController负责管理数据如何显示的，包含了一个将ChartController自身订阅到客户端的调用，那个客户端监听股票价格服务（请看前面的文章了解ChartController的初始状态）我们要修改这个，所以我们有不止一个订阅者。 在ChartController内的订阅者调用，替换this为一个新的类型的构造函数，PriceSubscriber. 这个类会负责管理从客户端消费价格数据。 将PriceSubscriber作为内部类，它需要实现Consumer并消费StockPrice。 （提示：IntelliJ IDEA能够为我们自动创建这个，如果我们在PriceSubscriber名称初次敲入时按下Alt+Enter）。public void initialize() { // 其它代码... webClientStockClient.pricesFor(symbol) .subscribe(new PriceSubscriber());} private class PriceSubscriber implements Consumer&lt;StockPrice&gt; {}将职责移到PriceSubscriber 将accept方法从ChartController移到PriceSubscriber。 从ChartController当中移除 “implements Consumer”声明。 将seriesData从ChartController移入到PriceSubscriber。 以symbol做参数调用PriceSubscriber构造函数，并更新PriceSubscriber去接受this作为构造函数参数。 （提示：我们可以让 IntelliJ IDEA去创建适当的构造函数，如果我们传入symbol，按下Alt+Enter并选择“Create constructor”)。 将创建Series操作移入到PriceSubscriber的构造函数并将series存为字段。 为series添加getter，因为ChartController需要获取这个series并添加到图表。 （提示：IntelliJ IDEA可以由字段生成getters）。private class PriceSubscriber implements Consumer&lt;StockPrice&gt; { private Series&lt;String, Double&gt; series; private ObservableList&lt;Data&lt;String, Double&gt;&gt; seriesData = observableArrayList(); private PriceSubscriber(String symbol) { series = new Series&lt;&gt;(symbol, seriesData); } @Override public void accept(StockPrice stockPrice) { Platform.runLater(() -&gt; seriesData.add(new Data&lt;&gt;(valueOf(stockPrice.getTime().getSecond()), stockPrice.getPrice())) ); } public Series&lt;String, Double&gt; getSeries() { return series; }}让我们修复ChartController的初始化方法 将新的PriceSubscriber提取到一个本地变量，我们要在方法的别处使用这个。 将这个priceSubscriber移动靠近方法顶部，然后在data.add里面调用getter。@Componentpublic class ChartController { @FXML private LineChart&lt;String, Double&gt; chart; private WebClientStockClient webClientStockClient; public ChartController(WebClientStockClient webClientStockClient) { this.webClientStockClient = webClientStockClient; } @FXML public void initialize() { String symbol = \"SYMBOL\"; PriceSubscriber priceSubscriber = new PriceSubscriber(symbol); ObservableList&lt;Series&lt;String, Double&gt;&gt; data = observableArrayList(); data.add(priceSubscriber.getSeries()); chart.setData(data); webClientStockClient.pricesFor(symbol) .subscribe(priceSubscriber); } private class PriceSubscriber implements Consumer&lt;StockPrice&gt; { // 之前代码的细节 }}如果我们重新运行应用程序，这图表应该像之前那样运行（假设后端服务也在运行），因为我们并没有改变行为，只是重构了订阅。添加第二个订阅者 将symbol重命名为symbol1，因为我们要有另一个这东西，重命名symbol本身，然后让我们也重命名priceSubscriber。 （提示：使用 rename refactoring，Shift + F6，实现这操作，这样确保所有代码仍能通过编译。） 重复这些行，并将变量名改为symbol2和priceSubscribe2。 （提示：重复行的键盘快捷键是Ctrl+D/⌘D）。 添加第二个系列数据到图表显示第二组价格数据。 重复订阅者代码并传入第二个股票代码和第二个订阅者public void initialize() { String symbol1 = \"SYMBOL1\"; PriceSubscriber priceSubscriber1 = new PriceSubscriber(symbol1); String symbol2 = \"SYMBOL2\"; PriceSubscriber priceSubscriber2 = new PriceSubscriber(symbol2); ObservableList&lt;Series&lt;String, Double&gt;&gt; data = observableArrayList(); data.add(priceSubscriber1.getSeries()); data.add(priceSubscriber2.getSeries()); chart.setData(data); webClientStockClient.pricesFor(symbol1) .subscribe(priceSubscriber1); webClientStockClient.pricesFor(symbol2) .subscribe(priceSubscriber2);}现在当我们重新运行应用程序，我们可以看到两个不同的系列在图表上追踪两个不同的股票价格，正如在视频的3:30看到的那样。整理代码现在我们的应用程序按预期运行，我们可以重构一下代码如果我们想的话。 我们可以将对订阅者的调用移到接近我们创建订阅者的上方。 我们可以清楚任意警告，例如让内部类改为静态。public void initialize() { String symbol1 = \"SYMBOL1\"; PriceSubscriber priceSubscriber1 = new PriceSubscriber(symbol1); webClientStockClient.pricesFor(symbol1) .subscribe(priceSubscriber1); String symbol2 = \"SYMBOL2\"; PriceSubscriber priceSubscriber2 = new PriceSubscriber(symbol2); webClientStockClient.pricesFor(symbol2) .subscribe(priceSubscriber2); ObservableList&lt;Series&lt;String, Double&gt;&gt; data = observableArrayList(); data.add(priceSubscriber1.getSeries()); data.add(priceSubscriber2.getSeries()); chart.setData(data);}额外的重构（不在视频中）有很多种方式可以进一步重构这些代码使之更容易阅读，减少冗余，或者按职责区别对待。例如，我们可以将对订阅的调用移入到PriceSubscriber以减少重复。我们甚至可以使用var如果我们的Java版本支持的话。public class ChartController { // ... fields and constructor ... @FXML public void initialize() { var priceSubscriber1 = new PriceSubscriber(\"SYMBOL1\", webClientStockClient); var priceSubscriber2 = new PriceSubscriber(\"SYMBOL2\", webClientStockClient); ObservableList&lt;Series&lt;String, Double&gt;&gt; data = observableArrayList(); data.add(priceSubscriber1.getSeries()); data.add(priceSubscriber2.getSeries()); chart.setData(data); } private static class PriceSubscriber implements Consumer&lt;StockPrice&gt; { private Series&lt;String, Double&gt; series; private ObservableList&lt;Data&lt;String, Double&gt;&gt; seriesData = observableArrayList(); private PriceSubscriber(String symbol, WebClientStockClient stockClient) { series = new Series&lt;&gt;(symbol, seriesData); stockClient.pricesFor(symbol) .subscribe(this); } @Override public void accept(StockPrice stockPrice) { Platform.runLater(() -&gt; seriesData.add(new Data&lt;&gt;(valueOf(stockPrice.getTime().getSecond()), stockPrice.getPrice())) ); } private Series&lt;String, Double&gt; getSeries() { return series; } }}总结所以现在我们有一个JavaFX应用程序，它能从Spring Boot服务订阅不止一种股票价格，而且能作折线图上一多个系列实时显示每组价格数据。全部代码在 GitHub：https://github.com/zwt-io/rsb/" }, { "title": "响应式Spring Boot系列教程6", "url": "/2020/01/09/reactive-spring-boot-part6-displaying-reactive-data/", "categories": "", "tags": "JavaFX, Tutorial, Spring Boot, Reactive", "date": "2020-01-09 09:38:00 +0800", "snippet": " 原文由 Trisha Gee 在当地时间2019年11月29日发布在 INTELLIJ IDEA BLOG在这一节，我们看一下如何连接JavaFX折线图到Kotlin Spring Boot服务以实时显示股票价格数据。在第四步，我们创建了一个JavaFX Spring Boot应用程序显示一个空的折线图。在上一步（第五步），我们整合了WebClientStockClient去连接到股票价格服务。在这一步我们要让折线图实时显示来自Kotlin Spring Boot服务的股票价格数据。设置好图表数据 在stock-ui模块的ChartController，创建一个initialize方法，这个方法会在FXML的字段被值填充完成后被调用。这个initialize方法会设置好图表数据的来源。 在图表上调用setData方法并创建一个局部变量data用于保存系列数据列表，用于传入到这个方法。 创建一个Series添加到data列表，并传入到seriesData。 创建seriesData作为一个字段，即空列表，使用FXCollections.observableArrayList()。public class ChartController { @FXML private LineChart&lt;String, Double&gt; chart; private WebClientStockClient webClientStockClient; private ObservableList&lt;Data&lt;String, Double&gt;&gt; seriesData = FXCollections.observableArrayList(); public ChartController(WebClientStockClient webClientStockClient) { this.webClientStockClient = webClientStockClient; } @FXML public void initialize() { ObservableList&lt;XYChart.Series&lt;String, Double&gt;&gt; data = FXCollections.observableArrayList(); data.add(new XYChart.Series&lt;&gt;(seriesData)); chart.setData(data); }}订阅到价格数据我们需要为图表从某处获取数据。这就是我们为什么添加了webClientStockClient。 在initialize方法内调用webClientStockClient的pricesFor方法，并传入用于获取股票价格的代号。现在我们可以暂时将这个值设为“SYMBOL”。 我们需要将一些东西订阅到由这个调用返回的Flux。最简单的做法是调用subscribe并传入this。 让ChartController实现java.util.function.Consumer并让它消费StockPrice。 实现Consumer里边的accept方法。 （提示：我们可以通过在类声明上红色的字按下Alt+Enter并选择”implement methods”让IntelliJ IDEA 实现满足接口所需的方法）。public class ChartController implements Consumer&lt;StockPrice&gt; { // fields and constructor here... @FXML public void initialize() { ObservableList&lt;XYChart.Series&lt;String, Double&gt;&gt; data = FXCollections.observableArrayList(); data.add(new XYChart.Series&lt;&gt;(seriesData)); chart.setData(data); webClientStockClient.pricesFor(\"SYMBOL\").subscribe(this); } @Override public void accept(StockPrice stockPrice) { }}显示价格数据我们要决定当获取到StockPrice的时候要做什么。我们从股票价格数据里面添加适当的值到图表的系列数据上。 在accept内，已新的Data实例调用seriesData.add。 对于Data的y值，我们可以从股票价格的时间获取，然后取其中的“秒”值。这是int类型，它需要转换为 String，因此放在一个String.valueOf调用里。 （提示：我们可以用后缀补全参数去将一个表达式包含在一个方法调用里以简化对String.valueOf的调用，当我们已经输入了表达式）。 对于x值，我们使用来自股票价格的price值。public void accept(StockPrice stockPrice) { seriesData.add(new XYChart.Data&lt;&gt;(String.valueOf(stockPrice.getTime().getSecond()), stockPrice.getPrice()));}这看起来不错，但是这个编程模型还有一样东西需要考虑。修改系列数据会反映在对用户界面的更新，会被UI线程绘制。这个accept方法是运行在不同的线程的，监听着来自后端服务的事件。我们要告知UI线程，当有机会时运行这段代码。调用Platform.runLater，并在UI线程传入一个Lambda表达式。public void accept(StockPrice stockPrice) { Platform.runLater(() -&gt; seriesData.add(new XYChart.Data&lt;&gt;(String.valueOf(stockPrice.getTime().getSecond()), stockPrice.getPrice())) );}运行 chart 应用程序 确保后端的Kotlin Spring Boot服务正在运行（StockSeriviceApplication）。 回到UI模块并运行我们的JavaFX应用程序，StockUiApplication。 你应该能看到一个JavaFX折线图根据价格数据自动地更新。（见视频里 3:20的例子）显示股票代码名称 将硬编码的股票代号提取到一个局部变量，我们想在不止一个地方用到它。 （提示：我们可以使用 IntelliJ IDEA 的 Extract Variable(文档) (视频) 轻松完成此操作。） 我们可以给系列一个标签，通过在Series的构造器传入股票代码作为参数。public void initialize() { String symbol = \"SYMBOL\"; ObservableList&lt;XYChart.Series&lt;String, Double&gt;&gt; data = FXCollections.observableArrayList(); data.add(new XYChart.Series&lt;&gt;(symbol, seriesData)); chart.setData(data); webClientStockClient.pricesFor(symbol).subscribe(this);}现在当我们重新运行应用程序，我们可以看到股票代码出现在系列的标签上。代码清理这些代码太多类型信息有点笨拙，让我们简化一下。我们可以在这里提到的很多类的名称上按下Alt+Enter去让IntelliJ IDEA建议自动执行这些更改。 导入Series本身以移除不必要的XYChart前缀。 为observableArrayList添加一个静态导入，这样我们就不用到处重复FXCollections。 添加一个valueOf导入，使得设置图表数据那行更简短一些。 导入Data类以移除其它重复的XYChart。@Componentpublic class ChartController implements Consumer&lt;StockPrice&gt; { @FXML private LineChart&lt;String, Double&gt; chart; private WebClientStockClient webClientStockClient; private ObservableList&lt;Data&lt;String, Double&gt;&gt; seriesData = observableArrayList(); public ChartController(WebClientStockClient webClientStockClient) { this.webClientStockClient = webClientStockClient; } @FXML public void initialize() { String symbol = \"SYMBOL\"; ObservableList&lt;Series&lt;String, Double&gt;&gt; data = observableArrayList(); data.add(new Series&lt;&gt;(symbol, seriesData)); chart.setData(data); webClientStockClient.pricesFor(symbol).subscribe(this); } @Override public void accept(StockPrice stockPrice) { Platform.runLater(() -&gt; seriesData.add(new Data&lt;&gt;(valueOf(stockPrice.getTime().getSecond()), stockPrice.getPrice())) ); }}这次重构并不会改变代码的行为，所以我们重新运行看到一切都跟之前一样可用。总结用这几行代码，我们创建了一个JavaFX应用程序使用了Spring 的WebClient去连接到 Spring Boot 服务，订阅到价格数据流并实时将股票价格数据绘制在折线图上。全部代码在 GitHub：https://github.com/zwt-io/rsb/" }, { "title": "响应式Spring Boot系列教程5", "url": "/2020/01/09/reactive-spring-boot-part5-auto-configuration-for-shared-beans/", "categories": "", "tags": "JavaFX, Tutorial, Spring Boot, Reactive", "date": "2020-01-09 09:28:00 +0800", "snippet": " 原文由 Trisha Gee 在当地时间2019年11月25日发布在 INTELLIJ IDEA BLOG这一节我们看一下如何在一个模块中使用另一个不同的模块中的Spring Beans，通过使用自动装配。在上一节 ，我们创建了一个JavaFX Spring Boot应用程序显示一个空的折线图。在这篇文章，我们要看一下如何为 Spring Beans设置自动装配，以便我们可以在stock-ui模块里面使用在stock-client定义的Beans。添加另一个模块的依赖 打开我们在上一节创建的ChartController类。这个类将会负责在折线图上更新和显示数据。 我们的ChartController需要使用在第二节的WebClientStockClient，它将使用这个连接到股票价格服务。为客户端创建一个新字段并确保这个类已经导入。public class ChartController { @FXML public LineChart&lt;String, Double&gt; chart; private WebClientStockClient webClientStockClient;} 我们需要给stock-ui模块添加一个对stock-client模块的依赖。 （提示：我们可以通过在红色的字段上按下Alt+Enter，并选择”Add maven dependency”去让IntelliJ IDEA为我们添加这依赖。它会在Maven的 pom.xml文件添加依赖，所以这个依赖是由构建文件而不是IDE管理的）。&lt;dependency&gt; &lt;groupId&gt;com.mechanitis&lt;/groupId&gt; &lt;artifactId&gt;stock-client&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; Add a constructor parameter so it gets wired in. 添加到构造函数参数使之注入。 （提示：如果你在灰色的字段名按下Alt+Enter，IntelliJ IDEA会让你添加构造函数参数，或者我们可以生成构造函数）。public class ChartController { @FXML public LineChart&lt;String, Double&gt; chart; private WebClientStockClient webClientStockClient; public ChartController(WebClientStockClient webClientStockClient) { this.webClientStockClient = webClientStockClient; }}创建 WebClientStockClient beanIntelliJ IDEA 通过告知我们找不到类型为WebClientStockClient去帮助我们发现ChartController存在的问题。让我们修复它。 在stock-client模块，我们需要创建一个新的Java类，ClientConfiguration，并为其添加@Configuration注解。我们会在这里定义我们的Beans。 创建一个由@Bean注解的方法，并且返回值类型为WebClientStockClient. 为了创建一个这样的东西，我们需要传入一个webClient参数。 （提示：我们可以通过在红色的webClient变量上按下Alt+Enter并选择”create parameter”去让IntelliJ IDEA为这个传进一个参数）。 定义另一个@Bean方法，这个返回值类型为WebClient。我们可以使用WebClient Builder默认设置去创建一个新的实例。 我们也可以用@ConditionalOnMissingBean去注解这个方法，表示仅当不存在WebClient实例时才去创建Bean。我们在这里使用它，因为其它用到这部分代码的地方可能也创建了WebClient。@Configurationpublic class ClientConfiguration { @Bean public WebClientStockClient webClientStockClient(WebClient webClient) { return new WebClientStockClient(webClient); } @Bean @ConditionalOnMissingBean public WebClient webClient() { return WebClient.builder().build(); }}启用自动装配回到stock-ui模块，IntelliJ IDEA告知我们还找不到这个Bean因为它是定义在不同的模块里并且这个模块不能看到定义在那里的Bean。我们要使用Spring Boot 的自动装配来帮助解决这个问题。 在stock-client的src/main/resources里创建一个META-INF目录。 在里边创建一个名为spring.factories的文件。 在spring.properties，将EnableAutoConfiguration属性的值指向我们的ClientConfiguration类，这能够让其它使用这个模块的模块能够访问到定义在ClientConfiguration里面的Bean。org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.mechanitis.demo.stockclient.ClientConfiguration现在当我们回到ChartController类，它知道去哪里找webClientStockClient Bean了。总结这是本教程的一个小步骤，但这一步让我们可以创建可以被不同的Spring Boot应用程序重用的模块。现在这一步完成了，我们可以ChartController里面的客户端连接到价格服务，并开始在折线图上实时地显示价格数据。全部代码在 GitHub：https://github.com/zwt-io/rsb/" }, { "title": "响应式Spring Boot系列教程4", "url": "/2020/01/09/reactive-spring-boot-part4-a-javafx-line-chart/", "categories": "", "tags": "JavaFX, Tutorial, Spring Boot, Reactive, 教程, 翻译", "date": "2020-01-09 09:15:00 +0800", "snippet": " 原文由 Trisha Gee 在当地时间2019年11月18日发布在 INTELLIJ IDEA BLOG在这一步，我们会看一下如何创建个一JavaFX应用程序显示一个折线图。这个应用程序会用到Spring的特性，类如控制反转。创建一个 Scene 打开在第2步中创建的stock-client工程，回到在第3步创建的stock-ui模块。 打开StageInitializer，我们要更新这个用于显示应用程序的用户界面。 在onApplicationEvent方法里，调用stage.setScene()，并给它传入一个父级元素（当前未定义），并将宽与高分别设为800×600。public void onApplicationEvent(StageReadyEvent event) { Stage stage = event.getStage(); stage.setScene(new Scene(parent, 800, 600));}（注意：这些代码目前未能通过编译） 创建一个类型为Parent的局部变量parent。 （提示：如果你在红色的parent字上按下Alt+Enter并选择”Create local variable” IntelliJ IDEA 创建一个变量，并直到它需要是Parent类型） 在stage初始化之后调用stage.show()。public void onApplicationEvent(StageReadyEvent event) { Parent parent; Stage stage = event.getStage(); stage.setScene(new Scene(parent, 800, 600)); stage.show();}现在我们要明确这个父级元素是来自哪里的。使用 FXML我们要使用FXML定义用户界面上需要哪些元素。在FXML上定义视图元素使得视图与模型以及控制器之间清晰地分离开（如果我们遵循MVC模式的话）。 在onApplicationEvent方法中定义一个FXMLLoader类型的局部变量。public void onApplicationEvent(StageReadyEvent event) { FXMLLoader fxmlLoader; Parent parent; // ...其它方法}我们尚未定义FXML相关类的依赖，然我们添加一个Maven依赖。 在我们的pom.xml文件，我们要添加一个javafx-fxml依赖。 （提示：在编辑器里边红色的FXMLLoader红色字按下Alt+Enter会给我们一个”Add Maven Dependency”选项）。 添加org.openjfx:javafx-fxml依赖，版本为13。&lt;dependency&gt; &lt;groupId&gt;org.openjfx&lt;/groupId&gt; &lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt; &lt;version&gt;13&lt;/version&gt;&lt;/dependency&gt; 现在在StageInitializer里面导入FXMLLoader类。 （提示：在编辑器的红色FXMLLoder文字上按下Alt+Enter 会有 “Import class”选项，或者IntelliJ IDEA可以不加提示地完成这操作如果设置了自动导入的方式）。 在StageInitializer中创建一个chartResource字段，它的类型将会是Spring的Resource。 我们可以使用@Value注解去告诉Spring在哪里找到文件，让我们说它在类路径上并且是一个名为chart.fxml的文件。 在FXMLLoader的构造函数里，传入chartResource.getURL()。 这个getURL会抛出异常，所以让我们用try/catch块围起来。简单起见，在catch部分我们将会抛出一个新的 RuntimeException，但是生成环境这种处理异常的方式没什么用。 最后我们现在可以初始化我们的父级元素了，通过调用fxmlLoader.load()方法。import javafx.fxml.FXMLLoader;import javafx.scene.*;import javafx.stage.Stage;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.ApplicationListener;import org.springframework.core.io.Resource;import org.springframework.stereotype.Component;import java.io.IOException; @Componentpublic class StageInitializer implements ApplicationListener&lt;StageReadyEvent&gt; { @Value(\"classpath:/chart.fxml\") private Resource chartResource; @Override public void onApplicationEvent(StageReadyEvent event) { try { FXMLLoader fxmlLoader = new FXMLLoader(chartResource.getURL()); Parent parent = fxmlLoader.load(); Stage stage = event.getStage(); stage.setScene(new Scene(parent, 800, 600)); stage.show(); } catch (IOException e) { throw new RuntimeException(e); } }}创建 FXML 文件 去到resource目录(src/main/resources)并创建一个新的FXML文件。 （提示：如果你使用 IntelliJ IDEA创建一个 “new FXML file” 你会得到一个基础的FXML文件）。 顶层元素应该是一个VBox，如果文件是由IntelliJ IDEA创建的，我们需要将它由AnchorPane改为VBox 确保VBox有一个fx:controller属性，其值为ChartController。 （提示：IntelliJ IDEA即使在FXML文件内也可以代码生成，所以我们可以在ChartController文字的末尾按下Alt+Enter并选择”Create class”）。 （在与其它类相同的包里创建一个ChartController类。确保fx:controller指向的路径包含了完整的报名）。 我们可以使用Optimize Imports去移除FXML文件内不必要的导入。&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;?import javafx.scene.layout.VBox?&gt;&lt;VBox xmlns=\"http://javafx.com/javafx\" xmlns:fx=\"http://javafx.com/fxml\" fx:controller=\"ChartController\"&gt; &lt;/VBox&gt;回到SpringBootApplication类使用Ctrl+Shift+F10（Windows）或Ctrl+Shift+R（macOS）运行这个应用程序。一个Java窗口应该会弹出来，宽高是我们在Stage设置的那样。这里还没有什么，因为我们还未放东西上去。设置应用程序的标题我们要做一些小改动，看我们是否能够控制在窗口显示的内容。 回到StageInitialzer，并添加一行去将视图的标题设为applicationTitle。 为applicationTitle创建一个String类型的字段。 （提示：我们可以让IntelliJ IDEA创建一个构造函数以适当的参数去初始化这个字段）。 添加一个构造函数参数以填充这个字段意味着我们可以使用Spring去填充这个标题的值。 我们使用@Value注解为这个参数设置默认的值。public class StageInitializer implements ApplicationListener&lt;StageReadyEvent&gt; { @Value(\"classpath:/chart.fxml\") private Resource chartResource; private String applicationTitle; public StageInitializer(@Value(\"Demo title\") String applicationTitle) { this.applicationTitle = applicationTitle; } public void onApplicationEvent(StageReadyEvent event) { try { FXMLLoader fxmlLoader = new FXMLLoader(chartResource.getURL()); Parent parent = fxmlLoader.load(); Stage stage = event.getStage(); stage.setScene(new Scene(parent, 800, 600)); stage.setTitle(applicationTitle); stage.show(); } catch (IOException e) { throw new RuntimeException(); } }}当我们重新运行应用程序的时候，我们应该看到JavaFX在标题栏中使用这个新的标题。设置从applicatio.properties读取应用程序标题硬编码字符串怎么说都是不好的，所以让我们从其它地方获取这个标题的值。 在 src/main/resources/application.properties，添加一个新的属性值spring.application.ui.title并设置一个值用于标题文字。spring.application.ui.title=Stock Prices 在StageInitializer，我们可以使用SpEL去表面我们想使用这个属性值作为我们的应用程序的标题。将应用程序标题的@Value改为指向这个属性。public StageInitializer(@Value(\"${spring.application.ui.title}\") String applicationTitle) { this.applicationTitle = applicationTitle;}现在当我们运行这个应用程序（例如通过按两下Ctrl运行任何东西），我们应该能看到窗口标题使用了从这个应用程序属性获得的值。从 Spring 获取 JavaFX 控制器为充分利用Spring的特性，我们还有最后一件事需要做，这就是让 JavaFX从Spring的应用程序上下文中获取 Beans。 在我们的fxmlLoader上调用setControllerFactory。我们需要给它一个Lambda expression说明，给定一个类，返回一个对象。 创建一个类型为ApplicationContext的字段applicationContext。 为这个添加新的构造函数参数，以便将其初始化。 （提示：如果你在尚未初始化的一个字段上按下Alt+Enter，IntelliJ IDEA会提供选项让你为构造函数添加参数）。 现在我们可以在setControllerFactory Lambda 表达式的参数中applicationContext调用getBean方法为JavaFX提供所需的控制器）。// ...start of class happens above this line private ApplicationContext applicationContext; public StageInitializer(@Value(\"${spring.application.ui.title}\") String applicationTitle, ApplicationContext applicationContext) { this.applicationTitle = applicationTitle; this.applicationContext = applicationContext; } @Override public void onApplicationEvent(StageReadyEvent event) { try { FXMLLoader fxmlLoader = new FXMLLoader(chartResource.getURL()); fxmlLoader.setControllerFactory(aClass -&gt; applicationContext.getBean(aClass));// ...rest of the class创建一个折线图现在我们整合好了，最后让我们创建折线图。 在chart.fxml里面，在VBox内，我们想要一个LineChart。 我们需要添加一个子元素，一个xAxisx轴。 在xAixs内，添加一个CategoryAxis这意味着x轴会有字符串类型的值。这是我们的时间轴，所以给它一个 “Time”标签。 在与xAixs同一级，添加一个yAxis。 在yAxis内，声明一个NumberAxis。 这个轴是用于股票价格，所以为它添加一个 “Price”标签。 通过将LineChart的prefHeight属性设为600，设置了图表的高度为600。 我们需要给这个LineChart一个fx:id，这就是ChartController里面的字段ID，会包含对这个LineChart 的一个引用，让我们将它命名为 “chart”。&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;?import javafx.scene.layout.VBox?&gt;&lt;?import javafx.scene.chart.LineChart?&gt;&lt;?import javafx.scene.chart.CategoryAxis?&gt;&lt;?import javafx.scene.chart.NumberAxis?&gt;&lt;VBox xmlns=\"http://javafx.com/javafx\" xmlns:fx=\"http://javafx.com/fxml\" fx:controller=\"com.mechanitis.demo.stockui.ChartController\"&gt; &lt;LineChart prefHeight=\"600\" fx:id=\"chart\"&gt; &lt;xAxis&gt; &lt;CategoryAxis label=\"Time\"/&gt; &lt;/xAxis&gt; &lt;yAxis&gt; &lt;NumberAxis label=\"Price\"/&gt; &lt;/yAxis&gt; &lt;/LineChart&gt;&lt;/VBox&gt; （提示：IntelliJ IDEA 可以识别到在控制器类里面没有chart字段。在fx:id的值 “chart”上按下Alt+Enter并选择 “Create field ‘chart’“，然后IDE会在ChartController内生成正确的字段）。 ChartController应该有一个类型为LineChart的字段称为chart。我们说这个图表有一个String类型的x轴和一个Number类型的y轴，所以我们可以将它定义为LineChart&lt;String, Double&gt;。 我们为它添加一个@FXML注解，表示这个字段由FXML填充。 确保ChartController被注解为Spring的@Component。import javafx.fxml.FXML;import javafx.scene.chart.LineChart;import org.springframework.stereotype.Component; @Componentpublic class ChartController { @FXML public LineChart&lt;String, Double&gt; chart;}现在当我们运行应用程序，我们应该窗口中显示一个折线图的轮廓，带有显示数值的价格y轴，和显示时间的x轴。我们已经成功的创建了一个集成到Spring Boot的JavaFX应用程序，它可以用FXML定义视图呈现什么内容。在接下来的教程，我们会让这个图实时更新股票价格数据。全部代码在 GitHub：https://github.com/zwt-io/rsb/" }, { "title": "响应式Spring Boot系列教程3", "url": "/2020/01/09/reactive-spring-boot-part3-a-javafx-spring-boot-application/", "categories": "", "tags": "JavaFX, Tutorial, Spring Boot, Reactive, 教程, 翻译", "date": "2020-01-09 08:15:00 +0800", "snippet": " 原文由 Trisha Gee 在当地时间2019年11月11日发布在 INTELLIJ IDEA BLOG这是第三步，演示如何创建一个 响应式应用程序，使用Spring Boot, Kotlin，Java和JavaFX。这个第三步演示如何创建一个由Spring Boot启动并管理的JavaFX应用程序，因此我们可以在JavaFX应用程序中使用Spring的特性，例如控制反转。本文也有配套的视频。设置好模块在这一节，我重用前面步骤创建的客户端，并为它添加一个新模块。但是如果我们想将这个作为一个独立的工程，我们可以创建一个新的工程而不是新模块，步骤是非常相似的（替换new module为new project)。 打开前面步骤创建的stock-client工程后，创建一个新的模块。 这会是一个Spring Boot应用程序，所以在左边选择Spring Initializr。 在本教程我们使用Java 13作为SDK，虽然我们并没有后使用任何Java 13特有的特性。 为工程填入groupId，和artifact名为stock-ui。 保持Maven工程默认的Java和jar打包选项。 我们选择Java 11作为Java版本，因为这是最近的长期支持版，但是对于本工程而已，这没有区别。 为模块输入一个有用的描述，这是我们的第三个模块，这有助于我们清楚每个模块的作用。 如有需要也可以改变默认的包结构。 在这个模块，我们不需要选择任何Spring Boot Starter。 保持默认的模块名和位置。IntelliJ IDEA从Spring Initializr下载工程并将IDE设置好。如果有提示选择 “show run configuration in services” 我们可以选择它。 那个services窗口对于查看正在运行的服务和管理微服务应用比较有用。Spring Boot应用程序类跟往常一样，Spring Boot为我们生成默认的应用程序类。我们需要更改一下以便启动一个JavaFX应用程序，但现在我们先留着它这样子。import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class StockUiApplication { public static void main(String[] args) { SpringApplication.run(StockUiApplication.class, args); }}更新Spring Boot设置因为这是一个JavaFX应用程序，不是一个Web应用程序。所以在这个模块的application.properties里添加：spring.main.web-application-type=none创建一个 JavaFX 应用程序类 在与Spring应用程序类同一个包里创建一个新的Java类，命名为ChartApplicaion。 （提示：在project窗口，Windows/Linux用户可以使用Alt+Insert（macOS用户是⌘N) 创建一个新文件或目录）。 让它继承于javafx.application.Application。这个类目前不在类路径上，因为我们还未添加JavaFX到依赖里，所以我们需要将它添加到pom.xml 文件。 （提示：在红色的Application 文字上按下Alt+Enter 会有”Add Maven Dependency”选项。 将org.openjfx:javafx-graphics添加为依赖，版本是 13。&lt;dependency&gt;\t&lt;groupId&gt;org.openjfx&lt;/groupId&gt; &lt;artifactId&gt;javafx-graphics&lt;/artifactId&gt; &lt;version&gt;13&lt;/version&gt;&lt;/dependency&gt; 现在可以在ChartApplication导入javafx.application.Application。 Application是一个抽象类，所以我们需要重写一个方法。 （提示：在红色的错误上按下Alt+Enter并选择”Implement methods”，选择要实现的方法，可以让InteliJ IDEA去帮我们实现这些方法。）。 只有一个start方法是必须实现的。import javafx.application.Application;import javafx.stage.Stage; public class ChartApplication extends Application { @Override public void start(Stage stage) { }}设置好 Spring Boot 应用程序类现在我们有了一个 JavaFX 应用程序，我们需要从Spring Boot应用程序里面启动它。不使用SpringApplication启动应用，我们将使用JavaFX的Application类，并以我们的JavaFX类作为参数调用launch方法。import javafx.application.Application;import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplicationpublic class StockUiApplication { public static void main(String[] args) { Application.launch(ChartApplication.class, args); }}我们要分离出两个应用程序类的原因跟JavaFX以及Java的模块化机制有关，这些细节已经超出了本教程的讨论范围。如果我们想要整合Spring和JavaFX但不使用Java 9的模块，这是一种做法。通过应用程序上下文发布事件让我们回到我们的JavaFX应用程序类，ChartApplication。 创建一个字段applicationContext，这会是ConfigurableApplicationContext类型。 我们的start方法是一个标准的JavaFX方法，它以Stage作为参数，但stage就绪时调用。我们可以使用Spring的通过应用程序上下文发布事件的模式去告诉何时Stage就绪。在start()方法内，以一个新的 StageReadyEvent作为参数去调用applicationContext.publishEvent()。 将stage传入到事件的构造函数。public class ChartApplication extends Application { private ConfigurableApplicationContext applicationContext; @Override public void start(Stage stage) { applicationContext.publishEvent(new StageReadyEvent(stage)); }}现在我们需要创建我们的StageReadyEvent。 简单起见将它创建为ChartApplication的一个内部类。以后总能再重构出来的。 （提示：在红色的StageReadyEvent按下Alt+Enter会有个选项”Create inner class StageReadyEvent”）。 在StageReadyEvent的构造函数，传入stage参数到super构造函数。 将这个内部类改为static且是包内可见，其它类将会监听这个事件。static class StageReadyEvent extends ApplicationEvent { public StageReadyEvent(Stage stage) { super(stage); }}创建应用程序上下文在Application类里面有些其它有用的方法我们可以重写利用一下。 重写init()方法。这是我们需要初始化应用程序上下文的地方。 （提示：你可以在一个类当中使用Ctrl+O选择要重写的超类方法）。 创建一个新的SpringApplicationBuilder，并传入一个我们的Spring Boot应用程序类，也就是 StockUiApplication。 运行run()以获取应用程序上下文，并赋值到applicationContext字段。@Overridepublic void init() { applicationContext = new SpringApplicationBuilder(StockUiApplication.class).run();}关闭应用程序上下文因为我们有一个init()方法，我们也应该有一些适当的拆卸或清理步骤。 重写Application类的stop方法。 在stop方法内，调用applicationContext.close()方法。 同时也在JavaFX程序结束处调用Platform.exit()。@Overridepublic void stop() { applicationContext.close(); Platform.exit();}现在我们有了Spring Boot应用程序类用来启动 JavaFX的Application类，即ChartApplication：import javafx.application.Application;import javafx.application.Platform;import javafx.stage.Stage;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.context.ApplicationEvent;import org.springframework.context.ConfigurableApplicationContext; public class ChartApplication extends Application { private ConfigurableApplicationContext applicationContext; @Override public void init() { applicationContext = new SpringApplicationBuilder(StockUiApplication.class).run(); } @Override public void start(Stage stage) { applicationContext.publishEvent(new StageReadyEvent(stage)); } @Override public void stop() { applicationContext.close(); Platform.exit(); } static class StageReadyEvent extends ApplicationEvent { public StageReadyEvent(Stage stage) { super(stage); } }}监听应用程序事件我们需要一些东西去监听我们所创建的StageReadyEvent。 当它就绪时这个会设置好我们的JavaFX Stage。 这个类应该用Spring的@Component注解。 这个类需要实现ApplicationListener接口，去监听我们的StageReadyEvent事件。 我们需要实现这个接口上的方法，即onApplicationEvent。 onApplicationEvent方法需要一个StageReadyEvent。 事件触发getStage被调用并将结果赋值到一个类型为Stage的局部变量。import com.mechanitis.demo.stockui.ChartApplication.StageReadyEvent;import javafx.stage.Stage;import org.springframework.context.ApplicationListener;import org.springframework.stereotype.Component; @Componentpublic class StageInitializer implements ApplicationListener&lt;StageReadyEvent&gt; { @Override public void onApplicationEvent(StageReadyEvent event) { Stage stage = event.getStage(); }}（注意：这些代码当前未能通过编译）这个方法不存在，所以我们需要创建这个StageReadyEvent。 （提示：我们可以在StageInitializer里面红色的getStage方法上按下Alt+Enter并选择”Create method getStage” 去让IntelliJ IDEA帮我们生成这个。 父类里面有个我们想要的方法，getSource这会返回一个对象，所以调用这个方法并将返回值。static class StageReadyEvent extends ApplicationEvent { public StageReadyEvent(Stage stage) { super(stage); } public Stage getStage() { return ((Stage) getSource()); }}我们知道source就是Stage类型，因为当我们将stage的构造函数参数传入到父类的构造函数时，它就变成了 source。最后步骤这个Stage已经准备就是可用于我们的用户界面。我们可以运行我们的StockUiApplication，然后看到它成功地作为一个Spring Boot应用程序启动了。同时它也启动了一个Java进程显示一个UI如果我们有创建的话。目前位置，我们已经成功地创建了一个由Spring管理并启动的JavaFX应用程序，并且允许我们方便地使用Spring应用程序的特性。全部代码在 GitHub" }, { "title": "响应式Spring Boot系列教程2", "url": "/2020/01/07/reactive-spring-boot-part2-a-rest-client-for-reactive-streams/", "categories": "", "tags": "Spring Boot, Reactive, 教程, 翻译", "date": "2020-01-07 09:18:00 +0800", "snippet": " 原文由 Trisha Gee 在当地时间2019年11月4日发布在 INTELLIJ IDEA BLOG这是第二步，演示如何创建一个 Java 客户端连接到一个发送一系列服务端发送事件的流。我们将使用测试驱动开发来进行开发客户端并进行测试。视频在 B 站本教程是一系列视频，概述了构建完整的Spring Boot的许多步骤，具有 Kotlin 服务后端，Java 客户端和 JavaFX 用户界面的应用程序。第二个视频将展示如何创建。一个响应式Spring Java客户端，连接到每秒流式传输股票价格的REST服务。创建客户端工程我们将为这客户端创建一个新工程，我们希望将客户端和服务器代码完全分开，因为它们应该完全独立运行的。 这个工程包含多个模块，所以开始的时候选择创建空工程。 将工程命名为 stock-client 按 Finish 默认情况下，当创建一个新的空 Project 时，IntelliJ IDEA显示 Project Structure 对话框的，Modules 部分。我们将在此处添加一个新模块，这将是一个 Spring Boot模块，因此我们选择左边的 Spring Initializr。 SDK我们使用 Java 13，但没有使用新的特性。 输入组和工件的详细信息，我们称此模块为stock-client。 我们将为模块填入一个有用的描述，以便清楚了解此代码的用途。 我们将保留默认使用Java创建Maven项目 选择Java 11作为版本，因为这是当前的长期支持版本。 我们可以选择更改默认的包结构。接下来选择所选的 Spring Boot Starter 使用Spring Boot 2.2.0 RC1 选择Spring Reactive Web Starter，然后也选择Lombok。 默认模块名称和位置没问题, 保留不变。IntelliJ IDEA 从 Spring Initializr 获取工程，并适当地设置IDE。选择 enable auto-import创建客户端类 删除Spring Initializr为我们创建的StockClientApplication，在这个模块我们不需要它，因为该模块将成为其他模块的库。 创建一个类WebClientStockClient。它将使用Spring的WebClient来，连接到股票价格服务。public class WebClientStockClient {}创建客户端的测试驱动客户端需求并验证可行性的方法之一是，是以测试驱动的方式进行开发。 Windows 或 Linux 使用 Ctrl+Shift+T (macOS 使用⇧⌘T ) 我们可以导航到某个类的测试。 在 WebClientStockClient 这个类还没有测试 所以让我们创建一个。 选择 JUnit 5 作为测试框架。 这实际上会是一个端到端测试，所以填入 WebClientStockClientIntegrationTest 作为类名。 用快捷键 Alt+Insert (⌘N) 生成测试的方法，在生成菜单中选择 “Test Method” 。 这不会是测试驱动开发的完美示例，因为我们只是创建一个只测试最佳情况的测试，有时称为快乐路径测试。将测试命名为像 shouldRetrieveStockPricesFromTheService 为测试创建一个 WebClientStockClient 实例class WebClientStockClientIntegrationTest { @Test void shouldRetrieveStockPricesFromTheService() { WebClientStockClient webClientStockClient = new WebClientStockClient(); }}我们可以通过测试驱动来做的其中之一，是按照我们想要的API进行编码，而不是测试我们已经创建的东西。IntelliJ IDEA 使得这样的操作更加容易，因为我们可以创建我们想要的测试，并为其生成代码，通常是使用 Alt + Enter 在测试代码中，在 WebClientStockClient 上调用 pricesFor 方法。 这个方法需要一个 String 类型的参数表示想要了解其价格股票的代码。void shouldRetrieveStockPricesFromTheService() { WebClientStockClient webClientStockClient = new WebClientStockClient(); webClientStockClient.pricesFor(\"SYMBOL\");}（注意：此代码当前未能通过编译）在客户端中创建一个基本的价格方法 （提示：在红色的 pricesFor 方法上按下 Alt + Enter 去让 IntelliJ IDEA 在 WebClientStockClient 里边创建这个方法，并有符合预期的签名。） 将 WebClientStockClient 里的方法返回值类改成 Flux&lt;StockPrice&gt; Flux 最简单地创建可编译、测试的方法是，让此方法返回空的Flux：public class WebClientStockClient { public Flux&lt;StockPrice&gt; pricesFor(String symbol) { return Flux.fromArray(new StockPrice[0]); }}（注意：此代码当前未能通过编译）创建一个类保存股票价格 （提示：最简单的方法是使用Alt + Enter让IntelliJ IDEA创建类） 在与 WebClientStockClient 的包里创建 StockPrice这就是我们要使用Lombok的地方，使用Lombok的@Data注解，我们可以创建类似于第一个视频中的Kotlin数据类。通过使用@Data注解，我们只需要使用字段定义该类的属性，getters,setters,equals,hashCode，以及toString方法均由Lombok提供。使用Lombok IntelliJ IDEA插件获得代码补全和其他有用的功能。 添加 String symbol，Double price 以及 LocalDateTime time 到 StockPrice 类。 通过Lombok添加@AllArgsConstructor和@NoArgsConstructor，这对于我们的代码是必需的 并用于JSON序列化。 @Data@AllArgsConstructor@NoArgsConstructorpublic class StockPrice { private String symbol; private Double price; private LocalDateTime time;}为测试添加断言我们回到 WebClientStockClientIntegrationTest 并添加一些断言， 我们需要检查Flux&lt;StockPrice&gt;是否符合预期。 将返回的 Flux 保存到 prices 局部变量。 添加此为非空的断言。 添加一个断言，如果如果我们从Flux中取出五个价格，我们不止得到一个价格。@Testvoid shouldRetrieveStockPricesFromTheService() { // given WebClientStockClient webClientStockClient = new WebClientStockClient(webClient); // when Flux&lt;StockPrice&gt; prices = webClientStockClient.pricesFor(\"SYMBOL\"); // then Assertions.assertNotNull(prices); Assertions.assertTrue(prices.take(5).count().block() &gt; 0);}当我们运行此测试时，我们看到它失败了，它失败是因为Flux中包含零个元素，因为这是我们硬编码的内容。将客户端连接到真实的服务让我们回到 WebClientStockClient 并写入实现。 我们要使用WebClient去连接服务。我们将其创建为一个字段，并添加为构造函数参数，以便Spring自动注入。public class WebClientStockClient { private WebClient webClient; public WebClientStockClient(WebClient webClient) { this.webClient = webClient; }// ...rest of the class here现在我们想要使用 WebClient 在我们的方法中调用 REST 服务。 移除来自priceFor方法中的桩代码（即删除 return Flux.fromArray(new StockPrice[0]);） 我们使用WebClient发出 GET 请求 (get()). 传入服务的 URI (http://localhost:8080/stocks/{symbol}) 并传入股票代码（symbol） 调用 retrieve(). 我们要指定如何将这个调用的响应转换为某种类型的 Flux，使用bodyToFlux并将数据类 StockPrice.class 作为参数。public Flux&lt;StockPrice&gt; pricesFor(String symbol) { return webClient.get() .uri(\"http://localhost:8080/stocks/{symbol}\", symbol) .retrieve() .bodyToFlux(StockPrice.class);}这些是要获得来自GET调用的响应流的最基本的要求，但我们还可以定义诸如retry和backoff策略，请记住了解从发布者到消费者的数据流，是创建成功的响应式应用程序的重要部分。我们还可以定义抛出特定异常时的处理方式。例如，我们可以说 当我们看到IOException时 我们想记录它。 我们将使用Lombok的Log4j2注解，使我们能够访问日志并记录错误。这不是处理错误的最可靠的方式，这只是表明我们可以认为异常在响应流中是数据。import lombok.extern.log4j.Log4j2;import org.springframework.web.reactive.function.client.WebClient;import reactor.core.publisher.Flux; import java.io.IOException;import java.time.Duration; @Log4j2public class WebClientStockClient { private WebClient webClient; public WebClientStockClient(WebClient webClient) { this.webClient = webClient; } public Flux&lt;StockPrice&gt; pricesFor(String symbol) { return webClient.get() .uri(\"http://localhost:8080/stocks/{symbol}\", symbol) .retrieve() .bodyToFlux(StockPrice.class) .retryBackoff(5, Duration.ofSeconds(1), Duration.ofSeconds(20)) .doOnError(IOException.class, e -&gt; log.error(e.getMessage())); }}运行集成测试回到 WebClientStockClientIntegrationTest，可以看到有些需要修复的东西。 我们现在需要给客户端一个 WebClient， 在测试中将其创建为字段。 （使用智能补全 Ctrl+Shift+空格， IntelliJ IDEA 甚至可以建议创建 WebClient 实例的完整语句）class WebClientStockClientIntegrationTest { private WebClient webClient = WebClient.builder().build(); @Test void shouldRetrieveStockPricesFromTheService() { WebClientStockClient webClientStockClient = new WebClientStockClient(webClient); // ...其余代码 为了进行集成测试，REST 服务必须要运行。回到上一个期创建的 StockServiceApplication 并运行起来。 运行 WebClientStockClientIntegrationTest。 你可以用边栏上的图标或使用快捷键 Ctrl+Shift+F10 (macOS 快捷键是 ⌃⇧R ) ，或者双击 Ctrl (“run anything”) 然后输入测试的名称。现在我们应该可以看到测试为绿色通过。如果我们看一下输出，可以看到我们正在解码带有符号的 StockPrice 对象，随机价格和时间。更多关于在集成测试中使用断言这不是最彻底的测试，所以让我们为的断言添加更多细节，以确保客户端符合我们预期。让我们更改断言为要获取五个价格时要求有五个价格，并确保某股票价格的代号是我们所期望的。import org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.Test;import org.springframework.web.reactive.function.client.WebClient;import reactor.core.publisher.Flux; class WebClientStockClientIntegrationTest { private WebClient webClient = WebClient.builder().build(); @Test void shouldRetrieveStockPricesFromTheService() { // given WebClientStockClient webClientStockClient = new WebClientStockClient(webClient); // when Flux&lt;StockPrice&gt; prices = webClientStockClient.pricesFor(\"SYMBOL\"); // then Assertions.assertNotNull(prices); Flux&lt;StockPrice&gt; fivePrices = prices.take(5); Assertions.assertEquals(5, fivePrices.count().block()); Assertions.assertEquals(\"SYMBOL\", fivePrices.blockFirst().getSymbol()); }}总结测试响应式应用程序是一项技能，而且还有比我们所展示的更好的方法。但是，我们已经成功地使用了集成测试来驱动股票价格客户端的API和功能，该客户端连接到发出服务器发送事件，并返回Flux&lt;StockPrice&gt;对象可被其他服务消费的端点。在本教程的后续视频中，我们将展示如何执行此操作。全部代码在 GitHub" }, { "title": "响应式Spring Boot系列教程", "url": "/2020/01/06/reactivce-spring-boot-tutorial/", "categories": "", "tags": "Reactive, Spring Boot", "date": "2020-01-06 07:38:00 +0800", "snippet": " 这篇文章起源于当时我看的一个 Spring 官方技术大会的演讲，也就是由 Trisha Gee 在 2019 年 10 月的 SpringOne Platform 分享的 Fully Reactive: Spring, Kotlin &amp; JavaFX Playing Together。这个演讲整合了 Spring、Kotlin 还有 JavaFX 等技术，感觉挺好玩的。当时就想搬运演讲的视频，并配上中文字幕。不过后来发现作者将内容分成了相对独立的步骤，配上文字版的文章描述和重新录制了精简版视频。因为她觉得这样分开会比较容易学习和吸收，所以我就翻译这些吧。 原版是在现场演示的，录播视频时长 1:08:28. 现场版就比较生动吧，有血有肉的，有开场白，也开玩笑活跃气氛。现场写代码，有时候出错，展示了调试的思路，与观众有互动。后面重新整理的录屏版就比较言简意赅，也不会有出错和调试的情节，节省读者时间。教程分成 10个部分，并配有讲解视频，链接如下： Kotlin REST服务 ✔ Java REST客户端 ✔ JavaFX Spring Boot应用程序 ✔ JavaFX折线图 ✔ 共享Bean的自动装配 ✔ 显示响应式数据 ✔ 订阅多个消费者 ✔ Kotlin RSocket服务器 ✔ Java RSocket客户端 ✔ 用Spring Profiles切换客户端 ✔本系列视频课程的播放列表代码在 GitHub" }, { "title": "响应式变革 Reactive Evolution 第 2 部分", "url": "/2019/12/03/reactive-evolution-part2/", "categories": "", "tags": "Reactive Programming, 响应式编程, Spring WebFlux, Spring Cloud Gateway, RSocket, R2DBC, Kotlin", "date": "2019-12-03 05:13:00 +0800", "snippet": "响应式变革第 2 部分——构造边缘服务客户端第二节开场现在 我们已经构建了一个服务是一个 HTTP API 额…… 我们演示了 WebSocket 我们演示了 响应式 NoSQL 和 SQL 数据访问 在 Spring Data 的世界里 我们全部用 Java 写的加点 JavaScript 对吧 那有点 额…… 你懂得 总会遇到 JavaScript 的对吧？就如谚语所说那样。额 然后 现在 是时候将我们的注意力转到 构建客户端 构建一个东西 我们可以用来 额 与那个服务进行通信 去构建边缘服务 而边缘服务是在逻辑上在架构的边缘的东西 首个来自外界请求的端口。会被适配到对下游微服务的请求，而边缘服务是逻辑上我们处理，一些边界关键问题。例如 负载均衡路由 还有安全之类的。所以我们要在这里做 在这个边缘服务里做，额 我们要构建一个 像往常一样。通过到 start.spring.io OK? 所以我们开始，啊 现在。我们要构建一个应用，你知道吗 顺便说一下 有点失望。之前从 10 月 31 日开始。那时候是万圣节前夜。从 10 月 31 日开始，这是万圣节前夜风格的。那很酷啊，现在变回暗色模式也很好 你懂的。但 当时这里有个南瓜和鬼怪的，随意啦 没关系。开始写代码 KotlinOK 我们要构建一个应用基于 Kotlin 的 我们要构建一个 reservation-client OK? 就是这样很好 我们要在这边选择 正确的东西当然选择 Java 13 然后我们有一些需要的依赖 我们需要响应式 Web 支持我们需要 RSocket 额 我们需要 Spring Cloud Gateway 我们需要 响应式 Redis 支持 我们需要 Spring Security 支持 然后我觉得我对我目前的选择满意了。所以我要点击 Generate 当我确认我已经有了我所需要的 是的 齐了 好 所以我要构建一个应用现在 这是一个 zip 文件可以打开的像往常一样 这是我们的 IDE UAO 喔 这是什么东西让我们看一下 我们不需要那个这个也不要 这也不需要 OK？ reservation… 好 我给自己拿了两杯咖啡 只是以防万一 好东西 跑起来吧 好这是基于 Kotlin 的应用程序 你们有多少人使用 Kotlin OK 实际上很不错啊 手先别放下 让我看看 哇…… 那很好啊那大概有 三分之一 或者 四分之一 我觉得惊讶 这很让人惊奇 这很酷 好东西 所以 Kotlin 是一种好的编程语言 构建在 JVM 之上你懂得 编译到字节码 有互操作性 跟其它的各种库之类的东西 使得它如此吸引人 目前 Kotlin 最大的用户是安卓用户 那是有很好的原因的 Android 很难有现代版本的 Java Java 8 怎么讲都不 跟它们相关 对吧 你不能保证你在安卓写的代码 可以编程成 Java 8 因为很多人没有与 Java 8 兼容的运行时 所以你要编写代码编译到 Java 7 之类的或者目标是 Java 7 这可能有点让人失望 因为我们现在用的是 Java 13 对吧 版本号差不多是两倍了 然而我们还不能在安卓用户端使用它 所以 Kotlin 是非常不错的 它可以编译到更加老的版本 同时仍使用一种语言 用起来更像 Java 20 的感觉相比较于 Java 7 对吧 额…… 额 我意思我喜欢 Java 的 很显然啦 但是 那只是 按照定义来讲它并没有那么有趣、前沿对吧 额…… 所以 Kotlin 非常不错的语言 在 Kotlin 有些东西你要理解的 首先 函数是由 fun 开头的 函数名紧随其后 所有在 Kotlin 当中你可能称为方法的其实都只是函数 如果它们在一个类里边 我说它们是成员函数如果在一个类之外 它们只是函数 它们只是顶层的东西 它们可以这样的 这是需要注意的我们这里有的是 一个空的类这是一个空的类 里边什么都没有 那里是同样的东西对吧 所以我有一个空的类 里边什么都没有这个函数不属于这个类它可以 那样的话 我就要这样做 对吧 但我不是要这样做我只是有一个顶层的类 一个顶层的函数 它们看起来是相互相邻的 额 在 Kotlin 里边 参数名称 放前边然后才是类型 对吧 额 有一种同一的语法给泛型参数的那就是 这是一个数组 String数组 相当于 String[] 对吧 OK 这基本上就是你需要理解的了讲一点 Kotlin 背景基础知识我们要做的是 我们要构建一个应用 那会访问一个 API 额…… 边缘服务 首先要做一些事情 我要确保这个应用 在 9999 端口启动 我们要确保注释掉 那个…… 那个…… 安全相关的东西 因为那会锁住这个应用的 我们现在还不想这样 好吧 计算机 好？ 好 这样可以了 好吗 我要选择 Enable-Auto import 因为有时候要更改 classpath 我希望工具会跟上节奏 OK 现在我要创建一个类 它将会是 额 Java config 风格的端点 我将会创建一个 API 网关使用 Spring Cloud API Gateway 这是第一类 边缘服务 一个 API 网关是一种将外界请求 并处理它们 以一种通用的方式有点与载荷本身无关的那样 它基本不知道那是 JSON 还是 XML 也不怎么关心 它只是做一些通用的转换与载荷的语义无关与特定的载荷本身无关 所以我们要创建一个基于 Spring Cloud Gateway的网关 现在 Spring Cloud Gateway是构建在 Spring 响应式 Web 支持之上的 所以它本身就是响应式的了我要在这里创建一个 Java 配置风格的端点所以我在创建一个 额…… 我们过去称之为 Bean 配置方法的 现在是函数 我正在注入一个类型为 RouteLocatorBuilder 的参数 我要使用 RouteLocatorBuilder 去构建我的网关路由你做的方式是构建一个路由然后你构建（builder 模式） OK？ 现在 额…… 在 Java 的话看起来就像这样 显然 在 Java 你会有分号但在这里是可选的 可以有任意多个这样的route() 调用 每个路由对应着某些会进入到服务的东西的定义然后你想要拦截处理 然后转发到其它东西OK? 通常你有一个像这样的 Lambda 然后 Lambda 有一个 route 配置 或 规范然后使用路由的规范去定义 例如 当每个请求进入到 这个路径 称为 /proxy … and().host(… 这个主机 ……然后我想将它发送到这个 URL 所以 localhost …现在当然 我实际这样做不到 对吧？ 这会发生什么？ 首先 嗯…… 我需要返回一个 RouteLocator …RouterLocator… 那就是返回值 那就是它抱怨的 额 首先将要发生的是 我想要匹配 /proxy 然后我想匹配这个主机名 当然如果路径是 /proxy 那么 如果我转发到这个不作任何地更改那会变成 /reservations/proxy 那不是我想要的 所以我需要 去过滤、我要按某种方式处理一下 所以这里我们有 filter 回调 我们写…… 然后赋予一个 lambda 我们可以使用 filterSpec… 然后写…… 这将会作为一个代理 这些过滤器是这里真正的力量 它赋予你能力做各种事情 想象一下 你有一个 HTTP (不好意思口误）HTML 5 客户端然后那个 HTML5 客户端 想要调用下游的服务 额 为了让那成为可能 你要确保你支持 CORS 跨域请求脚本 对吧而为了那样做 你要写我想要添加一个首部 HttpHeaders. 噢 不是这个 你可以看到不少人也想到了这个 对吧 HttpHeaders我们要允许 ACESS_CONTROL_ALLOW_ORIGIN ALLOW_ORIGIN 我想要说 允许所有东西 OK？嗯 所以那是 让我们去掉另一个使得这不必要地长 OK 拜拜 然后这个 OK？ 好 这就是这些代码 让我们看一下如果运行会怎样 正在编译 curl 减号 额不好意思 http://locahost:9999/proxy 这样当然是不行的 额 噢~ 不是这个 security.rsocket #%……￥%@#哼？ 这是什么鬼 我这辈子都没见过这个 说真的 这真有趣 这就是追求新技术的馈赠 OK 我们有这个让我们注释掉它 我以为我已经注释掉安全相关的依赖了 不是吗 我觉得我已经注释掉了 maven reimport… 别 那是什么？ …rsocket.core? 哇 看起来我们的确遇到些问题了 但我们可以 有可能解决它 让我们看一下 噢这个 spring-security-rsocket 没人想要这东西 我没要这个 OK 这次好了 这是新的 OK 好 那么 它们想帮忙的 因为我最初勾选了RSocket它引入了其它东西 然后我勾选了 Security 它将这两样都引入了 但这两样我不是全都要 OK 现在它显示它找不到端点 对吧 404 所以现在 我指定一个主机断言 -H”host.devoxx.spring.io” OK 然后 那…… 失败了 额 9999-H … devoxx.spring.io 连接被拒绝…… 噢 因为我的服务（未运行） OK 它正在代理请求到这边这个东西 我的 ReservationService 那东西还没有运行 OK 让我们重启它 然后这些就是请求 如果我美化输出到 JSON…. json_ppOK 就是这样 这是我们的数据 OK 所以我们代理转发了数据 我们也可以看更加详尽的输出 去掉那个 我们可以看到我们这样做 它添加 Access-Control-Allow-Origin 首部到响应所以现在任何 JavaScript 客户端 可以连接到我的边缘服务 而那会允许它们获取到数据 它会响应式不阻塞地转发请求 那不会等待完整的响应 它会流式传输数据当可用的时候 它会从下游的微服务获取到数据 在这个例子中就是 localhost:8080/reservations 然后它会发送回到给我们的客户端 OK？ 所以现在 让我们再回顾一下这代码 既然我们 已经让应用程序的基本骨架可以跑起来了 这个是在 Kotlin 种非常像 Java 做法 OK ? 但有很多方面我们可以改善的 首先 我们有一个函数 创建了一个表达式那个我们之后返回了我们实际上没有 什么东西在中间 没有逻辑 没有状态 什么都没有 我们不 我们并没有从中获益 所以我们可以使用等号 在这个例子 我们实际上可以 做个赋值 基本上我们可以写 这个函数 = 这个表达式 所以如果你调用这个 它是等价于调用那个的 那样更好一点 另一个 Kotlin 做得很好的是 它有种很好的能力 如果一个函数最后的参数是个lambda 你可以将lambda写到函数的外边 所以在这个例子 我可以将它重写成这样 喔 这看起来有点傻 不是吗？现在我在那里什么都没有了 对吧 但功能上是一样的 所以在 Kotlin 你也可以去掉括号 对吧 那也是同样的东西额 这样好了一点 对吧？这边也一样 我可以修改这个 即使这些全都很不错 但是我们有这些不必要 有些…… lambda 的参数 对吧 这是一个路由的规范 但 这只是中间变量这些是我们创建了为了有个名字而已但我们并不需要这些名字因为我们直到 lambda 有它的参数 所以我们可以去掉这些变量名 然后我们可以用 it 引用it 是一个隐式地被创建的参数 对吧 如果你用过 groovy 你就知道这些东西了 对吧所以同样的东西 我可以在这做同样的东西 我可以写 it 对吧 当然 在这个例子 可能会有点疑惑因为变量范围的问题 这可能是你想要保留变量名的原因 OK 随你OK 我喜欢那样 看起来更好一点了 但甚至在这里 我们还可以做得更好 所以 其实 Kotlin 当中有个很好的特性或可以获得扩展函数 这些是在 JVM、JDK 还有在 classpath 上的代码里面 但它们被添加到已存在的类型所以你可以将类型粘起来 非常像 ruby 例如你可以给已存在的类添加东西 额 这意味着你可以像玩视频游戏你可以解锁一个秘密等级你的类路径上有这些库 那些通常是为 Java 用户准备的但它们表达了某些 API 功能某些能力到 Kotlin 而且只有通过使用 Kotlin 才可以使用它所以实际上 我们还可以再次重写一遍 routes 然后这是 DSL所以 RouteLocatorBuilder 是 Java API 是用 Java 写的 你可以看到代码 是 Java 对吧 不过 这里有个额外的函数 称为 routes 我们可以看到 是一个扩展函数 让我下载它 OK下载源代码吧 谁在下种子 随意吧 OK 这个函数 是定义在 RouteLocator 之上的并且它需要一个 RouteLocator 做参数 从这里之后它接收一个参数 那是一个 lambda 那 这很有趣 这个lambda语法没有参数 然后返回 Void Unit 相当于 Void 这个 lambda 也写作 也被定义做 额… 基于对上下文绑定的RouteLocator DSL引用的 所以基本上 在那个lambda 如果我调用 this. 我实际上调用的是 我是对着一个 RouteLocator 实例调用的 this. 我原来的 ‘this’ 已经被替换成这个 DSL 的 ‘this’ 这意味着我可以对着这个（方法）调用，我意思是类型 而实际不需要声明那个类型 我的 lambda 被插入到那个对象里 它的上下文 基本上是这样所以现在我可以重写这些 更加明确地 我可以说 route… 然后我要匹配一个路径为 /proxy 而且，顺便说一下，我可以这样做我们可以那样做 但我们也有额 中缀表示法 对吧 所以 …host… 我可以这样做 我写 “*.spring.io” 随意啦但因为这是中缀标记法我可以去掉所有这些 对吧 同样的东西 额……然后 我想要创建 filter 然后这个 filter 包括设置路径 对吧 “/reservations” 然后我想要添加响应首部 让我…… 复制这个 OK 跟之前的一样 然后是 uri 在这里 “http… “http://localhost:8080/” 好了 就这样 这就是整个东西 所以现在我可以重写 全部 我不需要 build 上下文会帮我完成的 就是作用范围它本身给予了我那个 对吧 然后就是这样 这就是全部的重写的 DSL 所以你得到像这样的类型安全的 看起来有点像 有点让我想起 以前的 Apache 配置文件 对吧 不同的是这是编译器的 而且是类型安全的对吧 这很不错。Kotlin DSL 配置 Spring Cloud Gateway​\t\t所以这跟刚才给你展示的东西基本上是一样的，为了证明 让我们重启一下应用。我喝点咖啡 我觉得我值得这样做OK？那么，看吧 这就是我们的数据。所以这就是跑起来了的应用，现在，那个过滤器，就是魔法的所作。是力量所在。我可以做各种有趣的事情，我可以修改首部 我可以修改请求 URI，我可以修改请求体、响应体，我可以保存。或者是移除首部 例如 host 首部，我可以做重定向、可以做重试，我可以做重写 URL 重写。一些你可能会用 NGINX 或 mod_rewrite 做的事。你可以很容在这里做到，路径重写之类的东西，你可以在这里做，我可以设置响应的状态。我可以做各种事情。使用这些 filter 我最喜欢做的事情之一是当然是创建我自己的 filter 对吧？因为你可以完全掌控所以如果你想要创建你自己的 filter。做起来很简单 对吧 你可以 你可以看那是怎么做的嗯……另一样我最喜欢做的事是，考虑下限制访问速率，那么速率限制器是一个非常简单的东西。速率限制器是一种东西，当有一个请求进来的时候。查看进来的请求，基于你的规范的条件来验证。然后，选择保留还是拒绝那个请求，还有通常那个标准是。你所规定的一个计数 一个预算，你说，我允许，额…… 让我们假设 10 个记录 5 个请求，每秒十个请求。或5请求每秒 或者是 每秒百万个请求，不管是什么吧。对你来说可以接受就好，一个速率限制器，关注两个很常见的应用场景。第一种用例，是 嘿~ 我想要限制在全球范围的绝对请求次数，到 随意吧 n 个请求每秒 5 让我们只用 5 简单容易好算数 OK？所以假设我们想要限制每秒访问的绝对次数为5个请求，这意味着不管人们在哪里发起请求。也不管是一个客户端、机器人或者是人。什么都没关系，你只需限制每秒5个请求就好了。对于全球范围 OK？嗯…… 这是很常见的用例，如果，由于某种原因你有一个很昂贵的下游服务。那很难扩展起来的，例如 我想到的是大型机。对吧 某种大型机 你可以处理 x 个请求。x 个事务处理 x 个用户 但如果你再添加一个 你要买个新的大型机，对吧？这些东西还未开始用就已经要花几百万了,对吧? 如果可以的话没人想要扩展这些东西所以这非常有用 像说 嘿~ 我要将所有东西汇聚起来降低到这个小的 受限的速率 我要说 OK 这里只有 5 个请求只是简单的数学 我确信你可以处理比那更多的 对吧? 但是我只将它限制到每秒5个请求 对全球范围 不管是谁在发起请求 嗯……​\t\t这是一种应用场景 另一个应用场景是 我想要处理 我想每个用户 都是每秒只能发起5个请求 好吧 所以在这个案例你没有扩展起来的问题 很可能地 现在是 2019 年 快到 2020年了。你可以使用一个云平台 例如 CloudFoundry或者你可以用 Kubernetes 构建一些东西 额 随意什么东西吧 对吧？如果是这样的案例你想要限制对下游服务的调用 但你不想限制用户的绝对数量 通常你只是限制每个用户的请求数量 以确保每个人都参与公平的游戏 额 没有人 你懂得 滥用系统 并从中获益 你不希望有机器人对你的页面发送垃圾请求 或者是爬虫之类的 不管什么发现一种方式毁了系统对其它人的服务质量 所以速率限制器在这两方面都有用 嗯…… 速率限制器维持进入系统的请求的计数同时 它们与你所给的预算作比较 如果预算超了 它们拒绝请求 它们将请求发到别的地方去 所以我们有了速率限制器 嗯…… 一个追踪进入系统请求数的速率限制器 我们有一个边缘服务 我有一个边缘服务 一个速率限制器这个速率限制器 现在 让我们假设 我们想控制并限制每秒请求次数到 5 如果我创建另一个这样的边缘服务实例会怎样？如果我将这个边缘服务的 JVM 线程 并将其部署 然后我现在有两个实例在负载均衡器后面 当中每一个都可以配置成不可以超过每秒5个请求 那么现在 我变成可以每秒请求十次 不是吗？ 我所转发请求到的下游服务那个 reservation 服务 会看到十个请求每秒 因为我有两个节点 两个都允许每秒五个请求 这样不好 对吧 这就是将预算值写死在 Java 代码里的问题我们需要某种方式去追踪用户的数量 而且是保持追踪 独立地追踪某个特定的节点 我们需要一些东西是可见的 是一致的 能跨越所有的 JVM 访问 对吧 而且定义上来讲它必须要闪电般迅速 本质上 我们需要原子性的数字 然后是非常快的 可以运行在集群当中 而且那可以容易地接入到我们的应用 因此 我要放入额…… 该放在哪？Redis 对吧 就是它 我添加了 spring-boot-starter-data-redis-reactive OK？所以我们将要创建一个基于 Redis 的速率限制器。开始配置限流器 RateLimiter​\t\tK? re… 额 fun… 我会将它限制为5个请求每秒 然后我要冲破到 7 OK？OK 就是这样 嗯…… 现在为了让它能用。我需要配置速率限制器 所以我可以写 set… setRateLimiter 像这样子然后我只需调用 redisRateLimiter 但请记住 在 Kotlin 里边 就像现在的很多语言那样 例如 Groovy、Scala Ceylon 基本上其它东西 你可以只写 基于属性的访问它同样是这样调用 rateLimiter 这个 rateLimiter 它会查找速率 它会查找当前的计数 那个将会对我们调用的计数进行验证的 在 Redis 里边 嗯 什么是键值对存储啊 所以为了找到那个值 你要找到那个键 知道要用哪个键所以我们要给它一个 keyResolver 所以我们写 keyResolver… 然后我们可以插入 KeyResolver 嗯 这个 KeyResolver 有一个很简单的任务 返回一个数据流对吧 所以我可以写 你懂的 额 这是我的键 对吧？这是我们要在 Redis 里面使用的 key 这里有人看过《美丽人生》这电影吗？ La vita è bella 电影台词 没有吗？ 好吧 不管如何 这是这东西 嗯 额…… 所以 KeyResolver OK? 它返回 单个的数据流 这是首个应用场景我说 不管世上谁在发起请求 我不在乎你在哪里我不在乎 你在的地方是白天 而你在购物 然后那服务 应该会允许你 完全使用这系统 与此同时也有人在半夜使用这服务他们应该在睡觉的 我可以将他们的服务降级 因为这时候那各地区没有太多流量 你在这世上任何地方都无所谓因为我期望每秒不超过5个请求 就全球范围而言 OK？ 这就是一种应用场景 一个键 管理所有 OK ?限流器的基本需求​\t\t你可以那样做现在注意到作为参数我们有个请求 对吧 那个请求 是 it 我们可以只用 it 但它在那里 我们可以根据它验证一些东西我们可以说 嘿~给我 Principal 给我当前的 Java Security Principal 与这个请求相关的 对吧 所以 Principal 然后我想要将那个 Principal 然后我想 map 它一下 我要写 map… 所以它会给我 一个 publisherOfName 所以 Publisher Publisher&lt;String&gt; 的名字 等于这个 就是这样 好 这是我在这里创建的类额 我显示地指定类型 那样你们可以看到 但你们不必要这样做 你也可以这样写 好吗？ 同样的东西这是我的数据流的名称 我可以返回那个啦 我可以只是写 return… publisherOfName 对吧 让我们这样做吧 OK? 额…… 在 Kotlin 当中 顺便提一句 最后一行 在一个函数里面 或是 lambda 在这个例子 是那个被返回的对象 所以其实这也能用所以实际是我在这里返回 我这里获取到了名称 不过如果没有名称会怎样？ 如果这里没有 Principal 会怎样？在当前的请求里 那么…… 我们需要 .switchIfEmpty(… 所以我们写 Mono.empty()… OK? 现在返回一个数据流的名称如果存在的话 在请求当中 然后我们会讲那个 Principal 从哪里来 我稍后再讲 给我几分钟 不过 如果那不存在的话 那么我们希望返回 …empty()… 这是非常寻常的策略 我刚才所作的是 我创建了一个 keyResolver 那会基于当前用户返回当前的 key 如果 jlong 是已经认证了的 已登陆到系统的 那么 我会得到那个响应 我会获得那个 key 名称是 jlong我可以运用那个 KeyResolver 这是如此常见的策略 如此容易写 因为太常用 实际上 我们会有个 PrincipalNameKeyResolver 好吗？ 就是这些东西 好东西 实际上它太常用了 所以它是默认的 所以我们会变回这样。默认的 PrincipalNameKeyResolver​\t\t好吗？那么，这是我们的速率限制器。现在让我们谈一下安全然后 这边就是事情变得有点有趣的时候了安全是非常重要的很显然啦额 还有这并不是带来希望的消息如果你因其中一方而离开这个讲座的话你还不够资格做安全我不希望你自我感觉良好我想你记住你在安全方面很糟糕统计概率上来讲 你会搞砸的额…… 我也会搞砸这里边没有 这没有温暖而模糊的东西你真的需要怀着沉重心情望着镜子并接受你在安全方便很糟糕你不知道自己在做什么我也是这样对吧 这就是关键所在如果你要做安全你不该做 如果你觉得你应该进入安全领域重新思考一下回家 喝点什么 拥抱你的家人 喂一下你的狗 做些别的不要自己做安全方面 你就是不够资格那么而应该我想考虑的是在你的组织里面有人受雇做这方面的你应该相信他们而且 也有像 Spring Security 这样的工具你可以使用你也应该相信那个对吧 我们有一整个团队全职干这个的因为这些东西非常非常难 有很多我们作为工程师不能理解的东西 作为系统工程师或者是应用程序工程师 额 对于我们来说完全是陌生的 但对于普通的安全工程师而言却很有意义的 额这有很多的应用案例出现 在应用程序开发的世界 我们只是认为那是理所当然的 这因为安全与响应式编程的交互而变得更糟糕哈 那么…… 开始时候使用 Spring Security 理想的话 雇一个团队 确保他们也使用 Spring Security 我意思是安全专家 额…… 当我们使用 Spring Security 构建一个应用 我们关注两件事 这些都是正交的顾虑 它们互相之间并不相连这些是 额…… 授权 那也就是说我可以做什么？ 当我进入到系统后 我能够访问哪些资源？ 通过…… 额 通过哪个……我能通过哪个门在屋里穿行？ 给定一个钥匙 基本上是这样 那是授权 然后我们有身份认证 认证回答了问题谁在发起请求？ John? 还是 Josh 或 Jane? 是谁发的请求？ 他名称是什么他的身份是什么 那个正在敲门的人 你可以使用其中一个去通知另一个 例如 我可以说噢 那是 Josh Josh 有 你懂的 Josh 是好朋友 他可以进来这个房间 例如 可能那是其他人呢 你不是特别相信他们的 你懂的 你不想让他们看到 你的笔记本上的 PHP 代码 你们之间还没那么亲密所以 所以你不会告诉他 对吧 他们并没有那个权限 他们没那个权限 那就是授权 Spring Security 处理所有这些正交的顾虑 这些顾虑 这些事相关的但是不是同样的事情 现在想一下认证 让我们将观念切换回那些基础的认证概念我们在认证方面的目标是 获取一个从外界进来的请求 然后将那个请求变成一个东西 那可以告诉我们 是谁在发起请求 所以我们要将进来的 HTTP 请求 进来的对服务的请求 不管是什么吧 然后将它变成一种标记 关于请求者的某些 Id 我们要请求获取身份认证 关于请求者的 有很多种方式实现这个 你可以做基于 x.509 的相互认证 基于证书的认证对吧 这是其中一种方式 你可以做基于表单的用户名/密码认证 你可以做 HTTP basic 用户名/密码认证对吧你可以做各种不同的事情 你可以有 cookie “记住我”之类的东西 你可以使用令牌 你有对应着某些身份认证的令牌那会从一个认证服务器那里解析的 使用 OAuth 很多不同的方式可以达到这个特定的目的 可以做到对于给定的请求 这是 Josh 这是 Jane OK? 哈 然后取个简单的例子 然我们讨论一下用户名和密码 如果请求中有用户名和密码那会怎样？ 不管是一个表单 还是 HTTP basic 请求 当用户名和密码进入到系统 你提取用户名然后你有密码然后你要跟某些东西对比 然我们假设你有一张表 OK 一张 SQL 表 充满用户名和密码 所以当请求进来的时候 请求进来然后我们有密码 然后这个密码 额…… 是加密的 当请求进来时 没有 对吧 那是未加密的对吧 你需要那样做 你要加密对吧 基本上是 你要这样做的原因是 但愿在你的 SQL 表里 所有东西都是加密的 那是加密的吧？ OK 我要……喔…… 我才不会使用你们的软件呢 看起来只有五个人 剩下的人 你们吓到我了 额…… 这是怎么回事 我以为 大家都会喊 yeah但是 但…… 没所谓吧，额 是的 哈哈哈 嗯…… 那么…… OK 但愿你的密码以某种方式加密了 对吧 而且…… 因为它是加密存在数据库里的 类似地你也需要对进来的请求中的密码进行加密 并比较它们 对吧，你可以要做选择所有的用户名和密码并查看 passwordEncodes.equals 那个请求的已加密的密码 如果那为真的 你可以接受进来的请求 说这真的是 额 你懂得 他所说的 是真的 对吧？ OK 那么关于密码加密怎么说？那是什么原理 额 密码加密 就是前面提及的几样东西之一 我们早前提到的 会耗时间的通常是 CPU 密集型任务目前 Spring Security 使用的是 BCrypt 作为默认的密码加密器 它支持十多种不同的密码加密方式 但在目前 2019 年默认的密码加密器 以后可能会变的如果你在看这个视频 在 2020 年 或者甚至是下一周 对吧 我们现在是 2019 年 11 月初 但是因为安全领域经常发生变化你并不知道这些东西会不会变得过时 有些时候某种加密方式很正常 然后 然后不行了它们会被破解 不再可接受的了 所以 就目前而言 BCrypt 挺好 BCrypt 是非常 OK 的密码加密格式 那是 默认的 额 然后 还有它是 CPU 密集型的 那意味着 它要花费时间 它是计算上不高效的 你要坐在那里 等待结果 为了等待加密 要花多长时间取决于你那是编码强度的维度 你可以配置的 有点像调整杠杆 去取得更强健的秘密或不那么强健的密码 强度越强 花费时间越长 可能要一秒 也可能要两秒 你不知道的 关键是当那正在发生的时候 我们的服务会发生什么？你在阻塞 你坐在那个线程上 你在阻塞 这正是我们在响应式系统所不希望的OK 那么…… 现在我们将坏消息放到一边了对吧 那可能会阻塞的 你觉得 Spring Security 在这里能做什么？Spring Security 所做的是 当它准备要做用户认证的时候 它 创建… 它使用…… 它使用后台线程 它使用调度器 它从主线程池中移开 这就是我们所能做的 对吧这就是我们所能做的不可能在加密算法上实现响应式的 你所能做的就是将它移到一边 那就是 Spring Security 所做的那么好消息是在坏消息中有个好消息 好消息是 那就是你 所有不同的认证技术和不同的 你用惯的东西 使用的这些不同方法用于在 Spring Security 当中做用户认证的 某些依赖一些加密算法 所有这些机制这些你可能早已经熟悉了，如果你有用 Spring Security 它们的所有 继续能用得好好的 基本上不用修改 在响应式的世界里 这是好事 坏消息是所有的这些你所熟悉的东西 所有的 这些做加密的技术 毫无疑问 你们肯动用过当中一些 继续能用 不用更改 在 Spring Security 当中 这有好有坏对吧 额…… 这的确意味着你要特别注意将任务移到其它线程 在这个例子中 Spring Security 为你做了这件事 OK 但我早期提到 这是你需要注意的问题 移开或隔离此类阻塞的交互OK 你有用户名和密码 但顺便一下 也有替代方案 对吧 有不少基于用户名与密码认证的替代方案 嗯…… 而且重要的是要留意这些选择 对吧，其中一种选择是使用 OAuth OAuth 是非常适合的 额 因为 你做的是获得一个 Token 一个 Token 进来然后你要根据授权服务器验证那个 token 对吧 或者是一个已被加密的 JWT 已经被验证了的 基本上是一个自验证的但是 额…… 不过哪种方式至少都会与实际干活的第三方有交互 去验证 用户名和密码 但只需做一次 如果那是一个授权服务器 是在第二个节点完成的 更好的是 如果你购买基于云的服务提供者 例如 okta 他们会为你做加密 当你支付 okta 或者像 okta 的机构 去作为一个 OAuth HUB 你实际上是购买他们的安全服务 这其实很好 因为有整个团队全职干这件事 但你实际上也购买他们的 CPU 周期 你给钱他们为你做这个占进超的操作在他们的计算机 而不是你对吧 这实际上挺划算的如果你那样想 你购买的不仅是他们的知识 还有，你懂得 CPU周期 现在额 那是其中一种选择 你可以使用 你可以使用那个 请记住，让你的安全人员在队里很重要 这方面我可以一直讲好几年请记住 很多事情 我们觉得合理的其实不是让他们也加入决策过程是好的 我再次猜测才学到几乎都要猜两次才中 你懂得 你不会清楚安全的兼容性 关键点是 如果用户名和密码进来 然后我有这个密码想要 我想要加密并针对请求的密码进行校验 我要做什么 我获取那个密码并加密 然后我对数据表做一个选择全部操作 然后 username=? 以及 password=？我看一下那个东西 如果我够聪明的话 作为一个系统工程师 一个应用工程师 我说 OK 你知道吗 每个密码加密需要 2 秒钟 我会给我自己更多一点时间 我要短路求值那个验证过程 我准备说 select * users where username=? 如果那个用户不存在 那就不用管密码了 对吧 如果用户名不存在 就不用管密码了 听起来非常合理对吧 我之前就是这么干的 但从安全角度来看完全是错误的 黑客利用这一点 别人想黑你的系统时 别人利用这一点 说 噢 好你有一个登录页面 如果用户存在需要2秒登录 即使密码错误 但如果用户不存在 就不花时间 所以他们可能不知道你的密码但他们现在知道 jlong 存在于数据库里 例如 对吧 这是时间相关黑客 这我以前都没想过的 但安全人员会考虑到 Spring Security 会返回假 密码 如果不匹配的话 这个例子 总会是两秒，不过什么情况 对吧 现在 额 那是现在已不是非此即彼 所以我们要做的是 讲 Spring Security 加入到我们的应用 然后我 我要这样做 使用你可能用到的最坏的东西 我没时间为你设置 Active Directory 或是 或 SAML 或 或是 OAuth 所以我们只做 基于用户名和密码的加密的东西 硬编码密码， 别这样做 千万别这样做 所以 我们要写 fun… OK 我们的认证 将会是一个 MapReactive…而现在我要加入 Spring Security 依赖讲了安全方面的情况 主要还是 Spring SecurityOK 就是这样。好 将会给我一个 MapReactive…… 电脑干活吧 然后我们要创建一些用户 我写User… 这个方法是已经过时了 这个函数是过时了 额 它基本上 你可以看到 没有将其移除的计划 对吧 但它不是安全的 它只有在做演示的时候才是可以接受的 嗯哼 嗯 所以它会使用默认的那个 在目前也就是 BCrypt 对吧 如果你将所有的数据存到数据库 以 BCrypt 的形式，今天的话 然后到明天默认的换了其它的话 量子 BCrypt 之类的 那样子突然就没人能登录进系统了 对吧 因为你使用不同的加密方式 那就是为什么你要指定需要使用加密方式就我们的目的因为我实际并没有与数据库交互 只是在内存的 那没关系的 OK? 现在 我们创建一个用户名 还有一个密码 OK？ 还有就是 我给自己一些角色 USER OK？ 好东西 看看那 现在 我也添加 Spring Security 的领头人 Rod Winch 而他 我相信他保护我的数据 还有我的生命 隐式地 所以我们这样做 关于这个 demo 有趣的方面是 我在这边为你演示的 这个 demo 我做过不少次 我经常到处飞 每年我都尽量去多点地方 我尽量访问更多的人 额 你懂得在全球范围内 而那会让我有的忙的我已经访问了 三十多个国家 有时候更多 每一年 每年都去很多很多城市 成百成千里路 从北美来到这边就已经要 600000 英里了对吧 所以我尽量去适应 我设法接触更多的观众所以我在不同的时区都做过这个 demo现在我们在欧洲 现在是 这离我所在的州不是很远 Rod Winch 住在堪萨斯州 美国本土正中心 有时候我在其它国家做这个 demo 我去到更远 到东边 例如我去东欧 我去亚洲 我去中东 我去世界各地 你懂的 我去 澳大利亚 比如说似乎不管我在哪里做这个 demo 与我在哪里做这个 demo 无关 我注意到的一些事情是那 每次我做这个 demo 不管我在世上何处一些奇怪的事情发生了 似乎不管在何处都会发生的 不管我在哪个时区 只是很奇怪 每次我做这个 demo 我在这边硬编码写死用户名和密码在舞台上 每次我现场做这个 demo 在地球上的任何地方 不管在哪个时区一些真的非常奇怪的东西 开始发生 每次我做这个 demo 因为他无法理解 由于他不必要理解的原因 Rod Winch 在每次我做这个 demo 的时候 在台上将用户名和密码写死在代码里的时候 每次我做这个 demo Rod Winch 他开始回复邮件每次我做这个 demo Rod Winch 开始回应 Google Hangout 和 Slack 或在 Twitter 他开始发起 Pull Requests 不管我在世上何处只是看起来 每次我做这个 demo 的时候都会成功 他就突然出现了 不管是在什么时候 Rod Winch 是一个顾家的人 他有好的妻儿 他应该睡得很好的 有时候 对吧 你觉得但不管什么时候 我做这个 demo 时他开始睡不着每次我做这个 demo 我写死用户名和密码到代码中时由于一些 Rod Winch 没法理解的原因Spring Security 领头 Rod Winch 不必要理解的原因每次我做这个 demo 当我在台上写死用户名和密码到代码里 Rod Winch Spring Security 的领头人 开始难过 这将他唤醒 睡得那么沉的时候 他没得选择 只好干些活 因为他不知道那是怎么回事所以我的朋友们 不管你做什么 我无法强调更多了 不要让 Rod Winch 难过 不要做这样的事情。Authentication​\t\t现在，我们要也要做授权控制。OK？ authorization… 然后我们使用 ServerHttpSecurity 构造器 就像这样 然后写 http. 我们要启用一些东西 我想要构建它 这很好 我将要 使用 HTTP basic OK 我想要 HTTP basic 很好 我要写 HTTP basic 定制化它 这里的类型是什么？这是一个定制器 然后 withDefaults() 好 我要禁用 csrf() 因为在这里我不需要 所以我写 Customizer Customizer… OK 额 it… .disable() OK 只是一个 lambda 我可以这样做 嗯 我想要设置一个 授权交换器 OK 当请求进来时我想要允许 anyExchange()… 可以被访问 当我们要限制一个端点 当 .pathMatchers… /proxy 是一个 被允许的 额 不好意思 当你发起一个请求到 /proxy 我需要它时被认证的 其它东西都可以通过 但这个端点会被锁住 而且这是特别重要的 因为 这个需要出现在前面 我想要确保 我们先匹配这个然后是通配符其它所有东西都匹配了 如果这个放在下面这里 那么我们不会有机会到达这个规则因为它会匹配第一个OK 所以很重要的是最具体的规则 放在前面 所以这是默认的配置 OK 让我们看一下那会怎么样 好了 这就是结果你可以看到这是 401 Unahuthorized Basic realm=”Realm” 我需要认证 OK 所以 -vu jlong:pw 设为 http basic当我这样做时 我在下边这里获得了数据 这是 JSON 随着我发起请求 我接收到 3 个首部 表示我限流的容量 X-RateLimit-Burst-Capacity 以及 Replenish-Rate … OK 那么现在 我想要获取一些流量 但愿会超出它的限额在我发起请求的时候 你可以看到我使用的是额 稍微切换下 负载均衡器 额 不好意思 负载生成器 当你那样做的时候你可以 看到 429 Too Many Requests 它正在拒绝请求 因为它超出了一个很小的限额 我只是指定 5 个 那样的话我随便用 Bash 就可以超了 然后其中一些能通过 你可以看到 所以这边有一个通过了 所以这是每秒5个对吧 你看这边 你看 你看 然后最后结果是 429 对吧 所以每5个请求能通过 然后在那之后 请求被拒绝。限流器的演示OK 非常常见，非常简单地运行 Spring 给与我们能力 你懂的做各种有趣的事情 现在 目前 我已经使用了 Java 的配置风格 然我快速地指出 在 Kotlin 我们有 好的 设施 你可以在 Java 里面做的 但为了好玩 我会在这里创建一个 context context OK 然后我要添加 我的 Bean 我要像这样添加一个 Bean 所以你可以看到 Bean 你可以注册 其它 Bean 例如这个 RateLimiter 我可以按这种方式注册 我可以说 Bean 然后删除那个这实际上是函数式风格的注册所以我可以说 addInitializers… context 然后 哇啦 OK？ 这实际上是一个函数调用 所以我可以做 if if (Math.random() &gt; .5 ) 对吧 那样的话这个 Bean 不会被注册 如果小于则会 随意吧 如果它是大于的就会被注册否则不会 你可以选择任一风格 实际上这些东西可以混合搭配的 唯一的问题当然是 通过将它取出来 使得我现在得要注册这个 Bean 作为一个参数 所以 redisRateLimiter… 你可以混合搭配的 OK 随你便 现在我们有函数式的响应式端点 我们有 API Gateway 我们使用 Spring Cloud Gateway 我们看了 看了响应式…… 我们看了在响应式编程上下文中的安全 我们看了API Gateway 不同的过滤器 当中包含限流器 现在让我们来讨论一下 API 额 适配器 API 适配器是一个东西将进来的数据 然后它有点知道荷载中是什么 它知道如何操作或者按某种方式转换处理那个进来的荷载并在更改之后继续转发 OK？ 一个 API 适配器 额 不是一个特别的东西 你可以只使用普通的函数式响应式风格我实际上可以 在这里使用函数式响应式风格 然后你看到我在前面的 Java 代码也是这么干 这些是 DSL 你可以想象到的对于此类东西 在 Kotlin 的世界里 所以我们只需要写 router… 我可以写 … 我可以产生服务端响应OK？ 所以在这边我产生一个响应 额 那是 基于进来的名字的 基于那…… 我要通过调用下游预约服务产生响应为了要调用那个 Web 服务 我要使用 WebClient 那个 HTTP 客户端，像这样 然后我要调用下游的服务 我写 webclient…当数据进来的时候 我将会对此修改 我将其转变成一个发布者 类型为 Reservation 的 我可以用 Java 指定 我可以指定为类型字面量 即 Reservation.class 但在 Kotlin 我可以有这个疑似泛型的东西 我可以提供泛型的参数 但你发现我的类路径中没有那个类 用那个类型 被创建一个数据类型 创建为 data class val id… 这是一个 Integer然后是 val name: String 作为 DTO 所以就是这样 你可以看到 IDE 在提示我添加这个扩展函数 那允许我指定泛型参数 然后它知道那是什么因为有点 验证并在运行时捕获泛型参数 我不需要指定一个类型记号 例如 Foo.class 所以 Reservation reservaions…好吧这是一个 发布者 类型为 Reservation 所以这是我的 已更新的代码 让我们看一下有这个 好 实际上我并不需要它 对吧 这是多余的 如果我移除它 保留这个移除那个 一样可以 这是同样的东西 编译器能够知道 随你 所以这是我的 reservations 我所要做的是将它发送回来 那个 Reservation 我实际上想将它 map 到 我只需保留名字 其它的都不需要 OK? 我将要写 reservations 你可以看到那里还有另一个扩展函数 在函数体中的第二个参数 嗯 函数或方法是发布者的类型 所以 findAll 返回 一个发布者 类型为 Reservation 但是因为泛型 因为 Java 泛型的缺少在运行时没办法让我捕获 那个泛型参数 我没法说 嘿 T.class 是什么 对吧 不存在的 但这是 Reservation.class 我得要将它传进来 在 Kotlin 我不用这样 我可以只说&lt;Reservation&gt; 然后它能捕获 在编译时 被捕获并为我写在代码中就像我显式地写了类型 token 所以这是我的函数时响应式端点 非常简单的 HTTP 调用 然我们确保它能用让我们看一下得到什么 注意我跨越线路进行网络请求 嗯 首先 我写死了这个主机和端口 这是好主意吗？可能不吧 我应该使用负载均衡器 噢 我需要 一个 WebClient Bean 让我们在这里创建一个 fun webClient…一点关于 WebClient​\t\t额 OK？所以现在我们有了一个 WebClient 让我们看一下 我启动这个 我写死了这个用户名和密码 额 这里这个主机名 你不应该这样做 如果你使用 Spring Cloud 和服务发现客户端 你可以使用 Apache ZooKeeper 或者是 ashicorp Consul 或者是 Eureka 随意吧 你可以说 lb:… 对吧 那实际上是 或 你甚至可以使用 HTTP 不好意思 那只是 http 你可以那样做 对吧 但我写死了用户名和密码 即便如此 让我们假设我做对了负载均衡如果没有实例可用 没有服务可用怎么办 如果某些东西出错了 网络断开之类的 额 这里有些操作符可以使用说 OK 例如 onErrorResume…然后返回 Flux.empty() 如果某些事情出错 我可以控制返回的发布者 非常方便 而如果某事出错 我们可以重试我可以重试十次 我可以重试十次 然后指数回退 OK 指数式退避 这里发生的是有点跳动 因为那样你想要避免瀑布式重试风暴 对吧 如果我的服务重试 一秒后重试会发生什么 它重试如果还是失败 就2秒后再重试 3 秒后再重试 直到 10 次但不是准确的 1秒 想象 5个客户端同一时间发起 5 个同样的请求 结果会 你懂得 扩散那个 失去那个服务 所以要确保我们避免这些 所以我们有回退 额 在 Backoff 里面 你可以做很多有趣的事情 你可以做更多有趣的事情确保你的服务可以承受一些失败 我喜欢 Backoff 和 retry 另一个你可能使用的是 Timeout 这是非常常见的东西在这里使用超时问题在于 timeout 它们并不是特别公平对吧 它们是有点 它们是有点不太友好 如果你这样想 想象下我的服务要调用另一个服务 然后另一个服务调用另一个服务 我的服务在这边提供 9 个简单的路由是 20 秒 这很不正常如果你的服务访问要 20 秒 恭喜 你的工作是世上最简单的工作 对吧 你可以在 20 秒内做任何事情 对吧还是 假设你的服务提供需要整整 20 秒 然后你还调用另一个服务 那个服务要返回到给你 要多快？ 我会说 10 秒 对吧？如果你设置超时 你可以确保你在十秒内超时 然后再试多一次 直到你的服务能够被访问到 在破坏服务协议之前 所以你要将它除以二 那样你可以重试两次 对吧 你调用的东西如何? 如果那个东西调用另一个服务 它要在两秒钟内响应这意味着它调用的服务要在 5 秒内响应 对吧 所以这变得很不公平 想象下很差的服务 在那之后要在两秒半之内响应最终这会变得不堪一击对吧 所以 timeout 是最后的选择 它们能用 但是最后的选择 对吧 我并不想 将我整个系统构筑与超时判断之上 而是一种常见的分布式系统模式 额 谷歌首先提出的 然后 Uber 和 Netflix 都使用称为 服务对冲这个 hedging 所以 当你 当你 去一个赌场 我不知道这里是否有赌场 如果你赌博 这是种坏的 这是一种坏的策略孤注一掷你希望分散赌注 你要确保将风险分散 将风险分散到各个可能的投资对吧 你想要保留选择所以分散赌注意味着你只是分散了风险 这边也是一样的 这就是我们将要做的 分散投资 通过不发起同样的请求 到下游服务 所以我们要做的是 让我们将这代码移到这里 让我们重写这个代码 让我们假设我有 在这边假设我有个调用 val call1 =… 然后这是个发布者 Flux&lt;String&gt; 然后我们不知道这将会来自哪里 //todo OK? 我假设你会在那里发起个网络请求OK call3 还有 call2 OK？ 现在我有它们三个 我想要第一个 我想要在同一时间发起三个请求 而我可以这样做记得是因为我们有调度器 调度器可以在同一时间发起三个请求 请求会发出去当返回时 我想要返回的第一个响应 其中一个可能失效 其中一个可能去吃午饭了 你不知道 可能垃圾回收了 可能停止了 不管什么那个服务现在不可用而三者之一肯定是可用的 而我使用 3 作为一个简单的数字 你可以用个 for 循环 然后选择一些数字你可以使用 Spring Cloud Discovery 客户端 去询问服务注册表 你懂得 zookeeper consul eureka 随意吧你可以说 嘿 服务注册表给我 x 个实例 给我 20% 的容量 不管是啥 对吧 但让我们假设我想要第一个 我想要第一个的原因是因为我想最快的第一个开始发出值的发布者 那就是我想保留的 所以我写 Flux.first(call1, call2, call3) OK?他所做的是要保留第一个发布者然后 它取消管道的被压到其它两个现在我不用浪费时间 在不会产生结果的数据流上面 然后我尽快获得最快的结果OK?这是很常见的策略 而且很容易实现。超时、重试、分散风险​\t\t但想象一下不用响应式 API 实现的话，你所做的是一种竞争状态，定义上来说 这是一种竞争状态 你实际上希望 某些事情会出错 某些事情会先发生对吧？ 当你没有注意到 这并不是你想写的代码 在一般的多线程代码 你没有见到 任何的 Phaser、Semapore、CoutDownLatch 或是 CyclicBarrier 或是线程 或是 Executors 在这代码里然而它们肯定都存在在那里 还有请记住 这不是希望的消息 记住 只有一个人真正懂得如何写多线程代码而 那人不是你这就是最关键的 那不是你 是谁不重要 只是不是你 好吗？ 将它交给框架吧 尽管如此 相信我们我们也不敢保证百分百没问题 对吧 我们很肯定 这已经是久经考验了 被一些业务专家 但 你懂的 这些东西易出错 OK 额 现在 顺便说一下 你记得 Java 5 吗 那个 双重锁定模式 他们发现那个继承上来说是不安全的在 JVM 在 Java 5 之前对吧甚至是 JVM 甚至开发 JVM 的人 发现他们的多线程代码有个bug 在我们所依赖的 5 个版本的 Java 对吧 嗯 所以我们有了这个响应式 API 有边缘服务 也有这些可以使得代码刚强健的模式 这是非常自然的表达在响应式的世界里所有这些我觉得很有趣 其中一样我可以讨论的是断路器 我在这里并没有引入断路器 因为我们并没有足够的时间 但你可以使用一个项目叫 Spring Cloud Circuit Breaker 它支持响应式断路器 它有四种不同的实现 阿里巴巴 Sentinel Spring Retry 还有 Hystrix 当然还有 Resilience4j 你可以很容易地使用它们包装 这个特定的调用到断路器 如果出问题了它会重试 重试 重试 你甚至可以让它重试直到某些条件为真 通常那会是一个布尔量 系统某处的一个开关可以禁用某个路径 所有这些都很有趣但是 断路器我认为是问题的症结也就我们没有更好的方式。讲响应式编程模式比传统自己写多线程的优势​\t\t我在这里给你展示的很多东西，是基于没有更好的方式构建更好的服务。目前我给你展示的所有都是基于 HTTP 的 我也挺喜欢 HTTP 的我希望它一天能成大事 但我不知道这是否是服务的最佳选择 是获取文档的很好选择当做服务的时候我们还可以做得更好 对于有状态的连接 对吧 我想有更好的东西 更快的异构的服务环境 我想有更好的东西 有很多组织想要解决这个问题 Google 方面创造了 gRPC 而那促进了很多 HTTP 2 的变革而 gRPC 默认并不是响应式的 它支持异步 但不支持响应式 在硅谷有家“小公司” SalesForce 他们为 gRPC 创建了一个插件是一个 gRPC 的编译器插件 会创建基于 Reactor 的服务 有点意思实际上你可以 代码生成 而不是默认的gRPC代码生成你代码生成基于 Reactor 的服务 我喜欢那个 但在我看来 我认为 gRPC 不是准确的好选择 首先它要求用 HTTP 2HTTP 并不支持多路复用 那是流水线的但跟实际支持多路复用不同 而且它还要用到 Google protobuf 所有东西都需要以 Google protobuf 编码 所以我推荐一个叫 RSocket 的东西 在最后几分钟将会看到的是 RSocket RSocket 是由 Facebook 创建的二进制协议 这是一个原生支持响应式的二进制协议 由从 Netflix 后来到了 Facebook 的人创造的 而且 这是一种开放的二进制协议 因为它是开放的 而且是二进制协议 谁都可以使用 有客户端包括不同的语言 包括 C++ 包括 JavaScript 当然包含 Java 当这个来自 Netflix 的团队创建 RSocket 一直在搞 RxJava 很多年了 并了解 那个技术的扩展 当那个团队来自 Netflix 决定创建 RSocket他们为 RSocket 构建一个 Java 客户端很自然地搞 RxJava 的这个团队 顺便提一下 那是一个与 Reactive Streams 规范兼容的框架 RxJava 2 及其后版本 现在是 3这些都是响应式数据流 很自然地那个团队来自 Netflix 的研究和使用 RxJava 很久了所以当他们去到 Facebook 他们创建了一个 Java 客户端RSocket 客户端 很自然地他们选择 Reactor所以他们这样做了而 我是开玩笑的 我不知道他们为什么这样选择我当然感激 因为这使得我们更容易使用它了顺便说一下 用 RxJava 2 也没有问题RxJava 很不错 也兼容 Reactive Streams所以你可以在 WebFlux 用 Reactive Streams任何返回发布者的像 Akka Streams 和 Vertex RxJava 2 可以跟这些东西交互 但是它是基于 Reactor 的 OK? 然后那支持 使得我们非常容易集成所以我们确实这样做了。介绍 RSocket 对比 gRPC​\t\t我要做的是构建多一个边缘服务，再多一个 API 适配器。但这一次我想要回到我们的 GreetingService 我要将它变成一个 RSocket 服务 有两件事是必须做的 首先你要写点代码 肯定要啦 对吧 所以喔那发生了什么？Controller OK？我这个键卡了 感谢苹果 OK 然后是 @MessageMapping greetings 这是我的 RSocket 代码不用客气 我已经写好了 现在 为了能这个可用 我要在一个不同的端口运行 7777 然后我运行这个程序 现在 在客户端 我想要消费那个 RSocket 服务 请记住 RSocket 是一个二进制协议 可以做一些你在 HTTP 中不可以做的 首先是当客户端与服务连接时 当一个节点连接到另一个节点 它们成为对等关系 不再是服务器与客户端的关系它们是请求者与响应者的关系 一方可以发起会话任一方可以随意响应 任一方都可随意发送多或少它们可以发送 0 个值 1 个值一个响应式流的值 它们可以应用原生的背压式 你可以恢复一个 Stream 对吧 我可以拿 10 个记录然后进入没有 WiFi 的隧道 然后恢复 取多 10 个记录下来 对于 HTTP 如果我的 HTTP 客户端 不管是否响应式 与我的响应式服务器断开连接我的响应式 Web 服务 就说 噢 Socket 没了 所有调用都取消了 然后我应用背压式到这个响应式流 然后那会取消响应式流 在我的 MongoDB 或 R2DBC 数据源 对吧 那是传递性背压式 但你只能做一次 用 RSocket 我可以我可以暂停 可以继续 我可以做真实的响应式背压式对吧 这是非常有用的东西 想象一下它们是省带宽的如果你知道你懂的我要穿越一个隧道我要从这个点开始重新连接 对吧 那么 RSocket 嗯…… 额 支持所有不同的消息交换模式它支持 Fire and forget 它支持数据流输入输出 它支持单个消息入 没有值出或当个消息入数据流出来数据流进无消息出 随意吧 但你可以做所有各种消息交换模式 这是线路上真实的背压式 额 它是与荷载无关的所以 你可以发送 JSON、Thrift、Areon或是 Datapack 随你 或是 Google probuf 这样没问题对吧 嗯 它还有其它的好处使得它非常适合构建可扩展的服务 假设我们想用 WebSocket 做二进制通信 安全方面如何？ 你如何做 WebSocket 安全 对吧？它是一个 非常简单的问题但不是一个好的答案 如果你首次加载 WebSocket 端点 那里还会有 HTTP 首部的记得我说过协议升级 更换端点吗 那可以用 HTTP 首部做安全 像往常一样使用 Spring Security 能跑起来了你如何做安全?在 WebSocket 并没有首部 在 RSocket 里有首部 你应该有首部传递在范围外的信息 去传输一些像 Token 的东西这只是一些 HTTP 的基本限制 以及 WebSocket 等其它协议 显然它们并不是为服务而设计的 它们为文档获取而设计的所以 RSocket 克服了很多缺点 它是有状态的连接 很多你体验到的降速 当你使用 HTTP 的时候 是因为你经常连接和重连 用 RSocket 的话 你一直是连接状态 一旦已连接 任一方可以发送任意多少数据一个打开的 Socket 可以处理同时处理很多很多连接 很多很多请求 这就是我所说的多路复用所以这是一个很有趣的协议。RSocket 应用举例，使用场景，对比​\t\t让我们在这里构造我们的 API 适配器，再多一个端点 我们称之为 greetings{name}… 然后在这里我要调用下游的 RSocket 服务 然后我将要返回一个请求数据流 但我要将它通过服务发送事件返回给客户端 OK? 所以我要在这边注入我的 RSocket 客户端 fun rsocketClient… builder 额不好意思 RSocket… 随意吧 builder…RScoketRequester… .connectTcp… 我们只是想连接一遍 例如我可以这样做 OK？这就是我们的 RSocket 客户端现在 现在我要注入 RSocket 客户端 所以我写 在这里写 rsocketClient 好吧 RSocketRequester 然后我发起请求 rsocketClient… 然后端点是 greetings 而我要传入的数据是 是 greetings 请求和响应 什么…… 这是什么？这是之前打开的东西 我已删除了 OK 所以这是数据 额 val request 那会是一个“问候”的详情 我也要在这里创建data class GreetingRequest(val name:String)还有 GreetingResponse 现在是 GreetingRequest 和 GreetingResponse greetingRequest 然后 name 我从当前请求的路径变量中获取所以就是这些我会将它传进这里 我写 request… 然后返回的数据会是 stream 我会返回类型为 GreetingResponse 的发布者 val greetings 好吗 好东西 greetings 好的 这就是我的数据 所以这是我全部东西 当然这将会是一个服务发送事件流所以我发送回一个 contentType 去告知框架差异化处理 MediaType… 然后运行 好吗 那么现在 打开浏览器 访问 localhost:9999/greetings Devoxx 它会产生响应 每一秒 不间断地 通过网线 你懂的 不浪费时间一直到永远永远请记住为了得到那个服务发送事件流 在这个 9999 端口 我做了一个 RSocket 调用 到 端口 7777那是 响应式地发送不间断的数据流 这就是能用 对吧 这是一个二进制协议 我在最后将它变成了 JSON 这有点可怜 但 你可以看到正在发送什么对吧 现在 RSocket 有点意思 有些有趣的组织 已经开始使用了 它已经被整合到 Spring 5.2.x了 以及 Spring Boot 2.2 两个都 GA 了 所有东西我给你展示的 实际上所有东西除了 Spring Cloud Gateway 都是 GA 的东西 甚至我展示的 Spring Cloud Gateway 都是GA 了 你可以像在旧版本中那样使用它 但我现在使用的是一个非 GA 版本的 Spring Cloud Gateway 嗯 RSocket 正如我所说 是起源于来自 Netflix 的人的所以当他们去了 Facebook有了一些有趣的可能性 我们有新的 RSocket 支持 在 Spring Cloud Gateway 其中一个很有用的使用常见 想象下你有 RSocket 网关作为一个汇集器 请求去到 Spring Cloud Gateway 端点然后它们转发请求到其它的节点想象这些其它的节点 完全是黑箱子 没有入口的 完全封锁起来的 没有办法对它们发起请求的 当它们启动时它们打开一个rsocket 连接到网关 然后网关会将它们路由到其中某个可用的节点 其中一样网关可以询问这些节点的是嘿 你的健康状态如何? 你的可用性如何？ 你们有多少人使用 Actuator？ Spring Boot Actuator一系列的 HTTP 端点你可以用来询问个问题 你健康吗 你的启动时长是多久 状态怎样？指标如何？那些信息 时已经内建在协议中了在协议中有一帧 用于广播应用的健康状态 所以智能客户端可以看到它然后 你不是那么忙吧 我要将请求发给你这就像背压式的反转 而不是客户端控制流量 现在服务它自身可以广播它自身可处理请求的可用性这就是网关的作用最好的安全方案是你不需要担心的方案这就是这特定的组合给你带来的与网关的整合非常吸引人如果我有更多时间 我甚至可能会演示下。演示完 RSocket​\t\t但恐怕 我的朋友们，我们就要没时间了。快速的问题 谁玩得开心？好东西谁学到东西了？哇我很开心几乎大家都举手了那让我开心很显然我玩得开心 我穿着 Spring T恤还有 Spring 内裤 我当然开心我热爱这些东西 对吧当我的朋友们你不必只是听我在吹很多公司都已经大规模应用这些东西了我讲所有这些东西我花了很多时间跟不同的机构交流在世界各地我在巡讲这个月下旬 我会到中国的四个城市跟 Netifi 一起，另一家搞 RSocket 的公司还有 我会去阿里巴巴另一家公司全是用 Spring 的即使它只是中国的一家“小”公司我相信它某天会壮大的 额它们上一年做了 300亿美金 销售额，不好意思是上一年一天的他们做了 300 亿美金销售额你们…… 知道吗？好吧 只是好奇 了解一下他们都是用的 Spring 他们都对 RSocket 很好奇好的 我的朋友们 嗯……希望你们学到些东西 我很乐意回答问题感谢你们的时间 我后面还有两个讲座 一个讲Kotlin 一个讲测试的如果你想了解如何测试这些东西的话你绝对也应该来看看那个非常感谢祝你有美好的一天记得投票!我想有机会再回来 你要给我投票噢 拜托了" }, { "title": "响应式变革 Reactive Evolution 第 1 部分", "url": "/2019/11/21/reactive-evolution-part1/", "categories": "", "tags": "Reactive Programming, 响应式编程, Spring WebFlux, Spring Cloud Gateway, RSocket, R2DBC, Kotlin", "date": "2019-11-21 08:10:00 +0800", "snippet": "响应式变革第 1 部分——构造服务端传统的方式​\t\t响应式编程不是一个特别新的话题，不是新的概念。大概在 5 年前就开始讨论这个话题了。它更多地应该是一个答案。对更老的问题的答案，一个已经存在很久了的问题——如何扩展系统，可以支持更多用户，处理更多进入系统的请求。响应式编程是一种表达方式，一种新的答案。而答案的本身，并不是很新颖。响应式编程，更多是关于线程的使用效率。是关于让你的系统，让你的软件，在 JVM 上更好地处理线程的一种方式。这是很重要的，因为线程代价高，JVM 的线程开销大。​\t\t所以现在问题是，为什么我们为什么关心这个，对吧？我们支持更多用户的动机是什么？问题不是特别难回答，我相信你们能够指出一些方面。在过去 10 年 或是 12 年促使我们扩展的原因，并处理更多的用户，并不难找到这类东西。我才用这东西自拍了， iPhone 对吧？还有安卓设备，各种这些智能设备，这又促使了一大波，还有物联网的浪潮。这些联网设备随着我们连接更多的东西到互联网，随着我们逐步地迁移到一个HTTP 请求的世界并加上 CSS 和 JavaScript 构成一个视图的年代。我们从那个世界，迁移到了另一个世界，现在单独的一个用户界面，可以由十几个网络请求的，一系列的网络请求，最终才组合组成你看到的视图，对吧？而且这对于不同的连接设备都不同，当我们进到新的世界。现在一个用户界面又十几个网络请求组成，我们后端的服务变得更加棘手。​\t\t尤其是这些服务没花什么时间，产生结果原因是正确的传统构建软件的方式，在JVM构建软件的传统方式一直比较简单。当请求进来的时候你得到一个 java.net.ServerSocket，监听在 8080 端口并且当这些请求进来的时候ServerSocket 接受客户端进来的 socket 请求然后客户端将载荷发送到服务器，服务器接收给与 SeverSocket 和 socket 都有 InputStream 和 OutputStream然后他们开始相互通信了。它们来回传输字节通过网络。然后，当那个请求到达服务器，在传统的服务器 15 年前。那是非常简单的 while 循环，接受请求，创建一个新线程，在线程中你从请求中读取输入的字节。你在输出流产生响应，然后你发送回去，产生一个响应需要什么？现今，要做什么产生一个响应？你要做很多事情，你要调用数据库。你要调用 Web 服务，调用。额，其它的 API。传统的做法使用输入输出流，所以全部的 while 循环都在这个线程。你发出一个请求，并等待数据返回，只能停在那里等、等、等。你在等待这些字节返回，同一时间你在那个线程做什么？没事干，只是等 ，空闲状态。然后，这就是真正的犯罪，这是真正的问题。因为占用线程不做任何事情，这是非常不高效的线程使用方法。线程代价高，我们不能无限地创建它们，对吧？​\t\t所以这是第一个问题，希望还是有的，对吧?在视野之内几年内，幸运的话，我们有望迎来纤程，对吧？我不知道什么时候才有，算他两年吧，最快的情况。但愿这能让你创建更多的线程，另一个问题。当然，假设你部署，最新版本的 JVM 到生产环境。我是这样做的，你也应该这样做。如果不，我可以看到你们一些人有点不自在，所以我就不问了。你们还有多少人还在用 Java 8 不过……我们可能，哦哦 我看到你们有些人不自在了，好不管怎样，关键是假设你们有，使用最新版的 Java，并且假设我们在未来两年或三年有纤程之类的。额，然后，现在我们需要解决另一个问题 构建分布式系统。现在我们思考数据跨越网络的情况，考虑服务之间通过线路交互。是傻子的想法傻子的做法，去认为当我们请求的时候立即就能获取数据就好像数据在打个响指就在那了。对吧，傻子才这么想，才会认为 服务响应迅速，快捷，或者是可靠的。而且一直是高可用的，而且不会出错。当构建分布式系统这些交互情况是常见的，而且这种方式，这种传统方式，读取下一个字节。并不断地等待下一个字节，忽视那样的现实，忽视网络是不稳的。不稳定的，有时候还有问题的地方数据可能会丢包。所以我们需要更好的范式，更好的通信方式。用于处理这样特别的现实情况，所以，我们面对的是…… 噢 好东西。我们面对这样的需求，构建更好的系统，构建更好的软件。要支持它，目前，我们使用响应式编程。响应式编程，使得我们可以处理更好利用我们线程的需求。并允许我们编写更多消息传递风格的代码，将世界想象成为一系列的异步事件。事实确是如此 世界是异步的，是充满事件的。不是一系列的同步数据，你随意能获取想要的。所以，我们有这样的目标，目标是我们有一堆线程，随着请求进来。我们不想占着线程等待下一个字节到来，我们得有些转变，我们要改变传统方式。处理数据流的方式，而不是坐在那里等待数据到来，随着我们将数据从输入流取出来。​\t\t而不是这样操作，让我们切换到另一个世界。比如说，我们等待数据推送给我们，我们等待数据的生产者发布数据给我们。然而这是很难的概念对吧，想一下我们所做的事情可能阻塞线程。我们有什么东西是阻塞线程的，额 当然啦 有很多显而易见的事情。例如占用 CPU 的任务，像计算斐波那契数列。或者是加密，挖矿对吧？额 额…… 安全之类的东西，因为那需要加密。会符合这一类型，额…… 运行 Slack 对吧 需要很多 CPU 资源，基本上全占用了，对吧？你不希望这些东西独占 CPU 是很显然的。而且你不能解决这个问题，使用响应式编程。有些东西就是要占用 CPU 的，但是有些东西是 IO 密集的。受限于输入输出的，然后这些东西是天然适合。我们现时所作的一些修改，你发现，我们不需要做同步的。阻塞的输入输出，没理由让我们查询数据。从输入流 我们可以让数据准备好给我们。我们可以告诉操作系统，看这里操作系统。这是一个文件描述符，它有数据但是目前还不可用。请给我一个消息，给我一个中断回调。当数据可用的时候，对吧？ 这是操作系统很容易做到的事情它可以查询可以管理，它可以高效地选择，成千上万的文件描述符。但它不能创建成千上万的线程，这就是问题所在。所以更好的情况是，嘿 操作系统。给我一个回调当数据可用的时候，我会当它现在可用的状态继续工作，而不是更早的时候。同时，之前我用于询问数据的线程，我已经离开了那个线程。并让操作系统的其它用户使用那线程做其它事情。这仍然不是什么新东西，它有个老术语叫多线程协作，很简单的概念。我们说，嘿，我将会这样写代码。去告诉系统，我什么时候用完这个线程，我会表达更加明确，我会多花些功夫使得。那是一个多租户的系统，这是一个很简单的概念，响应式编程出现的原因是。给我们一种编程范式、模式，去让我们这样的表达这个世界可以让我们这样说 嘿，我请求了这个数据，但是它还不存在这里。这是异步的，它现在还不在这里。还未被解决 但最终会到来的，而且，可能不止一个值，这就是事情变得有点不同的原因。我要怎么说，我有一个值需要获取使用现在的 JDK，你说我有个 Future Future&lt;String&gt; 或 Future&lt;Integer&gt; 随意啦。甚至 CompletableFuture 更好，会给你一个值。响应式解决方案——响应式数据流规范 Project Reactor 背景​\t\t等了这么久还缺的是 一种方式表达，我有一连串的异步解决的值。所以我们需要一种范式 一种计算方面的模式，允许我们去描述这样的一种数据，这就是 Reactive Streams 规范的作用。Reactive Streams 规范是一些通用的底层接口，由这些组织提出 Pivotal, Netflix, Lightbend, Eclipse 基金会还有其它的。这是 4 不同的接口和一个类，给你能力。异步的数据串流，而且它们是非常非常基础的。它允许我们说 嘿 有数据进来了，除此以外并没有给你什么了。它不支持我们常用的操作，我们处理数据时期待的操作。我将它们比作数组 就像 Java 的数组，你们有多少人写代码用到数组的。大多数时候，是的，数组常常用到，对吧？通常你不会这样做的，如果我要描述一系列数字或什么的 我使用 List 或者 Set 随意吧，对吧？那会使用数据类型，因为这样处理数据方便惯用，我可以扩展它们，可以操作它们。可以流式操作，可以过滤它们之类的。所以这是非常常见的抽象，对吧？Java 数组不太好用，你们这些不看的，你们大概有二十人举手了。然后我说 “大多数时候”，大部分人放低手了。因为大部分人没有经常使用数组，我们使用更高层次的数据类型。这里也有同样的需求，对于这些响应式流。它们非常基础，作为一种基石。但我不会在生产环境只是要这些，我需要操作符，使用，组合处理流数据，更加容易，这就是 Project Reactor 的意义。Project Reactor 来自 Pivotal，它类似于 RxJava，它为你提供了这些好用的操作符。​\t\t好，我们完事了吗？可以回家了吗？还不行，当然不了，对吧？这是我们迎来另一个问题的情况，假设，只是假设出于某种原因，只是假象，好吧，好吧？我不承诺任何事情，但想象一下在一条时间线上。技术，你用着熟悉的技术。了解的并使用了很多年，几十年的，对吧？想象这些技术例如 Spring 例如 Hibernate，想象由于某种原因这些你们已经熟悉的技术。不能理解，java.util.Collection，或者是 java.util.Set，java.util.Map 之类的。假设想象一下，例如。只是假想一下，你想要映射一对多的关系，在 Hibernate 的实体里面 使用 java.util.Set 想象一下 当你这样做的时候 Hibernate 不仅抛出异常，想象一下你这样做了 Hibernate 不仅抛出异常，它实际上还渲染一个纯文本组成的竖中指，在控制台，并引起你机器的内核恐慌。帮你关机，它非常讨厌 java.util.Set，你还会继续在 Hibernate 继续用 java.util.Set 吗？如果你知道会出现这样的情况，当然不会啦，对吧？你不会弃用 Hibernate 如果你想做的是同步地阻塞，并映射对象到 JDBC 的数据结构？没有比这更好的了，那是现有最好的东西了。你不会重造 Hibernate 的轮子，你只是使用阻力最小的方式而已。如果这意味着使用其它数据类型，那就使用吧。因为那会让你可以到生产环境，最终那才是最重要的。它可以让你使用你熟悉的数据访问技术去到生产环境，所以我们有同样的需求。我想要处理的我的日常需求我希望可以构建数据访问层，能支持安全 Web 服务，还有其它的作为开发者的日常，开发交付到生产环境的东西。但我不想放弃所有那些，只是为了支持响应式类型。所以这就是 Spring 团队的第一步，在 2017 年 我们发布了，Spring 框架 5.0。5.0 是首个版本整合了，Pivotal Project 原生地，与此同时还有 Reactive Streams 规范。在此基础上我们构建了响应式 Web 运行时， 我们整合了对，Spring Data 的支持，还有 Spring Security 还有 Spring Boot 和 Spring Cloud，所以今天在 2019 年，快到 2020 年了。我们可以构建端到端的微服务系统在 Spring 的生态系统。生成项目​\t\t到 start.spring.io 生成一个 reservation-service 工程。使用 Java 13。依赖开始写代码​\t\t额，我们现在有。一个全新的项目 Spring Boot 项目。最新最好的 Java 版本，我要注释掉一些我现在还不需要的东西。我去掉这些，我不需要这些，我要注释掉。R2DBC 的依赖，并注释掉 R2DBC 本身。&lt;!--&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot.experimental&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-r2dbc&lt;/artifactId&gt;&lt;/dependency&gt;--&gt;刚开始先注释掉 r2dbc 的依赖， 即 Reactive Relational Database Connectivity，响应式关系数据库连接。我们留下，设置自动导入。现在我的选择满足了，让我们去到我们的应用。我们的应用只是一个 main 方法入口，我们应用程序的入口。只是一个全新的应用，它所作的全部只是一个普通的 Spring Boot 应用，我们所要作的是写数据到数据库。刚开始的 ReservationServiceApplication.java// 省略 import 语句@SpringBootApplicationpublic class ReservationServiceApplication { public static void main(String[] args) { SpringApplication.run(ReservationServiceApplication.class, args); }}通过创建一个实体。我要像这样地创建一个实体好吧，这个实体，这是个实体。但是需要，你懂得，需要一些常规东西。getter 和 setter， 我需要 toString 我需要 equals 和 hashCode我需要构造器等东西。还有这个OK 另一个构造器，好。好东西，对吧？我需要这些，这就是 Java，额，这非常现代！非常现代，如何现代… 我不那么做，那很糟糕！我是用 Lombok。Lombok 是一个编译时注解处理器，Lombok 使得我可以整合getter 和 setter toString, equals, hashCode 之类的。在此之上我加入 Spring Data 的 @id 注解，它会告诉 MongoDB 这个文档，这个实体，这个对象。我在这里描述的，将会被持久化到一个单独行。称之为集合，在 MongoDB 里面。在那个世界，在 MongoDB 里的叫法。一个记录被称为文档，所以这是一个文档，在一个集合中。这个文档有一个 id 字段，还有 name 字段，它们都在这里描述了。// 用于 MongoDB 的实体类@Data@AllArgsConstructor@NoArgsConstructor@Documentclass Reservation { @Id private String id; private String name;}这基本上就是我要做的，让这个能用。现在我要创建一个，repository。repository 只是一个东西，会将数据存储到数据库的东西。会处理无聊的到掉土渣的，读/写 更新/删除 的生命周期方法，支持处理我们数据的方法。这个 repository，支持所有可能的操作。在这你可以看到，所有这些常用方法，你在生产环境需要的，并将任务完成。例如 save, saveAll，count, delete, findById，检查是否存在，诸如此类的。所有这些方法我猜想，对于你们来说应该很熟悉了。// 创建数据负责数据访问的 repositoryinterface ReservationRepository extends ReactiveCrudRepository&lt;Reservation, String&gt; {}开始讲 Reactive Streams Spec一些现在还未熟悉的是，是参数的类型，第一个参数是一个 Publisher，这个 Publisher 你可以看到，来自于org.reactivestreams:reactive-streams，这是一个 Publisher，产生 0 到 n 个记录，对吧？是一个产生记录的 Publisher，异步地，不受限地，输出到一个订阅者，Subscriber。当它首次订阅，它会给一个指针到一个 Subscription，在这里看到我们有这个 Subscription。下我们再回头看这个 Subscription，稍后再看这个可以说是最重要的部分了，当数据到来的时候 1 2 3，十亿，万亿，无限的数据。当它们到达的时候，onNext 方法会被调用，是在 onNext 方法里面，我们才能，消耗并处理到达的数据流。那些来自 Publisher 的数据。如果遇到错误，当出现错误，onError 方法会被调用。就是在这个 onError 方法我们有机会，去 额…… 处理一些错误。请记住，错误。可在任何地方发生，但是堆栈追踪信息。那个 try-catch 机制，是限制在单个线程的。所以我们而是通过这个机制传播错误，因为请记住，我们的代码，会轻易地从一个线程切换到另一个线程，随着我们在响应式管道中执行代码。所以我们不能假设它们在同一个地方，所以这是非常能用的，自然的方式去处理数据。我们将错误作为另一种数据，而且这也是多线程代码中处理错误的自然方式，最后当我们处理完的数据。onComplete 方法会被调用，就是在 onComplete 方法里面我们知道。我们无异常地完成了所有事情，你懂得，没有错误。现在，让我们回到这个 onSubscribe 方法。这个我之前说了，应该是最重要的部分了。这个订阅，对于这个订阅者是唯一的，每个订阅者，当订阅到一个发布者，获得一个新的订阅。这个订阅，代表链接，联系 ，会话，可以这样想的话。存在于生产者于消费者之间的，Subscriber 和 Publisher，就是在这个订阅当中消费者或者订阅者才可以请求，更多的数据或者，另一方面，去取消，数据的产生。所以这是很重要的，订阅者通过使用订阅，控制消耗的速率。订阅者说，嘿，我在要多十个记录，然后，哇啦，如果有多十个记录的话。就会发给订阅者。但是不会给多，而且时间也不能确定，对吧？在规范里面没有提到这十个记录，会在未来一秒到达之类的。你可能在十年获得十个记录，你不知道，对吧？未来十年你可能每年得到一个记录，是没有保证的，或者你在下一纳秒就得到了十个记录。还是，没有保证的。所以你选择一个数字，那是，一个你可以想象到的。同一时间舒适地，安全地处理。或接近于同一时间，对吧？这是很重要的，有你掌控，消耗的速率。你控制发布者的速率给你数据的速率。这意味着，如果你受不了。如果你的订阅者，消费者，受不了这么多数据。那是谁的错？那是你的错。其实这还好，我宁愿你能掌控自己的命运，而不让过于积极的发布者主宰我命运，对吧？所以这给我了这种能力，它给我了数据的客户端，去管理控制流的能力，我控制数据流。这称为，客户端管理的流控制。这，绝对不是什么新概念，对吧？自从同一个网络中有一个计算机和另一个，我们就有了这个概念——流控制。确保方程的一端产生数据不会比另一端快，绝不是什么新概念，新的东西。只是，现在我们在这个概念套了一层表面 API，作为顶层的结构。这是我们可以在 API 显示地做的事情，好吧？如果我们想要取消，取消数据流。我们同样也可以 这也是很重要的，你不希望卡在一种情形，无法阻止数据太多流控制，在响应式编程的世界。有时候，多亏营销，被称为背压式。如果你有听过背压式这个词的话，你可以将其与客户端管理流控制交替使用，这就是已经存在了数十年的概念，对吧？从世界起源开始，哪个世界并不重要，在过去的 70 80 年里的任何东西 对吧？好了，现在，哈，我们有，发布者，订阅者，和订阅。那是三个，我说有四个的，第四个类型是，是 Processor，而处理器。是一个桥梁 一个水源和水槽，在订阅者与发布者之间，消费者 和…… 生产者。ok？ 就是这样，它就是一个桥梁这就是完整的 Reactive Streams 规范。早告诉你了，很简单的规范。很荒芜的没什么东西，那里边没有什么值得关心的内容的。非常简单的 API，如果你理解所有这些，就目前来说的话。我毫不怀疑你们都懂了，那么恭喜你们，你们是已认证的响应式编程人员。走，去硅谷，筹集数百万资金，炸了各种傻逼派对。你已经准备好了，你可以的了。你已经走在很多硅谷人之前了，ok ？​\t\t现在，我们有这四种类型。正如我所说，它们是非常基础的。非常原始的，够了吗？ 这些类型够了吗？我会说 额…… 不够。是吧？ 我们没有简单的方式可以，支持操作，例如支持 mapping 和 flatMapping 之类。因此，我们有特别实现。首先是 Flux，Flux 来自 Project Reactor，那是一个 Pivotal 的项目。它构建在响应式流规范的 Publisher 之上，你可看到 CorePublisher 最终是实现 Publisher。所以你可以看到 Flux说到底只是一个 Publisher。但同时它也提供了很多，很多，很多操作符，你看到吗？很多不同的东西，相信我，你不想花费太多时间在这些代码里。你会晕头转向的，所以，只需相信它做了你期望的事情。你想要做什么，OK? 这些代码支持像 map 和 flatMap 的操作。还有 filter 所有这些你需要的处理流数据的东西，Flux 是生产者。但它产生 0 到 n 个值。可能不受限的，OK ? 另一方面 Mono 也是一个发布者。它也有这些很多不同的操作符，很多很多操作符。哇！ 对吧？你可以使用很多东西，但是 Mono 最多产生一个值，0 个 或 1 个。有点像 CompletableFuture 但它支持背压式，OK？ 而且它是基于推的，区别于基于拉的 。好的，那么这就是CorePublisher 这是一个 Mono 现在我们有这两种不同的东西。问题是公平起见，为什么我使用其中一种？有人让你渲染一个用户界面，然后给你一个 Publisher&lt;Customer&gt; 你怎么知道该怎么做？如果它们给你一个Mono 发布者。那么你就知道这是单个详细记录，他们可能想让我渲染这个记录的详情。对吧，这区别于，Flux&lt;Customer&gt;那样的话，他们可能想让你渲染所有用户概况列表。对吧，其中之一现在我们有这两种不同的类型。我们可以用它们写一些样例数据到数据库，我要创建 SampleDataInitializer 它会监听一些事件，就像这样 @EvenListener，然后我们说，OK？写入数据库 MongoDB​\t\t我们要写些数据到数据库。所以 @Component 只是一个普通的 Spring Bean，在这里注入 reservationRepository 注入到构造器。我需要 @RequireArgsConstructor还有参数。定义这些数据然后我将数据写入到数据库，通过创建一些名字，好吗？所以我要过一遍，并获取一些名字，这些是在 Spring 团队的人。显然我在其中，很高兴见到你们，我是 Josh，额… 还有谁？ 我们有 Madhura 她很厉害。我们有，Mark Paluch 他也很厉害，我们还有 Olga 她也很厉害，我们还有，四个了。还要四个 我们有……Spencer 他很厉害。还有Ria 她很厉害。Stéphane 法国的不是荷兰的 虽然他也很厉害，OK 有那么一个人。额 还有，额…… 还有谁，还有谁。我说的是在 Devoxx 那位，不是那个 我觉得还有一个在我们 Spring 团队的，尽管 也欢迎他，额…… 不对，额…… 还有谁呢?，还有额 Violetta 好吧？她也很厉害 好了，现在我们有 ，所有这些不同的名字，好吧，好东西要开始了 就是这些名字。我们要做的是，我们要访问这每一个名字，我们有由名字组成的响应式流，我们要访问每一个 并将它变成。reservation 的数据流，OK 所以 reservations 就这样。我们将访问其中每一个，我想要将它们保存到数据库。我可以写 map ，我可以这样做，我可以写。然后，我这样做会怎样？额 map，返回 Mono&lt;Reservation&gt; OK。而我不想一个 Mono&lt;Reservation&gt;，因为如果我这样做，我会得到这个Flux&lt;Mono&lt;Reservation&gt;&gt; 不是很理想。而是，我想取出这个内部的发布者。我有个内部的发布者被这个，这个 Lambda 的返回值创建的。而且我想压平这个，压平它。所以我只有 Flux&lt;Mono&gt;，为了达到目的，你使用 flatMap OK？ 就像这样，你可以替换为方法引用。哇啦，这就是你的新的响应式流，好吧？@Component@RequiredArgsConstructor@Log4j2class SampleDataInitializer { private final ReservationRepository reservationRepository; // 注册一个事件监听器，应用启动就绪时调用该方法。 @EventListener(ApplicationReadyEvent.class) public void ready() { var saved = Flux .just(\"Josh\", \"Madhura\", \"Mark\", \"Olga\",\"Spencer\", \"Ria\",\"Stéphane\", \"Violetta\") .map(name -&gt; new Reservation(null, name)) .flapMap(this.reservationRepository::save); this.reservationRepository .deleteAll() // 先删除所有记录 .thenMany(saved) // 然后才写入 .thenMany(this.reservationRepository.findAll()) //然后才查找 .subscribe(log::info); // 控制台日志输出结果 }}所以，现在这是我们的数据。我要将它存到数据库里，额，我现在有了这些数据。如果我现在运行这个程序，啥都不会发生，你可以看到。这个响应式流，这是我们所说的冷的数据流，什么都还未发生。我们需要实际激活它，对吧？这有一个终端函数需要被调用，我们的终端方法就像，就像 Java 8 Streams API。所以我们说，或者我们可以提供一个消费者或者订阅者，对吧？不要提供订阅者，太多方法了。最近我使用 Consumer，对吧？非常简单，当然这可以是，Java 8 lambda。所以，哇啦。log.info OK？Log4j2，然后是 reservations，好 这可以是一个方法引用。所以 就是这样 OK？这就是所有东西，现在，我可以那样做。但在我做之前，让我们想一下会发生什么。我要运行这个程序它是 额…… 顺便设置一下。我懒，我希望我的代码也是。所以就这样，现在。我要运行这个程序，它会将一串数据。它会创建一个预约流，并会保存每一个到数据库，当我运行这个程序。多次运行 经过连续的迭代，我会看到数据库反映同样的数据，多次。那不是我想要的，我想先清理一下。所以我先删除所有东西，所以让我们写这会返回一个 Mono，那是一个异步的 Void。那么之后，不是订阅。我可以写.subscribe 但那就会很奇怪了。我会有一个嵌套的，我会有一个嵌套的回调，而不是做。嵌套的回调之类的东西，我是用操作符，将各种串联起来。一个发布者到另一个，所以我要写 saved。然后，我想写，找到数据，然后当且仅当，我才想打印日志出结果。所以我实际上，所以我实际上使用操作符去保证。所有东西都删除了，异步地加个限制。仅当它全部完成了，之后我才管保存数据，仅当那个时候。在我保存了所有东西之后，才管问数据库取数据。另一个要注意的是，正如我在这串起的管道。你也可以 ，你更经常，你会在这里串起这些东西。所以在管道的定义，让我们看一下那个代码。因此， OK。现在就是这样，完成了这部分，这就变成一个 Reservation。OK 这就是新的管道。保存数据记录的管道。额，老实说，这是正确的做法，对吧？Java 有 var 前缀了。，所以，你应该用那个，OK？​\t\t现在，额，这边。我的管道。额，你可以看到。这个，这些操作符，让使用响应式流的类型非常有用，对吧？ 而响应式流类型是，它们是 JDK 8，友好的，对吧？这并不是说必须要用 Java 8，你可以用更早的版本，对吧？顺便说一下，它们是，而且这很重要。它们是，这些等价的类。在 Java 本身里面了，自从 Java 9 开始所以你可以看到 java.util.concurrent Flow.Processor， Flow.Subscription，Flow.Subscriber 还有 Flow.Publisher这些类型被镜像到 JDK 里面了。已经超过两年了，每行都一样的，唯一不同的只是，包不同。所以当你谈论响应式流，重要的是要注意，你可能说的是 Java 9 的响应式流，或者是或者是响应式流规范本身。那个给了 Java 9 响应式流灵感的，大部分 API 例如 Reactor，支持从一种切换到另一个你可以适配。Java Flow 的 Publisher 到普通的 Publisher反之亦然，OK? 现在，让我们运行这些代码 看有什么结果。现在好了，编译。我们看看，你看看。朋友们看到吗？数据在这呢，这行得通。你可以看到这数据，已经反映出来了。在这里并显示在控制台上，这行得通，这当然行啦。因为这是个 demo 你还期待什么呢？这总是行得通的，这并没有很有趣对吗？我们可以看到那个 id 是 UUID，那与 MongoDB 里的相匹配。如果我到这里，输入 db.reservation.find({ })；然后这是数据，你可以看到，Mark Stéphane 等等。所有这些名字，都反映在数据库里。日志显式格式，不同的系统可能不一样，但内容应该差不多。在 Mongo shell 输入 db.reservation.find( { } ); 可以看到结果已经写入数据库。但并没有按照特定的顺序出现 对吧？对吧？那是因为，我们使用 flatMap，好吧? 所以 flatMap压扁了所有东西。但它这样做乱串了结果，一样东西被压扁，如果一样东西解决了。首先，在内部的发布者，那么解释的数据流 saved 可能会是乱序的。我可能有 1 2 3，但我可能得到 3 2 1。然后最后的东西被 flatMap OK? 这就是这很有趣。我们有数据在数据库，这能运行 这当然能运行啦，像我所说那样。这是 demo 肯定能跑的，这真的不是我在这里的原因。如往常一样。​\t\tOK 那么现在我们有很漂亮的纯文本艺术字，我们有很漂亮的纯文本艺术字。我们有数据在数据库里面，目前为止我使用的是 MongoDB。MongoDB 是一个不错的数据库，用于响应式处理，它有不少特性，有点有趣。我认为我已经表达的很清楚了，在响应式的世界里，例如 有些东西称为 Tailable 查询，你可以告诉MongoDB ，我想问你一个问题。我想你一直检查自己，等待一个答案，例如一个小时之后，如果有匹配问题。那么请告诉我，给我一个结果集。解释的结果与断言匹配，而不是一直在拉取数据库。我可以让 MongoDB 告诉我，这是一个很自然的事情。在响应式的世界里，嘿，在我的数据仓库里面。你说，你只需要添加 @Tailable。你可以写 我想表达一个一个查询。额，一个 finder 方法 findByName OK ? 这就能用了，你只需要，你需要确保你已经启用 MongoDB 在一个集群模式。这个我还没有设置好，所以我不演示了。但 在那之后你只需要，你可以在你的代码仓库运行这个法，然后它就会给你发送符合断言的结果，非常有用 额…… MongoDB 是个很好的体验，你可以做各种酷事情。在响应式的世界里。不过，这不是唯一的选择。我们在 Spring Data 的世界里，有很多项目现在支持响应式 NoSQL 数据访问。包含但不仅限于 MongoDB，我们有 Cassandra，有 CouchBase。我们有 Redis 这些都已经是 GA 了的响应式支持 NoSQL 选择。但更进一步，我们有 Azure Cosmos DB。现在也支持响应式数据访问了，来自微软的 微软 Azure Cosmos DB。我们有 Neo4J 2.0，对吧 新的 Rx Neo4J，Spring Data 项目。那也支持响应式NoSQL 之类的数据访问，用于那个图数据库，我们有很多选择，包括已经 GA 的和还在开发的。那正在向前看的，我们甚至有更多，除了我不太能确定可以说的。OK 这些都在出来，但是人们经常问的问题是。OK 这很好。讲完 Reactive MongoDB 之后讲 R2DBC PostgreSQL 为例​\t\t我可以做 SQL 数据访问吗？这是很多人在问的，对吧？所以你们有多少人用 MongoDB 的？OK 比我想象中的人多，你懂得。五年前，额，你们有多少人使用 Cassandra？这有 一些人 我可以给你们买啤酒都不觉得破费，额 你们有多少人用 Redis？我猜 这个估计是最受欢迎的了 嗯 是的 OK 但 仍然是 我们讨论的只是少数人 我认为没有 10% 我会说 大概 5% 对吧？所以不是很多人使用那东西，CouchBase 呢? CouchBase 好东西。啊 大概有五六个人啊。OK 你们有多少人有 SQL 存储的？在你的代码里，呀 OK 大多数人对吧？只是小的大多数 但还是大多数人所以 问题是在响应式我们怎么支持 SQL 数据访问？这是非常常见的问题，所以几年前，我们创建了 R2DBC？OK R2DBC。是…… 额 是一个抽象层，支持响应式关系数据库链接。那里有个核心的 SPI，还有数个不同的实现，有不同的驱动 如果你这样想的话。支持对像 PostgreSQL 等的访问，微软的 SQL Server 还有 H2 现在也有一个第三方项目。支持 MySQL，对吧？这里还有更多，R2DBC 实现，在路上（正在开发中），额 Mark 我们还有什么实现。那个我已经提到过了，Spanner, Google Cloud Spanner 是的，SAP Hive 所以我们也有这些进来，所以有很多正在开发。还有很多我们不能提及的，那些正在开发中的，对吧？这些是所有不同的 R2DBC 实现，R2DBC 在目前还有没有 GA。 还没有 GA 的，所以我在这一刻，在这一刻。我希望你觉得，持有像对待 PHP 一样的犹豫怀疑态度，PHP 这边是生产环境，这边是 PHP，他们不应该相遇的，OK? 不过，不过，我刚被通知，这个很快就会 GA 了，那是什么时候？我的朋友，感恩节，不是加拿大的感恩节。OK 那是更加往后的，大概在那一周后，所以这个月的下旬。十一月底，最后一个星期四。额，或者是差不多的时候，我们应该会有 GA 的，那会包含存储过程吗？没有，所以它会有 基本上。按照我的理解，它会支持大多数东西，除了存储过程。我们会让 API 稳定下来再看看那会是怎么样。在我们实现那个之前，所以你能够像 GA 的风格使用它。去做几乎所有你想做的事情，用这些 API R2DBC。现在已经可用了，你可以尝试。我们在大会上已经宣布了在华盛顿 DC，在 2018 年的时候。就是那时候我们向公众发布的。所以自我们发布到现在几乎有一年了，对吧？在此之前已经不止一年了，因为我们一直在开发它。我们知道它已经经过考验了，有经过迭代了的，而且它很有用。你总能从现今开始使用它，这就是我们已经做了的。当我在 start.spring.io，在那 Spring Initializr 我勾选了 R2DBC 这项，OK 所以我要在这里。将它放进来 放进这个，好东西。&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot.experimental&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-r2dbc&lt;/artifactId&gt;&lt;/dependency&gt;然后我要注释掉 MongoDB OK? 这会添加依赖，就这样。&lt;!--&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;/artifactId&gt;&lt;/dependency&gt;--&gt;然后在这里添加这个，然后这里我们需要重构一下代码，还有，我不想建议。通过我的做法，我的说法，你应该按某种方式写代码。然后能够从 MongoDB 迁移到 R2DBC 没意义对吧？我的代码是非常简单，要让它能够跑起来，总的来说 如果你有场景发现 MongoDB 是最适合的话，可能那个应用场景不是 R2BC 或 SQL 适合的。或者等价的替换，好吧？嗯 额…… Spring Data 的目的并不是支持这种奇葩的可移植性 OK？所以我有这代码，移除 @Document 额 我的实体 我的东西。我的记录，将会被存储在单调递增的主键，作为数据库中的主键。所以我将它从 String，也就是 UUID 支持 UUID 的改成 Integer 好吗？改完之后，我的代码又可以运行了。// R2DBC@Data@AllArgsConstructor@NoArgsConstructorclass Reservation { @Id private Integer id; private String name;}interface ReservationRepository extends ReactiveCrudRepository&lt;Reservation, Integer&gt; {}application.properties 文件内容，指定了 r2dbc 的 url，这里演示使用的是 PostgreSQL 数据库，可以替换成其它支持的关系型数据库，例如 MySQL，不过 MySQL 的 r2dbc 驱动属于第三方维护的。spring.main.lazy-initialization=truespring.r2dbc.url=r2dbc:postgres://localhost/ordersspring.r2dbc.username= [你的用户名]spring.r2dbc.password= [你的密码]我们可以再次运行这个程序，就是这样，它抱怨了，因为我没有，一个指向我的数据库的属性，我要去到我的属性文件 application.properties 然后我要指定 r2dbc url 对吧？所以 r2dbc url，而这是，这是我们之间的小秘密 OK 你不能告诉别人。这是我小小的生产环境的密码，OK？我们要，指定用户名。现在当然，你会被建议，记住你可以使用环境变量。你可以使用 Spring Cloud 配置服务器 。也可以用 Azure 配置服务器，你可以用很多方式外部化你的用户名和密码，但就我们演示目的这应该可以用，让我们再次运行这个，OK？然后这是数据，在数据库你可以看到已经反映在那了。额 在控制台。这里 我们单调递增地，增加主键也反映在数据库上，psql -Uorders orders \\d reservation 然后可以看到那个模式，有个主键 是 integer 类型 然后有一个列称为 name ，类型为 varchar 我可以敲入，来吧，好东西。OK 这也行得通，现在我们可以响应式地，我们响应式地写数据到 MongoDB 和 SQL 数据存储，那是好东西。orders=# \\d reservation 数据表 \"public.reservation\" 栏位 | 类型 | 校对规则 | 可空的 | 预设-------+-------------------+----------+----------+----------------------------------------- id | integer | | not null | nextval('reservation_id_seq'::regclass) name | character varying | | not null |索引： \"reservation_pk\" PRIMARY KEY, btree (id)然后执行 select * from reservation;orders=# select * from reservation; id | name-----+----------- 283 | Madhura 284 | Violetta 285 | Spencer 288 | Ria 282 | Stéphane 286 | Mark 287 | Olga 281 | Josh(8 行记录)演示事务操作​\t\t下一个 人们经常问的问题是，你懂得，你说得很好听。但是我还是要保证我数据的完整性的，在此背后我有这些很好的数据存储，有些东西正如我期望那样运行。而在旧的方式却不能这样期望 例如，数据的原子性如何？我如何保证当我往数据库写入十样东西，全部都写入或者全都不写入 对吧？这就是事务的应用场景，嗯 事务正如你们可能知道的，在传统的那个世界。我们基于 ThreadLocal 对吧？你创建… 有代码，保存与当前线程相关联的 ThreadLocal 那个 ThreadLocal 存储你的事务的状态，当前正在进行的事务，而 ThreadLocal。在当前线程的任何地方都可以解决，你只需请求，通常只是，通常是某个东西。在框架里面 例如 Spring 会为你做这事。它们一直追踪那个 ThreadLocal，并在线程结束的时候清除掉它，并在 ThreadLocal 安装当前事务。当一个新事务开始，那个机制，用于这方面很久了。而那个机制最终是被，PlatformTransactionManager 解决。这只是一个非常简单的接口，给你三个选项，给我一个事务 给我一个定义，提交事务或者回滚，这种抽象允许我们。可以抽象大部分不同的 API。很多不同的 API，都有它们自己相应的资源本地事务。问题是所有这些都假设 ThreadLocal，所有都基于一种概念，那会有一种存储机制附着在当前线程，我可以在往后任意时间解决它。那是非常不好的假设。尤其是在响应式的世界里，对吧？在响应式的世界里，我们不能保证，请求会从一个线程开始 并保持在那个线程，在整个事务的生命周期。所以 而是，我们需要其它东西，所以在 Spring 框架 5.2.x，那是刚刚发布的。我们正在使用的 已经 GA 了，在 Spring 5.2.x，我们发布了一个 ReactiveTransactionManager所以就算这边的这个东西。而那个 ReactiveTransactionManager 也是继承于 TransactionManager 的，对吧 它们都只是标记性接口。额 它继承了那个接口，并且它有对应的响应式。就如你所见的在 PlatformTransactionManager 里面的。包括给我一个当前的事务。或给我一个新的事务提交事务还有回滚，OK? 这个 ReactiveTransactionManager，允许我们做事务的包裹，以熟悉的方式。让我们创建一个 @service 在这里我们添加 ReservationService 而这个服务会让我们可以写数据到数据库里，给定的一系列的数据流的名字。这是变长参数的名字数组，所以为了这样做，我要注入我们的 ReservationRepository ，正如往常一样。让它是 @RequireArgsConstructor 就会合成了。由 Lombok 合成，所以我想从那里获取数据 所以 Flux.fromArray… OK? 这是我的 String 类型的发布者，我将取其中的每一个我要 map 每个名字都 Reservation 里面，我们在创建某些方面我们之前就有了东西。这是一系列的已经 map 了的数据，我要写 对于它们每一个 我要 flatMap 每个记录。存入到数据库里面，这它传入进去。额 这会给我，我想要验证每一个，我想要写。reservatoin.doOnEach(... OK 我写 doOnNext(… 所以对于每个 reservation 我想要断言测试一下它，我想要判断它，每个记录都有一个有效的名字，给定一个 reservation，返回 true 或 false 如果那个名字是由大写字母开始的，getName().charAt(… 0… 然后我要写，然后我断言判断它应该是一个大写字母，如果不是的话 我想让它失败。测试，好吗？所以我们应该这样做，doOnNext(… 传入 r 然后 the name … OK? 哇啦 这是我已更新了的管道。额 很明显你可以将这些都串联起来。就像我这样 我想做这样的事情串联起来那样我更容易读。即使我想将它拆开看看正在发生什么事情，然后就是这样，这是已经更新的代码，现在我们有了一个管道基本上是跟之前一样的。问题是，我首先读入数据。然后再当且仅当这样我才做验证，更加重要的是。如果我写两个记录的话会怎样，或者是十个、五个 随意吧。然后第三个记录有个小写的名字，我真的想写入前面两个记录吗？ 可能我更希望那是原子性的对吧？这取决于你 额是，风格选择问我我觉得 但是，让我们假设我真的想要原子性操作，我想要保证要么？全部名字都写入，或者全部都不写入，为了支持这个 我是用了这个新的 ReactiveTransactionManager 支持。所以我能够创建一个，ReactiveTransactionManager 实例，像这样然后这个需要，这里边有很多不同的实现，顺便说一下。我们有 ReactiveTransactionManager 的实现，在 额 R2DBC 给我也给 MongoDB 实现了，还有 Neo4J， 对吧 我确信还有一些我忘记了的至少目前有这些，return new … 注入来自 R2DBC 的连接工厂然后 我们想创建一个 TransactionalOperator，好吗？而这个 ，transactionalOperator 需要 ReactiveTransactionManager 才能干活。所以我们创建那个，然后 哇啦 OK？所以这是我们的事务管理者，嗯 就是这些东西。现在，我想要做的是，是我想要使用那个 TransactionalOperator 例如 private final TransactionalOperator 然后我会写this.transactionalOperator... 然后我将整个管道，放到这个事务分区里边，使用这个 transactionalOperator所以 再次，所有东西在 transactional 里边的，在里面的整个发布者。会在一个事务当中。不在这里边的不会在一个事务里，对吧？我可以用另一种方式，写 @EnableTransactionalManagament对吧？然后只需要，只要返回的是一个发布者。我只需要用 @Transactional，在这个例子中 它们是一样效果的TransactionalOperator很好如果你想要更细粒度的事务控制。什么需要事务控制 而什么不需要，所以现在然我们重写这里的代码使用那个支持事务的服务，这里 private final … 好吗，然后。我要写 this.reservationService... 好吗？哇啦，这是我们的服务 这是我们要写入数据库的数据。额……这会是支持事务的，所以我要写数据到数据库，支持事务地。但我要删除所有在那个事务之外的东西然后我要读取数据。在事务之外，所以这个，这行可能会显示 0 或 10，我们不清楚 或者 8 实际上这是我们有的 8 个记录。所以这只是，让我们将，Mark 的名字 暂时地 只是暂时地。我们会将 Mark 的名字改成小写，而他是操作中的第三个记录，对吧？所以现在，让我们返回到数据库这边 delete from reservation，对吧？现在里边什么都没有了 OK？现在再次运行这个代码，这些只是日志。/** * 一个服务，事务地往数据库写入数据。 */@Service@RequiredArgsConstructorclass ReservationService { private final ReservationRepository reservationRepository; private final TransactionalOperator transactionalOperator; Flux&lt;Reservation&gt; saveAll(String... names) { return this.transactionalOperator // 在这个操作符里面是事务。 .transactional( Flux .fromArray(names) .map(name -&gt; new Reservation(null, name)) .flatMap(this.reservationRepository::save) .doOnNext(r -&gt; Assert.isTrue(isValid(r), \"名字首字母必须大写！\"))); } // 一个断言，用于上面 Assert.isTrue() private boolean isValid(Reservation r) { // 判断首字母是否为大写 return Character.isUpperCase(r.getName().charAt(0)); }}上面的代码启用了事务，所以需要定义两个 bean/*** 配置响应式事务管理** @param cf 连接工厂* @return 返回 R2dbcTransactionManager*/@Bean(\"r2dbc\")ReactiveTransactionManager reactiveTransactionManager( @Qualifier(\"connectionFactory\") ConnectionFactory cf) { return new R2dbcTransactionManager(cf);}// 事务操作符@BeanTransactionalOperator transactionalOperator( @Qualifier(\"r2dbc\") ReactiveTransactionManager transactionManager) { return TransactionalOperator.create(transactionManager);}之后应用启动时写入数据的代码改为：@Component@RequiredArgsConstructor@Log4j2class SampleDataInitializer { private final ReservationRepository reservationRepository; private final ReservationService reservationService; @EventListener(ApplicationReadyEvent.class) public void ready() { var saved = this.reservationService.saveAll(\"Josh\", \"Madhura\", \"Mark\", \"Olga\",\"Spencer\", \"Ria\", \"Stéphane\", \"Violetta\"); this.reservationRepository .deleteAll() .thenMany(saved) .thenMany(this.reservationRepository.findAll()) .subscribe(log::info); }}如果将上面的人名字，某个首字母改为小写，则事务不通过，回滚，不会写入数据。反映了这里有异常，但是这个应用没事能运行。额 现在数据库里什么都没有 OK？如果我恢复这个，大写字母，我们会看到全部 8 个，噢 就是这些。所以这里有数据 我们事务地。写入数据到数据库，正如我们期望的那样。OK 顺便问下 你们有注意到，这需要更多时间编译吗？相对比应用启动运行时间而言，对吧？我们目前所做的好处是，这是非常快，对吧？那么，我的大多数运行时间，你可以看到，少到 0.9 秒左右。额 ……这是有帮助的 顺便提一下 我还跑着 Chrome 呢。即便如此 我还能获得那样的速度。可以想象到在生产环境会是怎样吗？肯定会更加好，OK 那么现在，我有这个事务分区，我将数据写入到了数据库。HTTP 端点​\t\t额，我想是时候写一个 HTTP API 了。OK 下一件事就是写一个简单 HTTP 服务，我们写 @RestController这是非常常见的东西，毫无疑问的肯定见过了 RestController 所以你可以写 Reservation… ReservationController 就像这样。你可以在这里注入它，可以写 private final … OK ? 我将一个 我要将它添加为，构造器注入依赖 使用 @RequiredArgsConstructor 然后我创建一个简单端点，Reservation 的发布者然后我要读取所有数据，我写 this…，reservationRepository.findAll(… 重启一下，，运行了吗？ 是的 跑起来了，所以 localhost:8080/reservations，这是我们的数据，好吗？这啥牛逼的，你以前就见过了 一点都不牛逼非常简单 只是一个 RestController 返回一个发布者，这是很重要的，。所以，尽管这看起来像 Spring MVC然后你可能会觉得熟悉，如果你使用 Spring MVC，这个并不是 Spring MVC，这里边没有 Servlet API 在 classpath 对吧 我甚至都没有使用 Servlet API 这是全新的 Reactive Web 运行时，基于 Netty 的。从底层开始构建起来支持我们这里想做的，好吗？所以，我们这里有响应式支持，而有些东西表面上是非常相似的 例如那些注解。将会感觉非常熟悉，其中不同的是 我们实际上返回 额。发布者 Spring MVC 控制器的返回值。典型的是用于构造会被客户端渲染的响应的东西，这个实际上不是这样做的 是吗？这个它本身就是一个响应了，这是一个东西 WebFlux 这个框架，可以用来到达结果的东西，两者是不同的 它们之间的区别是很重要的，它给了一个我们可以用的。然后得到结果的结果，但不是同样的东西，所以这次进入到了问题。// 典型的类似 Web MVC 的路由配置方式@RestController@RequiredArgsConstructorclass ReservationRestController { private final ReservationRepository reservationRepository; @GetMapping(\"/reservations\") Flux&lt;Reservation&gt; reservationFlux() { return reservationRepository.findAll(); }}可以使用以下风格：// 函数式路由配置，作为 MVC 风格路由配置的一种替换选择。@BeanRouterFunction&lt;ServerResponse&gt; routers(ReservationRepository rr) { return route()\t\t.GET(\"/reservations\", request -&gt; ok().body(rr.findAll(), Reservation.class))\t\t.build();}​\t\tOK 如果我想要一些东西一直活着，在一个管道的生命周期之内一直存活着。我应该怎样做？我如何附着某物到生命周期超越这东西的，记住我们不能使用 ThreadLocal 对吧？ThreadLocal 现在用不了啦，你可以看到 我们解决了事务的问题，就在几分钟前，我们可以做的方式是 如果你想做的话。是我们可以访问一个称为 context 的东西，OK 你可以创建一个订阅者上下文。而 context 是在底层支持的，我们的能力取附着一个例如，额 事务附着到目前的管道。不管那个管道是在哪个线程执行的，这是一个可以支持我们做分布式跟踪的东西，去持续画出沿着不同线程的路线，那是可以允许我们做，安全扩散的，你可以在数个不同线程间传播认证信息，你可以创建一个与管道有关的上下文。就像这样，所以我在这里做的是，创建一个 context，以一个键和值，分别等于 a 和 b 的，对吧？它可以一直可见，在这个管道之中 我可以访问这个上下文？我的代码的任意地方 我可以写，doOn… 例如 …Each… 然后我给个信号 从每个信号，我可以获取到当前的上下文。例如我可以打日志输出它，所以你自己可以做各种事情。你可以自己管理那种机制，但除此之外 这仍然是，一个 Spring MVC 风格的控制器而已。我喜欢这种风格。考虑到这只是一个简单的例子，我想要发起一个 HTTP GET 请求，然后想它返回 Reservation，就是这样而已 然而我一整个类和构造器。还有注解 方法之类的东西，只是为了支持那一个 HTTP 端点。额 你可能更喜欢这种替换的风格。称之为函数式响应式端点，在 Spring 5 及其后版本可用。所以我们支持它已经超过两年了，所以 routes。return … 好吗？.GET(… 所以我正在做的是 我创建一个 Bean 在这个 Bean 里面。我定义一个函数式响应式路由。而我将它注入作为数据仓库的协作对象，我写 …findAll(), Reservation.class… 然后 哇啦 OK？就是这样子，我将使用 static import 然后这就是我整个 HTTP 端点 这只是一行 我说的是，让…… 当某人，对/reservations 发起请求时。那么指派这个 Lambda 去干活，还有就是这是构建者方法，所以我实际上可以将这些串联起来，我可以做 .DELETE 我可以做… PUT 还有 POST 等所有这些东西。我可以编程地添加这些东西，我可以使用条件语句 while 循环之类 随意玩。去随意添加这些端点，所以 取决于你偏好的风格，但它们功能上来说是一样的。它们做的是同样的事情 OK？所以让我们重新运行这个程序，然后看一下我们会得到什么我？ 嗯 可以了OK 就是这样。这就是数据，OK？现在我们有了一个可用的响应式 HTTP 端点，我们有 额……我们有 R2DBC 我们看到我们可以写 SQL 到数据库。额 当然这是一种非常常见的自然的事情，我们有这些非常…… 额…… 简单 易实现的用例对吧？我想写数据到 SQL 数据存储，然后我想从 HTTP 端点读取它们。然后问题当然是，那又怎样？我以前就可以这样做了，我并不需要响应式去从数据库读取 8 个记录。然后将它暴露为 JSON 对吗？这在以前做起来也不难 为什么今天我要这样做。演示 WebSocket 实时发送消息到网页​\t\t这是个好问题。所以真实的用例 真实地使得，响应式编程如何迷人的。是它带来的能力和机遇，用于一些可能会独占线程的事情。那么有什么例子，什么会独占一个线程？在一个典型的应用架构我们会怎么做？可能会让一个线程一直开着。嗯 每当你需要客户端与服务器通信的时候。然后客户端想要活动地持续地更新，自是很自然的候选者。去让一个线程持续地打开，像服务端发送事件之类的。例如 WebSocket 然后这些协议支持的使用场景是什么？它们支持的使用场景必须要，持续地更新。例如，聊天 Presence 还有股票动态，这类型使用场景需要一直接入的，OK？那么让我们创建，一个服务会产生，数据的一个永不停息的数据流。OK 我们将创建一个 WebSocket 端点。那会响应一系列 WebSocket 数据流 一系列“问候”的数据流当某如需要一个“问候” 给定一个“问候”请求， 我们将要产生数据流。作为问候的响应 好吗？request OK 然后。@service 将这个类型放到这里 class将这个类型放到这里，这里。好，那个请求只是有，name 它的详细内容只是包含一个名字。然后响应会有，问候消息它本身。OK ? 现在当然是 @Data 哇 这是什么 @Data @AllArgsConstructor @NoArgsConstructor 好东西。好东西 现在。我们要做的是，当某人请求一个“问候”。我们会返回一个不间断的数据流，new Greeting … Request 额 不好意思 是 response Hello OK? 所以这将会是不间断的数据流，现在 那是一个不间断的数据流。让我们用这个替换它，然后用 Lambda 替代。然后我们也调用 delayElements… 我要写我想要延迟它 1 秒 所以每一秒我都要产生一个新的值 现在留意下我刚才做了什么。我引入了，一个永不间断的数据流，它将会产生新的响应，一直都会，那个数据流会。会很快地滚动下来很快占满控制台，我们不看看到终结的，所以我通过使用 delayElements 分散下结果。我可以这样，我可以在这里改变时间是因为，是因为在 Reactor 背后我们所做的一切。里边都有个调度器，通常你不会注意到它存在。你也不需要知道它存在，但它一直都在那里，那个调度器。就是允许我们控制，执行的动向，从一个线程无缝的切换到另一个线程。你不需要担忧这个，调度器。处理两件事。处理调度任务，然后它处理多线程，它实际… 它有点像个线程池，加上一个定时器 你可以这样想。OK ? 额 这是我们放进 Reactor 里的抽象。通常你不需要担忧这个，但是默认情况下。一个线程占一个 CUP 核，好吗？所以你有每个线程一个核，在默认的应用程序，这意味着，如果你是在一个机器。你只有四个核 那你就只有四个线程，所以非常重要，你不阻塞这些线程。如果你使用响应式代码，那么你不能阻塞。对吧？额 在这里你有调度器如果你觉得需要的话，如果你需要重写调度器的话，如果你需要做一些事。那会阻塞的话，非常重要的是，你处理好。额，将那个任务，放到一个不同的调度器。所以 Schedulers… 额…… elastic() … 或者是 fromExecutor(…你懂得像这样，你提供你自己的 Executors。随你所想 对吧？很重要的是，你要处理好重写调度器，那某个管道的使用。要么 subscribeOn 或者是 publishOn 对吧？我通常使用 subscribeOn但如果你有一个生产者它会如果你有消费者比生产者更慢的话。你可以使用 publishOn 对吧？嗯 喔 这是这被认为是代码臭味我认为那会是代码臭味。如果你发现要经常这样做，如果你有代码在你的代码库里是阻塞的，与阻塞资源之间的交互，然后你要扩展开那个交互，通过添加更多线程的办法，这样是我们尝试使用响应式编程的初衷。我们想要的是，你懂得 不阻塞。我们想从中获益的，是在系统高效地复用线程。如果你只能通过增加线程扩展的话，有的问题了。你应该能找到那个代码，而且一点点，隔绝并从你的代码中移除。为帮助你做这样的事情，我们创建了称为 blockhound 的东西。是一个 Java 代理，你可以用它来检测，不阻塞线程的阻塞调用。你只需将它添加到 classpath然后只需运行 BlockHound.install()在你的 public static void main(… 方法里 在你启动 Spring Boot 之前，OK ？额这样做了之后，如果你干些傻事 例如 Thread.sleep() 或计算斐波那契数列，不管什么 额。你会得到这个阻塞的调用。对吧 这个阻塞的异常，它会抛出异常 帮助你知道那里有错误。就那么简单，然后你可以好好调试或者，将其隔离，或者至少处理好。将它放到它自己的调度器，这响应式的世界里这要做很重要。请记住 如果你有四个核心 你有四个线程。如果你阻塞了其中一个线程，那不只是一个请求，那是你 25% 的用户，对吧？ 你通常可能使用 PHP。去解决那样的问题 不 不要那样做。做正确的事情OK ? 那么，我们有一个调度器，你可以使用它 如果你想的话。那个调度器，是一个允许我们，像这样做事情。我们可以增加时间，时间是我们的 API 的一个维度这是响应式编程的一种好处。我们现在可以想象世界，真的作为一系列的时间 时间里一系列的事件，那么现在我们那样做了。让我们创建一个请求，额 WebSocket 端点 OK？Websocket … 好吧 …Configuration 然后我们会在这创建一些 Beans 那个 WebSocketHandleerAdapter 这是一个东西。我们需要去告诉 Spring，去查找 WebSocket 支持，对吧？我们需要那个 WebSocketHandler 本身，然后这里边是我们的业务逻辑，等会我们再回头看看这个这个是业务逻辑。然后我们实际上需要告诉，Spring 去装载我们的，WebSocket 端点。到一个 HTTP URL，我们需要这样做的原因是，额 WebSocket 是一个二进制协议。但当 WebSocket 客户端连接到服务器的时候，它会升级到二进制协议，所以它先是连接到 HTTP，然后有握手 接着协议升级，我们需要告诉框架。嘿 映射这个端点这个 HTTP 端点，到这个二进制协议OK? 所以我要写 Map.of… /ws/greetings 然后我要给它一个引用到 WebSocketHandler 它会延迟操作 对吧 我要给… 我要给这个特定的 URL 一个排序 只是为了确保它 确保它排在其它 URL 之前 OK 那么现在 这是我的 WebSocketHandler 这是业务逻辑所在的地方 条约很简单 当请求进来的时候我们获得一个指向当前 WebSocket Session 的指针，而正是在那个 WebSocket Session 我们才可以。做一些像询问传入的数据，那么什么是传入的数据，在这个例子当中，那将会是一个“问候”请求，将会是 String 类型的 name。我们可以将它变成一个问候请求，然后调用服务得到一系列的响应，再发送回给 WebSocket 客户端，所以我们将会说 嘿。给我们一个数据流，的 WebSocket 消息。接收当中的每一个，就像这样 获取载荷作为文本就像这样 map 这里边的文本。这些是名字实际情况只是会有一个名字，你知道的我们这里有个发布者 map 每一个名字。到 GreetingRequest就像这样 OK？greetingRequestFlux 然后将当中的每一个，然后我们会将它变成对服务的一个调用。然后我们注入刚刚创建的“问候服务”到这里。就像这样 gs.greet( gr … 然后我们将要创建一个“问候响应” 现在对于其中每一个响应我想要将它转换成 WebSocket 消息 我可以返回给客户端，我们将要写receive… 额 我们要写 greetingResponseFlux… OK？这些是 String 类型的名字，我要将它变成 WebSocket 的消息。通过写 txt… 将它变成这样 这是我的 WebSocket 信息数据流 我只需要写 session.send(… map1这就是整个管道。很显然我不想让它这样子折叠起来成为一个容易理解的数据流 OK？所以你可以看到默认情况下我使用 map 除非我有其它东西会产生一个发布者。那样的话我会使用 flatMap 额 还有就是这样 这就是整个序列所以 receive 当然这整个接口是函数式接口 所以这是它的 lambda 形式，OK?// 配置 WebSocketHandler 初始写法@BeanWebSocketHandler webSocketHandler(GreetingService greetingService) { return new WebSocketHandler() { @Override public Mono&lt;Void&gt; handle(WebSocketSession webSocketSession) { Flux&lt;WebSocketMessage&gt; receive = webSocketSession.receive(); Flux&lt;String&gt; names = receive.map(WebSocketMessage::getPayloadAsText); Flux&lt;GreetingRequest&gt; greetingRequestFlux = names.map(GreetingRequest::new); Flux&lt;GreetingResponse&gt; greetingResponseFlux = greetingRequestFlux.flatMap(greetingService::greet); Flux&lt;String&gt; map = greetingResponseFlux.map(GreetingResponse::getMessage); Flux&lt;WebSocketMessage&gt; map1 = map.map(webSocketSession::textMessage); return webSocketSession.send(map1); } };}变成// 配置 WebSocket@BeanWebSocketHandler webSocketHandler(GreetingService greetingService) { return session -&gt; { var receive = session .receive() .map(WebSocketMessage::getPayloadAsText) .map(GreetingRequest::new) .flatMap(greetingService::greet) .map(GreetingResponse::getMessage) .map(session::textMessage); return session.send(receive); };}这个配置类是这样@Configurationclass GreetingWebsocketConfiguration {// 配置 WebSocket@BeanWebSocketHandler webSocketHandler(GreetingService greetingService) { return session -&gt; { var receive = session .receive() .map(WebSocketMessage::getPayloadAsText) .map(GreetingRequest::new) .flatMap(greetingService::greet) .map(GreetingResponse::getMessage) .map(session::textMessage); return session.send(receive); };}// 处理 URL 升级@BeanSimpleUrlHandlerMapping simpleUrlHandlerMapping(WebSocketHandler webSocketHandler) { return new SimpleUrlHandlerMapping(Map.of(\"/ws/greetings\", webSocketHandler), 10);}// 配置 WebSocket@BeanWebSocketHandlerAdapter webSocketHandlerAdapter() { return new WebSocketHandlerAdapter();}}现在，我有一个 WebSocketHandler 这是一个 Bean 我在配置类里边配置的这是一个 WebSocket 端点 这东西能用但我想 我要给你们演示这个 现在我的朋友们 我有点 有点尴尬 我们这边有点问题不幸的是我要给你们演示这个然而我想不到做这事的更加优雅的方式了我想不到一个好的方式去做我想做的事情 但我必须做这件事 为了做这件事额…… 我会觉得不自在 对吧 我们是朋友啊 我觉得…… 这会破坏我们之间的信任如果我这样做 但我想不到更好的方式了 而我通常不会在体面的公司里做这样的事情 OK 如果我能避免的话 如果我可以找到其它方式 去做我想做的事那么当然我会 哎…… 我要写 JavaScript OK？好 那么 window.addEventListener… OK 这些代码 OK 不好意思 是 … ws/greetings … 对吧 就是这样 然后 当 Socket 打开的时候 然后我可以开始跟它交互了 我要做的是 我要获取 Socket 我要发送请求 我只是写 Devoxx Belgium OK? 好了吗？然后当数据进来的时候我要加载这些资源所以我要构造请求 这是我们要发送的名字 实际上我们不需要在 Belgium 后加叹号当那个消息返回的时候我们有 onMessage 回调 所以写 function … … msg … 我将结果打印到这里 所以 console.log(… 然后我们重启应用 OK 噢 是这个 就是这样我的朋友们。JavaScript 代码：&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;body&gt;&lt;script&gt; window.addEventListener('load', function (ev) { const ws = new WebSocket('ws://localhost:8080/ws/greetings'); ws.addEventListener('open', function (ev1) { ws.send('Devoxx Belgium') }); ws.addEventListener('message', function (msg) { console.log('new message: ' + msg.data); }); })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;每一秒钟 至往后无限它会产生新的结果。它会一直有…… 继续有…… 有……永远 直到永远…… 永远…… 永远…… 它不会结束的 它是无终结的 就像海洋…… 亦如星空……还有你代码中的 bug无穷的，无尽的 我们朋友们 那没关系好吗 那没关系 因为 我们要做的是 是在雨滴之间 在这些消息发送给客户端的过程 那个线程释放了 某物 某人在系统中之后可以使用那个线程 去做更多的事情 这是真正的好处。响应式编程带来的进步，并不是我们让每个事务更加快，是我们这样做所以。处理更加多的事务，这就是真正的胜利。对吧 做个简单的计算。这个完全算不上是真实的性能测试，但在这里使用简单数字做例子。这里的目标是用一半的硬件成本去处理。同样多的事务，对吧？或者去处理，一半…… 额一样数量的事务，或者是两倍数量的事务，以同样的硬件。对吧？那并不是要使得每个特定的事务更加快，记得吗 因为线程切换，那可能会更慢一点。但目标是你可以用同样的硬件做得更多，你更高效地使用了这个系统，所以我的朋友们 我们已经看了如何构建一个服务，在这边谈论了一些不同的东西。我们构建了一个简单服务。在下一节，我们会讲构建一个客户端。那将会带我们进入到恐怖的微服务，当你有一个服务于另一个服务通信的时候会发生什么？在那一节我们会讨论像网关 HTTP 适配器 网关之类的。API 适配器 HTTP 客户端 你懂的。我们会用 Kotlin 写，那会是在第二节。" }, { "title": "Effective Java 条款1", "url": "/2019/11/17/effective-java-item1-notes/", "categories": "", "tags": "Effective Java, Best Practices", "date": "2019-11-17 10:50:00 +0800", "snippet": "ITEM 1: Consider static factory methods instead of constructors属于 “创建和销毁对象” 那章。静态工厂方法跟“四人帮”设计模式里面的工厂方法模式是不同的。静态工厂方法的好处 有名称，容易读。 静态工厂方法不一定每次都创建新实例。有点类似享元模式（Flyweight pattern)。如果创建对象代价比较大，使用静态工厂方法可以提高性能。这种类被称为实例受控（instance-controlled）类。可以确保单例（singleton）或不被实例化。还有让值不可变类（immutable value class）保存没有两个相等的实例存在。 可返回任意子类的对象。 静态工厂方法返回的对象可以因调用参数不同而不同。 返回的对象可以先不存在，这就是 service provider framework 的基础，例如 Java Database Connectivity API (JDBC). 服务提供者框架的三个主要组件：服务接口（service interface），代表实现。服务提供者注册接口（provider registration API），用于注册服务的实现。服务访问接口（service access API），客户端用来获取服务实例的方式。以 JDBC 为例子，Connection 就是服务接口， DriverManager.registerDriver 是服务提供者注册接口， DriverManager.getConnection 是服务访问接口，然后 Driver 是服务提供者接口。 静态工厂方法的缺点 只提供私有静态工厂方法（没有 public 或 protected 构造器）的类不能被继承（派生），不过有时候是好事，因为鼓励使用组合而不是继承。 比较难找，因为不想构造器那样出现在 java doc。一些静态工厂方法的例子： from —— 一种类型转换方法，取一个参数并返回此类型对应的实例，例如： Data d = Date.from(instant); of —— 一种聚集方法，取多个参数，返回此类型的实例，整合了这些参数的值，例如： Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING); valueOf —— 更详尽版本的 of ，例如： BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE); instance 或 getInstance —— 返回参数描述的实例，但不一定得到同样的值。例如： StackWalker luke = StackWalker.getInstance(options); create 或 newInstance —— 像前一个，但是保证每次都返回新实例。例如： Object newArray = Array.newInstance(classObject, arrayLen); getType —— 像 getInstance 但是在不同类里面，Type 是静态工厂方法返回的对象类型，例如： FileStore fs = Files.getFileStore(path); newType —— 像 newInstance 但是在不同类里面，Type 是静态工厂方法返回的对象类型，例如： BufferedReader br = Files.newBufferedReader(path); type —— getType 和 newType 的更精简替换，例如： List&lt;Complaint&gt; litany = Collections.list(legacyLitany); 总结通常使用静态工厂方法更好，所以可以考虑一下，而不是只想到公有构造器。" }, { "title": "Java 并发", "url": "/2019/11/15/concurrency/", "categories": "", "tags": "Java, OCP", "date": "2019-11-15 14:03:00 +0800", "snippet": "Concurrency 并发Synchronized 语句块package synchronizing;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class SheepManager {\t\tprivate int sheepCount = 0;\t\t// private void incrementAndReport() {\tprivate void incrementAndReport() {\t\tsynchronized(this) { System.out.print((++sheepCount)+\" \"); }\t}\tpublic static void main(String[] args) {\t\tExecutorService service = null;\t\ttry {\t\t\tservice = Executors.newFixedThreadPool(20);\t\t\t\t\t\tSheepManager manager = new SheepManager();\t\t\tfor(int i = 0; i &lt; 10; i++) \t\t\t\tservice.submit(()-&gt; manager.incrementAndReport());\t\t\t} finally {\t\t\t\tif (service != null) service.shutdown();\t\t\t}\t}}使用 Monitor 或称为 Lock，使用 synchronized 的时候，注意🔒的对象是那个。保证同步，就要去要锁同一个对象。并发集合类 类名称 接口 元素有序？ 可排序？ 阻塞？ ConcurrentHashMap ConcurrentMap No No No ConcurrentLinkedDeque Deque Yes No No ConcurrentLinkedQueue Queue Yes No No ConcurrentSkipListMap ConcurrentMap, SortedMap, NavigableMap Yes Yes No ConcurrentSkipListSet SortedSet, NavigableSet Yes Yes No CopyOnWriteArrayList List Yes No No CopyOnWriteArraySet Set Yes No No LinkedBlockingDeque BlockingQueue, BlockingDeque Yes No Yes LinkedBlockingQueue BlockingQueue Yes No Yes Understanding CopyOnWrite CollectionsList&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;(Arrays.asList(4,3,52));for (Integer item: list) {\tSystem.out.print(item+\" \");\tlist.add(9);}System.out.println();System.out.println(\"Size: \"+list.size());" }, { "title": "升级到 Java SE 11 开发者考试大纲", "url": "/2019/11/14/upgrade-ocp-java-8-to-java-se-11-exam-review-topics/", "categories": "", "tags": "Java 11, OCP", "date": "2019-11-14 14:03:00 +0800", "snippet": "升级到 Java SE 11 开发者考试大纲Understanding Modules Describe the Modular JDK Declare modules and enable access between modules Describe how a modular project is compiled and runMigration to a Modular Application Migrate the application developed using a Java version prior to SE 9 to SE 11 including top-down and bottom-up migration, splitting a Java SE 8 application into modules for migration Use jdeps to determine dependencies and identify way to address the cyclic dependenciesServices in a Modular Application Describe the components of Services including directives Design a service type, load the services using ServiceLoader, check for dependencies of the services including consumer module and provider moduleLocal-Variable Type Inference Use local-variable type inference Create and use lambda expressions with local-variable type inferred parametersJava Interfaces Create and use methods in interfaces Define and write functional interfacesLambda Expressions Create and use lambda expressions Use lambda expressions and method references Use built-in functional interfaces including Predicate, Consumer, Function, and Supplier Use primitive and binary variations of base interfaces of java.util.function packageLambda Operations on Streams Extract stream data using map, peek and flatMap methods Search stream data using search findFirst, findAny, anyMatch, allMatch and noneMatch methods Use the Optional class Perform calculations using count, max, min, average and sum stream operations Sort a collection using lambda expressions Use Collectors with streams, including the groupingBy and partitioningBy operationParallel Streams Develop the code that use parallel streams Implement decomposition and reduction with streamsJava File I/O (NIO.2) Use Path interface to operate on file and directory paths Use Files class to check, delete, copy or move a file or directory Use Stream API with FilesLanguage Enhancements Use try-with-resources construct Develop code that handles multiple Exception types in a single catch block" }, { "title": "Java 多线程编程", "url": "/2019/11/07/java-multithreading/", "categories": "", "tags": "Java, Multithreading", "date": "2019-11-07 01:12:00 +0800", "snippet": "多线程编程Java 的线程模型线程的优先级线程同步问题线程的消息机制Thread 类 和 Runnable 接口主线程// Controlling the main Thread.class CurrentThreadDemo { public static void main(String args[]) { Thread t = Thread.currentThread(); System.out.println(\"Current thread: \" + t); // change the name of the thread t.setName(\"My Thread\"); System.out.println(\"After name change: \" + t); try { for(int n = 5; n &gt; 0; n--) { System.out.println(n); Thread.sleep(1000); } } catch (InterruptedException e) { System.out.println(\"Main thread interrupted\"); } }}创建一个线程实现 Runnable 接口// Create a second thread.class NewThread implements Runnable { Thread t; NewThread() { // Create a new, second thread t = new Thread(this, \"Demo Thread\"); System.out.println(\"Child thread: \" + t); t.start(); // Start the thread } // This is the entry point for the second thread. public void run() { try { for(int i = 5; i &gt; 0; i--) { System.out.println(\"Child Thread: \" + i); Thread.sleep(500); } } catch (InterruptedException e) { System.out.println(\"Child interrupted.\"); } System.out.println(\"Exiting child thread.\"); }}class ThreadDemo { public static void main(String args[]) { new NewThread(); // create a new thread try { for(int i = 5; i &gt; 0; i--) { System.out.println(\"Main Thread: \" + i); Thread.sleep(1000); } } catch (InterruptedException e) { System.out.println(\"Main thread interrupted.\"); } System.out.println(\"Main thread exiting.\"); }}继承 Thread 类// Create a second thread by extending Threadclass NewThread extends Thread { NewThread() { // Create a new, second thread super(\"Demo Thread\"); System.out.println(\"Child thread: \" + this); start(); // Start the thread } // This is the entry point for the second thread. public void run() { try { for(int i = 5; i &gt; 0; i--) { System.out.println(\"Child Thread: \" + i); Thread.sleep(500); } } catch (InterruptedException e) { System.out.println(\"Child interrupted.\"); } System.out.println(\"Exiting child thread.\"); }}class ExtendThread { public static void main(String args[]) { new NewThread(); // create a new thread try { for(int i = 5; i &gt; 0; i--) { System.out.println(\"Main Thread: \" + i); Thread.sleep(1000); } } catch (InterruptedException e) { System.out.println(\"Main thread interrupted.\"); } System.out.println(\"Main thread exiting.\"); }}该用哪种方式？创建多个线程// Create multiple threads.class NewThread implements Runnable { String name; // name of thread Thread t; NewThread(String threadname) { name = threadname; t = new Thread(this, name); System.out.println(\"New thread: \" + t); t.start(); // Start the thread } // This is the entry point for thread. public void run() { try { for(int i = 5; i &gt; 0; i--) { System.out.println(name + \": \" + i); Thread.sleep(1000); } } catch (InterruptedException e) { System.out.println(name + \"Interrupted\"); } System.out.println(name + \" exiting.\"); }}class MultiThreadDemo { public static void main(String args[]) { new NewThread(\"One\"); // start threads new NewThread(\"Two\"); new NewThread(\"Three\"); try { // wait for other threads to end Thread.sleep(10000); } catch (InterruptedException e) { System.out.println(\"Main thread Interrupted\"); } System.out.println(\"Main thread exiting.\"); }}使用 isAlive() 和 join()// Using join() to wait for threads to finish.class NewThread implements Runnable { String name; // name of thread Thread t; NewThread(String threadname) { name = threadname; t = new Thread(this, name); System.out.println(\"New thread: \" + t); t.start(); // Start the thread } // This is the entry point for thread. public void run() { try { for(int i = 5; i &gt; 0; i--) { System.out.println(name + \": \" + i); Thread.sleep(1000); } } catch (InterruptedException e) { System.out.println(name + \" interrupted.\"); } System.out.println(name + \" exiting.\"); }}class DemoJoin { public static void main(String args[]) { NewThread ob1 = new NewThread(\"One\"); NewThread ob2 = new NewThread(\"Two\"); NewThread ob3 = new NewThread(\"Three\"); System.out.println(\"Thread One is alive: \" + ob1.t.isAlive()); System.out.println(\"Thread Two is alive: \" + ob2.t.isAlive()); System.out.println(\"Thread Three is alive: \" + ob3.t.isAlive()); // wait for threads to finish try { System.out.println(\"Waiting for threads to finish.\"); ob1.t.join(); ob2.t.join(); ob3.t.join(); } catch (InterruptedException e) { System.out.println(\"Main thread Interrupted\"); } System.out.println(\"Thread One is alive: \" + ob1.t.isAlive()); System.out.println(\"Thread Two is alive: \" + ob2.t.isAlive()); System.out.println(\"Thread Three is alive: \" + ob3.t.isAlive()); System.out.println(\"Main thread exiting.\"); }}线程优先级线程同步使用同步的方法// This program is not synchronized.class Callme { void call(String msg) { System.out.print(\"[\" + msg); try { Thread.sleep(1000); } catch(InterruptedException e) { System.out.println(\"Interrupted\"); } System.out.println(\"]\"); }}class Caller implements Runnable { String msg; Callme target; Thread t; public Caller(Callme targ, String s) { target = targ; msg = s; t = new Thread(this); t.start(); } public void run() { target.call(msg); }}class Synch { public static void main(String args[]) { Callme target = new Callme(); Caller ob1 = new Caller(target, \"Hello\"); Caller ob2 = new Caller(target, \"Synchronized\"); Caller ob3 = new Caller(target, \"World\"); // wait for threads to end try { ob1.t.join(); ob2.t.join(); ob3.t.join(); } catch(InterruptedException e) { System.out.println(\"Interrupted\"); } }}同步语句// This program uses a synchronized block.class Callme { void call(String msg) { System.out.print(\"[\" + msg); try { Thread.sleep(1000); } catch (InterruptedException e) { System.out.println(\"Interrupted\"); } System.out.println(\"]\"); }}class Caller implements Runnable { String msg; Callme target; Thread t; public Caller(Callme targ, String s) { target = targ; msg = s; t = new Thread(this); t.start(); } // synchronize calls to call() public void run() { synchronized(target) { // synchronized block target.call(msg); } }}class Synch1 { public static void main(String args[]) { Callme target = new Callme(); Caller ob1 = new Caller(target, \"Hello\"); Caller ob2 = new Caller(target, \"Synchronized\"); Caller ob3 = new Caller(target, \"World\"); // wait for threads to end try { ob1.t.join(); ob2.t.join(); ob3.t.join(); } catch(InterruptedException e) { System.out.println(\"Interrupted\"); } }}线程间通信// An incorrect implementation of a producer and consumer.class Q { int n; synchronized int get() { System.out.println(\"Got: \" + n); return n; } synchronized void put(int n) { this.n = n; System.out.println(\"Put: \" + n); }}class Producer implements Runnable { Q q; Producer(Q q) { this.q = q; new Thread(this, \"Producer\").start(); } public void run() { int i = 0; while(true) { q.put(i++); } }}class Consumer implements Runnable { Q q; Consumer(Q q) { this.q = q; new Thread(this, \"Consumer\").start(); } public void run() { while(true) { q.get(); } }}class PC { public static void main(String args[]) { Q q = new Q(); new Producer(q); new Consumer(q); System.out.println(\"Press Control-C to stop.\"); }}生产者与消费者的正确玩法// A correct implementation of a producer and consumer.class Q { int n; boolean valueSet = false; synchronized int get() { while(!valueSet) try { wait(); } catch(InterruptedException e) { System.out.println(\"InterruptedException caught\"); } System.out.println(\"Got: \" + n); valueSet = false; notify(); return n; } synchronized void put(int n) { while(valueSet) try { wait(); } catch(InterruptedException e) { System.out.println(\"InterruptedException caught\"); } this.n = n; valueSet = true; System.out.println(\"Put: \" + n); notify(); }}class Producer implements Runnable { Q q; Producer(Q q) { this.q = q; new Thread(this, \"Producer\").start(); } public void run() { int i = 0; while(true) { q.put(i++); } }}class Consumer implements Runnable { Q q; Consumer(Q q) { this.q = q; new Thread(this, \"Consumer\").start(); } public void run() { while(true) { q.get(); } }}class PCFixed { public static void main(String args[]) { Q q = new Q(); new Producer(q); new Consumer(q); System.out.println(\"Press Control-C to stop.\"); }}死锁// An example of deadlock.class A { synchronized void foo(B b) { String name = Thread.currentThread().getName(); System.out.println(name + \" entered A.foo\"); try { Thread.sleep(1000); } catch(Exception e) { System.out.println(\"A Interrupted\"); } System.out.println(name + \" trying to call B.last()\"); b.last(); } synchronized void last() { System.out.println(\"Inside A.last\"); }}class B { synchronized void bar(A a) { String name = Thread.currentThread().getName(); System.out.println(name + \" entered B.bar\"); try { Thread.sleep(1000); } catch(Exception e) { System.out.println(\"B Interrupted\"); } System.out.println(name + \" trying to call A.last()\"); a.last(); } synchronized void last() { System.out.println(\"Inside A.last\"); }}class Deadlock implements Runnable { A a = new A(); B b = new B(); Deadlock() { Thread.currentThread().setName(\"MainThread\"); Thread t = new Thread(this, \"RacingThread\"); t.start(); a.foo(b); // get lock on a in this thread. System.out.println(\"Back in main thread\"); } public void run() { b.bar(a); // get lock on b in other thread. System.out.println(\"Back in other thread\"); } public static void main(String args[]) { new Deadlock(); }}线程的挂起，恢复和停止// Suspending and resuming a thread for Java 2class NewThread implements Runnable { String name; // name of thread Thread t; boolean suspendFlag; NewThread(String threadname) { name = threadname; t = new Thread(this, name); System.out.println(\"New thread: \" + t); suspendFlag = false; t.start(); // Start the thread } // This is the entry point for thread. public void run() { try { for(int i = 15; i &gt; 0; i--) { System.out.println(name + \": \" + i); Thread.sleep(200); synchronized(this) { while(suspendFlag) { wait(); } } } } catch (InterruptedException e) { System.out.println(name + \" interrupted.\"); } System.out.println(name + \" exiting.\"); } synchronized void mysuspend() { suspendFlag = true; } synchronized void myresume() { suspendFlag = false; notify(); }}class SuspendResume { public static void main(String args[]) { NewThread ob1 = new NewThread(\"One\"); NewThread ob2 = new NewThread(\"Two\"); try { Thread.sleep(1000); ob1.mysuspend(); System.out.println(\"Suspending thread One\"); Thread.sleep(1000); ob1.myresume(); System.out.println(\"Resuming thread One\"); ob2.mysuspend(); System.out.println(\"Suspending thread Two\"); Thread.sleep(1000); ob2.myresume(); System.out.println(\"Resuming thread Two\"); } catch (InterruptedException e) { System.out.println(\"Main thread Interrupted\"); } // wait for threads to finish try { System.out.println(\"Waiting for threads to finish.\"); ob1.t.join(); ob2.t.join(); } catch (InterruptedException e) { System.out.println(\"Main thread Interrupted\"); } System.out.println(\"Main thread exiting.\"); }}获取一个线程的状态使用多线程编程" }, { "title": "Java Lambda 表达式", "url": "/2019/11/06/java-lambda-revisited/", "categories": "", "tags": "Java, Lambda", "date": "2019-11-06 06:21:00 +0800", "snippet": "Lambda ExpressionsIntroducing Lambda ExpressionsLambda Expression 基础函数式接口一些函数表达式例子演示一个简单的 Lambda 表达式// Demonstrate a simple lambda expression. // A functional interface. interface MyNumber { double getValue(); }使用 Lambda 表达式 class LambdaDemo { public static void main(String args[]) { MyNumber myNum; // declare an interface reference // Here, the lambda expression is simply a constant expression. // When it is assigned to myNum, a class instance is // constructed in which the lambda expression provides an override // of the getValue() method in MyNumber. myNum = () -&gt; 123.45; // Call getValue(), which is overridden by the previously assigned // lambda expression. System.out.println(\"A fixed value: \" + myNum.getValue()); // Here, a more complex expression is used. myNum = () -&gt; Math.random() * 100; // These call the lambda expression in the previous line. System.out.println(\"A random value: \" + myNum.getValue()); System.out.println(\"Another random value: \" + myNum.getValue()); // A lambda expression must be compatible with the method // defined by the functional interface. Therefore, this won't work: // myNum = () -&gt; \"123.03\"; // Error! } }另一个lambda demo// Another functional interface. interface NumericTest { boolean test(int n); } 演示使用class LambdaDemo2 { public static void main(String args[]) { // A lambda expression that tests if a number is even. NumericTest isEven = (n) -&gt; (n % 2)==0; if(isEven.test(10)) System.out.println(\"10 is even\"); if(!isEven.test(9)) System.out.println(\"9 is not even\"); // Now, use a lambda expression that tests if a number // is non-negative. NumericTest isNonNeg = (n) -&gt; n &gt;= 0; if(isNonNeg.test(1)) System.out.println(\"1 is non-negative\"); if(!isNonNeg.test(-1)) System.out.println(\"-1 is negative\"); } 演示需要两个参数的 lambda// Demonstrate a lambda expression that takes two parameters. interface NumericTest2 { boolean test(int n, int d); } class LambdaDemo3 { public static void main(String args[]) { // This lambda expression determines if one number is // a factor of another. NumericTest2 isFactor = (n, d) -&gt; (n % d) == 0; if(isFactor.test(10, 2)) System.out.println(\"2 is a factor of 10\"); if(!isFactor.test(10, 3)) System.out.println(\"3 is not a factor of 10\"); } }语句块函数表达式演示快语句的函数表达式// A block lambda that computes the factorial of an int value. interface NumericFunc { int func(int n); } class BlockLambdaDemo { public static void main(String args[]) { // This block lambda computes the factorial of an int value. NumericFunc factorial = (n) -&gt; { int result = 1; for(int i=1; i &lt;= n; i++) result = i * result; return result; }; System.out.println(\"The factoral of 3 is \" + factorial.func(3)); System.out.println(\"The factoral of 5 is \" + factorial.func(5)); } }反转字符串的函数表达式// A block lambda that reverses the characters in a string. interface StringFunc { String func(String n); } class BlockLambdaDemo2 { public static void main(String args[]) { // This block lambda that reverses the charactrers in a string. StringFunc reverse = (str) -&gt; { String result = \"\"; int i; for(i = str.length()-1; i &gt;= 0; i--) result += str.charAt(i); return result; }; System.out.println(\"Lambda reversed is \" + reverse.func(\"Lambda\")); System.out.println(\"Expression reversed is \" + reverse.func(\"Expression\")); } }泛型函数式接口泛型化的函数式接口// Use a generic functional interface with lambda expressions. // A generic functional interface. interface SomeFunc&lt;T&gt; { T func(T t); } class GenericFunctionalInterfaceDemo { public static void main(String args[]) { // Use a String-based version of SomeFunc. SomeFunc&lt;String&gt; reverse = (str) -&gt; { String result = \"\"; int i; for(i = str.length()-1; i &gt;= 0; i--) result += str.charAt(i); return result; }; System.out.println(\"Lambda reversed is \" + reverse.func(\"Lambda\")); System.out.println(\"Expression reversed is \" + reverse.func(\"Expression\")); // Now, use an Integer-based version of SomeFunc. SomeFunc&lt;Integer&gt; factorial = (n) -&gt; { int result = 1; for(int i=1; i &lt;= n; i++) result = i * result; return result; }; System.out.println(\"The factoral of 3 is \" + factorial.func(3)); System.out.println(\"The factoral of 5 is \" + factorial.func(5)); } }函数表达式作为参数传递函数做参数// Use lambda expressions as an argument to a method. interface StringFunc { String func(String n); } class LambdasAsArgumentsDemo { // This method has a functional interface as the type of // its first parameter. Thus, it can be passed a reference to // any instance of that interface, including the instance created // by a lambda expression. // The second parameter specifies the string to operate on. static String stringOp(StringFunc sf, String s) { return sf.func(s); } public static void main(String args[]) { String inStr = \"Lambdas add power to Java\"; String outStr; System.out.println(\"Here is input string: \" + inStr); // Here, a simple expression lambda that uppercases a string // is passed to stringOp( ). outStr = stringOp((str) -&gt; str.toUpperCase(), inStr); System.out.println(\"The string in uppercase: \" + outStr); // This passes a block lambda that removes spaces. outStr = stringOp((str) -&gt; { String result = \"\"; int i; for(i = 0; i &lt; str.length(); i++) if(str.charAt(i) != ' ') result += str.charAt(i); return result; }, inStr); System.out.println(\"The string with spaces removed: \" + outStr); // Of course, it is also possible to pass a StringFunc instance // created by an earlier lambda expression. For example, // after this declaration executes, reverse refers to a // synthetic instance of StringFunc. StringFunc reverse = (str) -&gt; { String result = \"\"; int i; for(i = str.length()-1; i &gt;= 0; i--) result += str.charAt(i); return result; }; // Now, reverse can be passed as the first parameter to stringOp() // since it refers to a StringFunc object. System.out.println(\"The string reversed: \" + stringOp(reverse, inStr)); } }函数表达式与异常关于函数表达式与异常处理// Throw an exception from a lambda expression. interface DoubleNumericArrayFunc { double func(double[] n) throws EmptyArrayException; } class EmptyArrayException extends Exception { EmptyArrayException() { super(\"Array Empty\"); } } class LambdaExceptionDemo { public static void main(String args[]) throws EmptyArrayException { double[] values = { 1.0, 2.0, 3.0, 4.0 }; // This block lambda computes the average of an array of doubles. DoubleNumericArrayFunc average = (n) -&gt; { double sum = 0; if(n.length == 0) throw new EmptyArrayException(); for(int i=0; i &lt; n.length; i++) sum += n[i]; return sum / n.length; }; System.out.println(\"The average is \" + average.func(values)); // This causes an exception to be thrown. System.out.println(\"The average is \" + average.func(new double[0])); } }函数表达式与变量捕获variable captureeffective finalLambda 可以访问包围它的方法的局部变量，也可以使用 this ，但是不可以修改局部变量，没有自己的 this// An example of capturing a local variable from the enclosing scope.interface MyFunc { int func(int n);}class VarCapture { public static void main(String[] args) { // A local variable that can be captured. int num = 10; MyFunc myLambda = (n) -&gt; { // This use of num is OK. It does not modify num. int v = num + n; // However, the following is illegal because it attempts // to modify the value of num. // num++; return v; }; // The following line would also cause an error, because // it would remove the effectively final status from num. // num = 9; }}方法引用引用静态方法// Demonstrate a method reference for a static method. // A functional interface for string operations. interface StringFunc { String func(String n); } // This class defines a static method called strReverse(). class MyStringOps { // A static method that reverses a string. static String strReverse(String str) { String result = \"\"; int i; for(i = str.length()-1; i &gt;= 0; i--) result += str.charAt(i); return result; } } class MethodRefDemo { // This method has a functional interface as the type of // its first parameter. Thus, it can be passed any instance // of that interface, including a method reference. static String stringOp(StringFunc sf, String s) { return sf.func(s); } public static void main(String args[]) { String inStr = \"Lambdas add power to Java\"; String outStr; // Here, a method reference to strReverse is passed to stringOp(). outStr = stringOp(MyStringOps::strReverse, inStr); System.out.println(\"Original string: \" + inStr); System.out.println(\"String reversed: \" + outStr); } }引用实例方法// Demonstrate a method reference to an instance method // A functional interface for string operations. interface StringFunc { String func(String n); } // Now, this class defines an instance method called strReverse(). class MyStringOps { String strReverse(String str) { String result = \"\"; int i; for(i = str.length()-1; i &gt;= 0; i--) result += str.charAt(i); return result; } } class MethodRefDemo2 { // This method has a functional interface as the type of // its first parameter. Thus, it can be passed any instance // of that interface, including method references. static String stringOp(StringFunc sf, String s) { return sf.func(s); } public static void main(String args[]) { String inStr = \"Lambdas add power to Java\"; String outStr; // Create a MyStringOps object. MyStringOps strOps = new MyStringOps( ); // Now, a method reference to the instance method strReverse // is passed to stringOp(). outStr = stringOp(strOps::strReverse, inStr); System.out.println(\"Original string: \" + inStr); System.out.println(\"String reversed: \" + outStr); } }另一个例子// Use an instance method reference with different objects. // A functional interface that takes two reference arguments // and returns a boolean result. interface MyFunc&lt;T&gt; { boolean func(T v1, T v2); } // A class that stores the temperature high for a day. class HighTemp { private int hTemp; HighTemp(int ht) { hTemp = ht; } // Return true if the invoking HighTemp object has the same // temperature as ht2. boolean sameTemp(HighTemp ht2) { return hTemp == ht2.hTemp; } // Return true if the invoking HighTemp object has a temperature // that is less than ht2. boolean lessThanTemp(HighTemp ht2) { return hTemp &lt; ht2.hTemp; } } class InstanceMethWithObjectRefDemo { // A method that returns the number of occurences // of an object for which some criteria, as specified by // the MyFunc parameter, is true. static &lt;T&gt; int counter(T[] vals, MyFunc&lt;T&gt; f, T v) { int count = 0; for(int i=0; i &lt; vals.length; i++) if(f.func(vals[i], v)) count++; return count; } public static void main(String args[]) { int count; // Create an array of HighTemp objects. HighTemp[] weekDayHighs = { new HighTemp(89), new HighTemp(82), new HighTemp(90), new HighTemp(89), new HighTemp(89), new HighTemp(91), new HighTemp(84), new HighTemp(83) }; // Use counter() with arrays of the class HighTemp. // Notice that a reference to the instance method // sameTemp() is passed as the second argument. count = counter(weekDayHighs, HighTemp::sameTemp, new HighTemp(89)); System.out.println(count + \" days had a high of 89\"); // Now, create and use another array of HighTemp objects. HighTemp[] weekDayHighs2 = { new HighTemp(32), new HighTemp(12), new HighTemp(24), new HighTemp(19), new HighTemp(18), new HighTemp(12), new HighTemp(-1), new HighTemp(13) }; count = counter(weekDayHighs2, HighTemp::sameTemp, new HighTemp(12)); System.out.println(count + \" days had a high of 12\"); // Now, use lessThanTemp() to find days when temperature was less // that a specified value. count = counter(weekDayHighs, HighTemp::lessThanTemp, new HighTemp(89)); System.out.println(count + \" days had a high less than 89\"); count = counter(weekDayHighs2, HighTemp::lessThanTemp, new HighTemp(19)); System.out.println(count + \" days had a high of less than 19\"); } }泛型方法引用// Demonstrate a method reference to a generic method // declared inside a non-generic class. // A functional interface that operates on an array // and a value, and returns an int result. interface MyFunc&lt;T&gt; { int func(T[] vals, T v); } // This class defines a method called countMatching() that // returns the number of items in an array that are equal // to a specified value. Notice that countMatching() // is generic, but MyArrayOps is not. class MyArrayOps { static &lt;T&gt; int countMatching(T[] vals, T v) { int count = 0; for(int i=0; i &lt; vals.length; i++) if(vals[i] == v) count++; return count; } } class GenericMethodRefDemo { // This method has the MyFunc functional interface as the // type of its first parameter. The other two parameters // receive an array and a value, both of type T. static &lt;T&gt; int myOp(MyFunc&lt;T&gt; f, T[] vals, T v) { return f.func(vals, v); } public static void main(String args[]) { Integer[] vals = { 1, 2, 3, 4, 2 ,3, 4, 4, 5 }; String[] strs = { \"One\", \"Two\", \"Three\", \"Two\" }; int count; count = myOp(MyArrayOps::&lt;Integer&gt;countMatching, vals, 4); System.out.println(\"vals contains \" + count + \" 4s\"); count = myOp(MyArrayOps::&lt;String&gt;countMatching, strs, \"Two\"); System.out.println(\"strs contains \" + count + \" Twos\"); } }另一个例子// Use a method reference to help find the maximum value in a collection. import java.util.*; class MyClass { private int val; MyClass(int v) { val = v; } int getVal() { return val; } } class UseMethodRef { // A compare() method compatible with the one defined by Comparator&lt;T&gt;. static int compareMC(MyClass a, MyClass b) { return a.getVal() - b.getVal(); } public static void main(String args[]) { ArrayList&lt;MyClass&gt; al = new ArrayList&lt;MyClass&gt;(); al.add(new MyClass(1)); al.add(new MyClass(4)); al.add(new MyClass(2)); al.add(new MyClass(9)); al.add(new MyClass(3)); al.add(new MyClass(7)); // Find the maximum value in al using the compareMC() method. MyClass maxValObj = Collections.max(al, UseMethodRef::compareMC); System.out.println(\"Maximum value is: \" + maxValObj.getVal()); } }构造器引用例子// Demonstrate a Constructor reference. // MyFunc is a functional interface whose method returns // a MyClass reference. interface MyFunc { MyClass func(int n); } class MyClass { private int val; // This constructor takes an argument. MyClass(int v) { val = v; } // This is the default constructor. MyClass() { val = 0; } // ... int getVal() { return val; }; } class ConstructorRefDemo { public static void main(String args[]) { // Create a reference to the MyClass constructor. // Because func() in MyFunc takes an argument, new // refers to the parameterized constructor in MyClass, // not the default constructor. MyFunc myClassCons = MyClass::new; // Create an instance of MyClass via that constructor reference. MyClass mc = myClassCons.func(100); // Use the instance of MyClass just created. System.out.println(\"val in mc is \" + mc.getVal( )); } }涉及泛型的构造器引用// Demonstrate a constructor reference with a generic class. // MyFunc is now a generic functional interface. interface MyFunc&lt;T&gt; { MyClass&lt;T&gt; func(T n); } class MyClass&lt;T&gt; { private T val; // A constructor that takes an argument. MyClass(T v) { val = v; } // This is the default constructor. MyClass( ) { val = null; } // ... T getVal() { return val; }; } class ConstructorRefDemo2 { public static void main(String args[]) { // Create a reference to the MyClass&lt;T&gt; constructor. MyFunc&lt;Integer&gt; myClassCons = MyClass&lt;Integer&gt;::new; // Create an instance of MyClass&lt;T&gt; via that constructor reference. MyClass&lt;Integer&gt; mc = myClassCons.func(100); // Use the instance of MyClass&lt;T&gt; just created. System.out.println(\"val in mc is \" + mc.getVal( )); } }使用构造器引用创建类工厂// Implement a simple class factory using a constructor reference. interface MyFunc&lt;R, T&gt; { R func(T n); } // A simple generic class. class MyClass&lt;T&gt; { private T val; // A constructor that takes an argument. MyClass(T v) { val = v; } // The default constructor. This constructor // is NOT used by this program. MyClass() { val = null; } // ... T getVal() { return val; }; } // A simple, non-generic class. class MyClass2 { String str; // A constructor that takes an argument. MyClass2(String s) { str = s; } // The default constructor. This // constructor is NOT used by this program. MyClass2() { str = \"\"; } // ... String getVal() { return str; }; } class ConstructorRefDemo3 { // A factory method for class objects. The class must // have a constructor that takes one parameter of type T. // R specifies the type of object being created. static &lt;R,T&gt; R myClassFactory(MyFunc&lt;R, T&gt; cons, T v) { return cons.func(v); } public static void main(String args[]) { // Create a reference to a MyClass constructor. // In this case, new refers to the constructor that // takes an argument. MyFunc&lt;MyClass&lt;Double&gt;, Double&gt; myClassCons = MyClass&lt;Double&gt;::new; // Create an instance of MyClass by use of the factory method. MyClass&lt;Double&gt; mc = myClassFactory(myClassCons, 100.1); // Use the instance of MyClass just created. System.out.println(\"val in mc is \" + mc.getVal( )); // Now, create a different class by use of myClassFactory(). MyFunc&lt;MyClass2, String&gt; myClassCons2 = MyClass2::new; // Create an instance of MyClass2 by use of the factory method. MyClass2 mc2 = myClassFactory(myClassCons2, \"Lambda\"); // Use the instance of MyClass just created. System.out.println(\"str in mc2 is \" + mc2.getVal( )); } }预定义的函数式接口内置的函数式接口// Use the Function built-in functional interface. // Import the Function interface. import java.util.function.Function; class UseFunctionInterfaceDemo { public static void main(String args[]) { // This block lambda computes the factorial of an int value. // This time, Function is the functional interface. Function&lt;Integer, Integer&gt; factorial = (n) -&gt; { int result = 1; for(int i=1; i &lt;= n; i++) result = i * result; return result; }; System.out.println(\"The factoral of 3 is \" + factorial.apply(3)); System.out.println(\"The factoral of 5 is \" + factorial.apply(5)); } }" }, { "title": "Java 泛型回顾", "url": "/2019/11/04/java-generic-revisited/", "categories": "", "tags": "Java, Generics", "date": "2019-11-04 23:40:00 +0800", "snippet": "GenericsJDK 1.5 版本开始引入，加强了类型安全（Type safety），强化了语言本身，更加强化了集合框架（Collections Framework）。Java 8 开始加入 Lambda、Stream 更加进一步增强了语言的表达能力。什么是泛型？泛型（Generics）意思是参数化类型（Parameterized types）。泛型允许在创建类、接口和方法的时候，以提供参数的形式指定其能操作的数据类型。它的对象是类、接口、方法。这三者都可以泛型化。在没有泛型特性之前，可以通过 Object 类实现泛型编程，但是不能保证类型安全。简单的泛型例子// 一个简单的泛型例子// T 是类型参数// 在创建Gen对象的时候 T 会被实际类型代替。class Gen&lt;T&gt; { T ob; // 声明一个类型为 T 的对象 // 给构造器传递一个对类型为 T 的引用 Gen(T o) { ob = o; } // 返回 ob T getob() { return ob; } // 显示 T 的类型 void showType() { System.out.println(\"Type of T is \" + ob.getClass().getName()); } } 演示操作泛型// 演示使用泛型class GenDemo { public static void main(String args[]) { // 创建一个实际类型为 Integer 的 Gen 引用 Gen&lt;Integer&gt; iOb; // 创建一个 Gen&lt;Integer&gt; 对象并将其引用赋值给 iOb // 注意 88 自动装箱成一个 Integer 对象。 iOb = new Gen&lt;Integer&gt;(88); // 显示 iOb 的数据类型 iOb.showType(); // 获取 iOb 的值。 // 注意不需要类型转换。 int v = iOb.getob(); System.out.println(\"value: \" + v); System.out.println(); // 创建一个实际类型为 String 的 Gen 对象 Gen&lt;String&gt; strOb = new Gen&lt;String&gt;(\"Generics Test\"); // 显示 strOb 使用的数据类型 strOb.showType(); // 获取 strOb 的值。 // 注意不需要类型转换。 String str = strOb.getob(); System.out.println(\"value: \" + str); } }泛型只适用于引用类型泛型不能用于基本数据类型 ，只能用于引用类型，因此以下声明是错误的：Gen&lt;int&gt; intOb = new Gen&lt;int&gt;(53); // 错误，不能使用基本数据类型。可以使用基本数据类型对应的封装类型，如 Integer。泛型因类型参数不同而异不同类型参数的同一个泛型是不兼容的类型，例如，就上面展示的代码而言，以下这行代码是错误的，不能通过编译：iOb = strOb; // 错误，不能编译，类型不兼容。虽然 iOb 和 strOb 都是 Gen&lt;T&gt; 类型，但两者的实际引用类型因为它们的类型参数不同而不同。iOb 实际引用的类型为 Integer ，strOb 实际引用的类型为 String。所以泛型增加了类型安全，防止错误。泛型如何增强类型安全泛型为什么能增强类型安全？上面的代码实际上不使用泛型也可以实现同样的效果，只需要将引用类型声明为 Object 类型，并添加相应的类型转换操作即可。那么使用泛型究竟有什么好处？答案是泛型机制会自动保证与 Gen 相关的所有操作都是类型安全的，无需手动进行类型转换和类型检查。可以看以下没有使用泛型的，实现了同样功能的代码：// NonGen 功能上等价于 Gen // 但是没有使用泛型 class NonGen { Object ob; // ob 现在是 Object 类型 // 给构造器传递一个对类型为 Object 的引用 NonGen(Object o) { ob = o; } // 返回类型为 Object Object getob() { return ob; } // 显示 ob 的类型 void showType() { System.out.println(\"Type of ob is \" + ob.getClass().getName()); } } 演示没用使用泛型的情况：// 演示没有使用泛型的情况class NonGenDemo { public static void main(String args[]) { NonGen iOb; // 创建一个 NonGen 对象引用并存放一个 Integer 对象 // 自动装箱 iOb = new NonGen(88); // 显示 iOb 的数据类型 iOb.showType(); // 获取 iOb 的值 // 这次类型转换是必要的。 int v = (Integer) iOb.getob(); System.out.println(\"value: \" + v); System.out.println(); // 创建另一个 NonGen 引用并存放一个 String 对象 NonGen strOb = new NonGen(\"Non-Generics Test\"); // 显示 strOb 的数据类型 strOb.showType(); // 获取 strOb 的值 // 再次注意到，类型转换是必要的。 String str = (String) strOb.getob(); System.out.println(\"value: \" + str); // 可以通过编译，但是概念上来说是错误的！ iOb = strOb; v = (Integer) iOb.getob(); // 运行时错误！ } }不使用泛型的情况，Java 编译器无法知道 NonGen 引用的实际类型，这是很糟糕的，因为： 必须要显示地进行类型转换才能获取到存储的数据。 很多类型不兼容的错误只能在运行时才能被发现。总的来说，通过使用泛型，运行时错误被转化成了编译时错误。含两个参数的泛型// A simple generic class with two type // parameters: T and V. class TwoGen&lt;T, V&gt; { T ob1; V ob2; // Pass the constructor a reference to // an object of type T. TwoGen(T o1, V o2) { ob1 = o1; ob2 = o2; } // Show types of T and V. void showTypes() { System.out.println(\"Type of T is \" + ob1.getClass().getName()); System.out.println(\"Type of V is \" + ob2.getClass().getName()); } T getob1() { return ob1; } V getob2() { return ob2; } }演示两个类型参数的泛型// Demonstrate TwoGen. class SimpGen { public static void main(String args[]) { TwoGen&lt;Integer, String&gt; tgObj = new TwoGen&lt;Integer, String&gt;(88, \"Generics\"); // Show the types. tgObj.showTypes(); // Obtain and show values. int v = tgObj.getob1(); System.out.println(\"value: \" + v); String str = tgObj.getob2(); System.out.println(\"value: \" + str); } }泛型类的一般形式class class-name&lt;type-param-list&gt;{ //...}class-name&lt;type-arg-list&gt; var-name = new class-name&lt;type-arg-list&gt;(cons-arg-list)范围受限类型// Stats attempts (unsuccessfully) to // create a generic class that can compute // the average of an array of numbers of // any given type. // // The class contains an error! class Stats&lt;T&gt; { T[] nums; // nums is an array of type T // Pass the constructor a reference to // an array of type T. Stats(T[] o) { nums = o; } // Return type double in all cases. double average() { double sum = 0.0; for(int i=0; i &lt; nums.length; i++) sum += nums[i].doubleValue(); // Error!!! return sum / nums.length; } }numeric types 才有 doubleValue() 方法。解决上面的问题，可以使用 bounded types，范围受限的类型。语法： &lt;T extends superclass&gt;修改为：// In this version of Stats, the type argument for // T must be either Number, or a class derived // from Number. class Stats&lt;T extends Number&gt; { T[] nums; // array of Number or subclass // Pass the constructor a reference to // an array of type Number or subclass. Stats(T[] o) { nums = o; } // Return type double in all cases. double average() { double sum = 0.0; for(int i=0; i &lt; nums.length; i++) sum += nums[i].doubleValue(); return sum / nums.length; } } 演示使用受限类型：// Demonstrate Stats. class BoundsDemo { public static void main(String args[]) { Integer inums[] = { 1, 2, 3, 4, 5 }; Stats&lt;Integer&gt; iob = new Stats&lt;Integer&gt;(inums); double v = iob.average(); System.out.println(\"iob average is \" + v); Double dnums[] = { 1.1, 2.2, 3.3, 4.4, 5.5 }; Stats&lt;Double&gt; dob = new Stats&lt;Double&gt;(dnums); double w = dob.average(); System.out.println(\"dob average is \" + w); // This won't compile because String is not a // subclass of Number. // String strs[] = { \"1\", \"2\", \"3\", \"4\", \"5\" }; // Stats&lt;String&gt; strob = new Stats&lt;String&gt;(strs); // double x = strob.average(); // System.out.println(\"strob average is \" + v); } }涉及到类或接口，或多个接口的时候，使用 &amp; 操作符将它们连接起来，例如：class Gen&lt;T extends MyClass &amp; MyInterface&gt; { //... }使用通配符参数// Use a wildcard. class Stats&lt;T extends Number&gt; { T[] nums; // array of Number or subclass // Pass the constructor a reference to // an array of type Number or subclass. Stats(T[] o) { nums = o; } // Return type double in all cases. double average() { double sum = 0.0; for(int i=0; i &lt; nums.length; i++) sum += nums[i].doubleValue(); return sum / nums.length; } // Determine if two averages are the same. // Notice the use of the wildcard. boolean sameAvg(Stats&lt;?&gt; ob) { if(average() == ob.average()) return true; return false; } }演示使用通配符// Demonstrate wildcard. class WildcardDemo { public static void main(String args[]) { Integer inums[] = { 1, 2, 3, 4, 5 }; Stats&lt;Integer&gt; iob = new Stats&lt;Integer&gt;(inums); double v = iob.average(); System.out.println(\"iob average is \" + v); Double dnums[] = { 1.1, 2.2, 3.3, 4.4, 5.5 }; Stats&lt;Double&gt; dob = new Stats&lt;Double&gt;(dnums); double w = dob.average(); System.out.println(\"dob average is \" + w); Float fnums[] = { 1.0F, 2.0F, 3.0F, 4.0F, 5.0F }; Stats&lt;Float&gt; fob = new Stats&lt;Float&gt;(fnums); double x = fob.average(); System.out.println(\"fob average is \" + x); // See which arrays have same average. System.out.print(\"Averages of iob and dob \"); if(iob.sameAvg(dob)) System.out.println(\"are the same.\"); else System.out.println(\"differ.\"); System.out.print(\"Averages of iob and fob \"); if(iob.sameAvg(fob)) System.out.println(\"are the same.\"); else System.out.println(\"differ.\"); } }范围受限通配符// Bounded Wildcard arguments. // Two-dimensional coordinates. class TwoD { int x, y; TwoD(int a, int b) { x = a; y = b; } } // Three-dimensional coordinates. class ThreeD extends TwoD { int z; ThreeD(int a, int b, int c) { super(a, b); z = c; } } // Four-dimensional coordinates. class FourD extends ThreeD { int t; FourD(int a, int b, int c, int d) { super(a, b, c); t = d; } } // This class holds an array of coordinate objects. class Coords&lt;T extends TwoD&gt; { T[] coords; Coords(T[] o) { coords = o; } } 演示范围受限通配符// Demonstrate a bounded wildcard. class BoundedWildcard { static void showXY(Coords&lt;?&gt; c) { System.out.println(\"X Y Coordinates:\"); for(int i=0; i &lt; c.coords.length; i++) System.out.println(c.coords[i].x + \" \" + c.coords[i].y); System.out.println(); } static void showXYZ(Coords&lt;? extends ThreeD&gt; c) { System.out.println(\"X Y Z Coordinates:\"); for(int i=0; i &lt; c.coords.length; i++) System.out.println(c.coords[i].x + \" \" + c.coords[i].y + \" \" + c.coords[i].z); System.out.println(); } static void showAll(Coords&lt;? extends FourD&gt; c) { System.out.println(\"X Y Z T Coordinates:\"); for(int i=0; i &lt; c.coords.length; i++) System.out.println(c.coords[i].x + \" \" + c.coords[i].y + \" \" + c.coords[i].z + \" \" + c.coords[i].t); System.out.println(); } public static void main(String args[]) { TwoD td[] = { new TwoD(0, 0), new TwoD(7, 9), new TwoD(18, 4), new TwoD(-1, -23) }; Coords&lt;TwoD&gt; tdlocs = new Coords&lt;TwoD&gt;(td); System.out.println(\"Contents of tdlocs.\"); showXY(tdlocs); // OK, is a TwoD // showXYZ(tdlocs); // Error, not a ThreeD // showAll(tdlocs); // Error, not a FourD // Now, create some FourD objects. FourD fd[] = { new FourD(1, 2, 3, 4), new FourD(6, 8, 14, 8), new FourD(22, 9, 4, 9), new FourD(3, -2, -23, 17) }; Coords&lt;FourD&gt; fdlocs = new Coords&lt;FourD&gt;(fd); System.out.println(\"Contents of fdlocs.\"); // These are all OK. showXY(fdlocs); showXYZ(fdlocs); showAll(fdlocs); } }创建上限使用以下语法：&lt;? extends superclass&gt; ，创建下限使用这样的语法：&lt;? super subclass&gt;创建泛型方法创建一个简单的泛型方法：// Demonstrate a simple generic method. class GenMethDemo { // Determine if an object is in an array. static &lt;T extends Comparable&lt;T&gt;, V extends T&gt; boolean isIn(T x, V[] y) { for(int i=0; i &lt; y.length; i++) if(x.equals(y[i])) return true; return false; } public static void main(String args[]) { // Use isIn() on Integers. Integer nums[] = { 1, 2, 3, 4, 5 }; if(isIn(2, nums)) System.out.println(\"2 is in nums\"); if(!isIn(7, nums)) System.out.println(\"7 is not in nums\"); System.out.println(); // Use isIn() on Strings. String strs[] = { \"one\", \"two\", \"three\", \"four\", \"five\" }; if(isIn(\"two\", strs)) System.out.println(\"two is in strs\"); if(!isIn(\"seven\", strs)) System.out.println(\"seven is not in strs\"); // Opps! Won't compile! Types must be compatible. // if(isIn(\"two\", nums)) // System.out.println(\"two is in strs\"); } }泛型方法的类型参数声明放在返回值类型的前面。泛型方法可以是静态的也可以是非静态的。方法可以类型推断，但是仍然可以显式地指明类型参数。泛型方法的一般形式为： &lt;type-param-list&gt; ret-type meth-name(param-list) { //... }， type-param-list 为逗号分隔的类型参数。泛型构造器构造器可以是泛型，即使它的类不是泛型也可以。例如：// Use a generic constructor. class GenCons { private double val; &lt;T extends Number&gt; GenCons(T arg) { val = arg.doubleValue(); } void showval() { System.out.println(\"val: \" + val); } } class GenConsDemo { public static void main(String args[]) { GenCons test = new GenCons(100); GenCons test2 = new GenCons(123.5F); test.showval(); test2.showval(); } }泛型接口泛型接口的例子：// A generic interface example. // A Min/Max interface. interface MinMax&lt;T extends Comparable&lt;T&gt;&gt; { T min(); T max(); } 实现泛型接口：// Now, implement MinMax class MyClass&lt;T extends Comparable&lt;T&gt;&gt; implements MinMax&lt;T&gt; { T[] vals; MyClass(T[] o) { vals = o; } // Return the minimum value in vals. public T min() { T v = vals[0]; for(int i=1; i &lt; vals.length; i++) if(vals[i].compareTo(v) &lt; 0) v = vals[i]; return v; } // Return the maximum value in vals. public T max() { T v = vals[0]; for(int i=1; i &lt; vals.length; i++) if(vals[i].compareTo(v) &gt; 0) v = vals[i]; return v; } }演示使用泛型接口：class GenIFDemo { public static void main(String args[]) { Integer inums[] = {3, 6, 2, 8, 6 }; Character chs[] = {'b', 'r', 'p', 'w' }; MyClass&lt;Integer&gt; iob = new MyClass&lt;Integer&gt;(inums); MyClass&lt;Character&gt; cob = new MyClass&lt;Character&gt;(chs); System.out.println(\"Max value in inums: \" + iob.max()); System.out.println(\"Min value in inums: \" + iob.min()); System.out.println(\"Max value in chs: \" + cob.max()); System.out.println(\"Min value in chs: \" + cob.min()); } }泛型接口的一般形式：interface interface-name&lt;type-param-list&gt; { //... }实现一个泛型接口的情况：class class-name&lt;type-param-list&gt; implements interface-name&lt;type-arg-list&gt; { //... }原始类型和老代码演示原始类型（raw type）// Demonstrate a raw type. class Gen&lt;T&gt; { T ob; // declare an object of type T // Pass the constructor a reference to // an object of type T. Gen(T o) { ob = o; } // Return ob. T getob() { return ob; } }演示使用原始类型：// Demonstrate raw type. class RawDemo { public static void main(String args[]) { // Create a Gen object for Integers. Gen&lt;Integer&gt; iOb = new Gen&lt;Integer&gt;(88); // Create a Gen object for Strings. Gen&lt;String&gt; strOb = new Gen&lt;String&gt;(\"Generics Test\"); // Create a raw-type Gen object and give it // a Double value. Gen raw = new Gen(new Double(98.6)); // Cast here is necessary because type is unknown. double d = (Double) raw.getob(); System.out.println(\"value: \" + d); // The use of a raw type can lead to run-time. // exceptions. Here are some examples. // The following cast causes a run-time error! // int i = (Integer) raw.getob(); // run-time error // This assigment overrides type safety. strOb = raw; // OK, but potentially wrong // String str = strOb.getob(); // run-time error // This assingment also overrides type safety. raw = iOb; // OK, but potentially wrong // d = (Double) raw.getob(); // run-time error } }原始类型不是类型安全的，因为绕过了泛型提供的类型安全机制。会提示 unchecked warning泛型类体系结构泛型与非泛型的继承体系结构之间的区别在于，在泛型继承体系里面，任何类型参数都需要向上传递到超类。这跟构造器参数在继承体系结构中必须向上传递的情况类似。使用泛型超类一个简单的泛型继承体系结构// A simple generic class hierarchy. class Gen&lt;T&gt; { T ob; Gen(T o) { ob = o; } // Return ob. T getob() { return ob; } }Gen 的一个子类// A subclass of Gen. class Gen2&lt;T&gt; extends Gen&lt;T&gt; { Gen2(T o) { super(o); } }一个子类可以添加它自己的类型参数// A subclass can add its own type parameters. class Gen&lt;T&gt; { T ob; // declare an object of type T // Pass the constructor a reference to // an object of type T. Gen(T o) { ob = o; } // Return ob. T getob() { return ob; } }// A subclass of Gen that defines a second // type parameter, called V. class Gen2&lt;T, V&gt; extends Gen&lt;T&gt; { V ob2; Gen2(T o, V o2) { super(o); ob2 = o2; } V getob2() { return ob2; } }演示继承体系结构// Create an object of type Gen2. class HierDemo { public static void main(String args[]) { // Create a Gen2 object for String and Integer. Gen2&lt;String, Integer&gt; x = new Gen2&lt;String, Integer&gt;(\"Value is: \", 99); System.out.print(x.getob()); System.out.println(x.getob2()); } }泛型子类非泛型子类// A nongeneric class can be the superclass // of a generic subclass. // A nongeneric class. class NonGen { int num; NonGen(int i) { num = i; } int getnum() { return num; } }泛型子类// A generic subclass. class Gen&lt;T&gt; extends NonGen { T ob; // declare an object of type T // Pass the constructor a reference to // an object of type T. Gen(T o, int i) { super(i); ob = o; } // Return ob. T getob() { return ob; } }演示继承体系// Create a Gen object. class HierDemo2 { public static void main(String args[]) { // Create a Gen object for String. Gen&lt;String&gt; w = new Gen&lt;String&gt;(\"Hello\", 47); System.out.print(w.getob() + \" \"); System.out.println(w.getnum()); } }泛型体系的运行时类型比较// Use the instanceof operator with a generic class hierarchy. class Gen&lt;T&gt; { T ob; Gen(T o) { ob = o; } // Return ob. T getob() { return ob; } }Gen 的一个子类// A subclass of Gen. class Gen2&lt;T&gt; extends Gen&lt;T&gt; { Gen2(T o) { super(o); } }演示泛型运行时类型推断// Demonstrate run-time type ID implications of generic // class hierarchy. class HierDemo3 { public static void main(String args[]) { // Create a Gen object for Integers. Gen&lt;Integer&gt; iOb = new Gen&lt;Integer&gt;(88); // Create a Gen2 object for Integers. Gen2&lt;Integer&gt; iOb2 = new Gen2&lt;Integer&gt;(99); // Create a Gen2 object for Strings. Gen2&lt;String&gt; strOb2 = new Gen2&lt;String&gt;(\"Generics Test\"); // See if iOb2 is some form of Gen2. if(iOb2 instanceof Gen2&lt;?&gt;) System.out.println(\"iOb2 is instance of Gen2\"); // See if iOb2 is some form of Gen. if(iOb2 instanceof Gen&lt;?&gt;) System.out.println(\"iOb2 is instance of Gen\"); System.out.println(); // See if strOb2 is a Gen2. if(strOb2 instanceof Gen2&lt;?&gt;) System.out.println(\"strOb is instance of Gen2\"); // See if strOb2 is a Gen. if(strOb2 instanceof Gen&lt;?&gt;) System.out.println(\"strOb is instance of Gen\"); System.out.println(); // See if iOb is an instance of Gen2, which it is not. if(iOb instanceof Gen2&lt;?&gt;) System.out.println(\"iOb is instance of Gen2\"); // See if iOb is an instance of Gen, which it is. if(iOb instanceof Gen&lt;?&gt;) System.out.println(\"iOb is instance of Gen\"); // The following can't be compiled because // generic type info does not exist at run-time. // if(iOb2 instanceof Gen2&lt;Integer&gt;) // System.out.println(\"iOb2 is instance of Gen2&lt;Integer&gt;\"); } }类型转换只能是兼容的类型之间转换重写泛型类的方法重写一个泛型类中的泛型方法// Overriding a generic method in a generic class. class Gen&lt;T&gt; { T ob; // declare an object of type T // Pass the constructor a reference to // an object of type T. Gen(T o) { ob = o; } // Return ob. T getob() { System.out.print(\"Gen's getob(): \" ); return ob; } }重写了 getob() 的一个 Gen 的子类// A subclass of Gen that overrides getob(). class Gen2&lt;T&gt; extends Gen&lt;T&gt; { Gen2(T o) { super(o); } // Override getob(). T getob() { System.out.print(\"Gen2's getob(): \"); return ob; } }演示如何重写泛型方法：// Demonstrate generic method override. class OverrideDemo { public static void main(String args[]) { // Create a Gen object for Integers. Gen&lt;Integer&gt; iOb = new Gen&lt;Integer&gt;(88); // Create a Gen2 object for Integers. Gen2&lt;Integer&gt; iOb2 = new Gen2&lt;Integer&gt;(99); // Create a Gen2 object for Strings. Gen2&lt;String&gt; strOb2 = new Gen2&lt;String&gt;(\"Generics Test\"); System.out.println(iOb.getob()); System.out.println(iOb2.getob()); System.out.println(strOb2.getob()); } }泛型的类型推断即钻石操作符 diamond operator &lt;&gt;类型擦除泛型只是源代码机制，编译后不存在类型参数信息。桥接方法有时候编译器需要一个桥接方法，确保子类重写的方法的类型擦除效果与父类方法不同。模糊错误常出现在方法重载的时候。泛型的一些限制类型参数不可实例化例如以下代码：// 不能创建一个类型为 T 的示例class Gen&lt;T&gt; { T ob; Gen() { ob = new T(); // 非法操作! }}原因编译器不知道应该创建声明类型的对象，T 只是一个占位符。静态方法的限制No static member can use a type parameter declared by the enclosing class. For example, both of the static members of this class are illeagal:class Wrong&lt;T&gt; {\t// Wrong, no static variables of type T. static T ob; // Wrong, no static method can use T. static T getob() { return ob; }}Although you can’t declare static memebers that use a type parameter declared by the enclosing class, you can declare static generic methods, which define their own type parameters, as was done earlier in this chapter.泛型在数组的限制主要包含两方面的限制：不可以实例化元素类型为类型参数的数组。不可以创建某个特定的泛型的数组引用。以下代码展示这两种情况：// Generics and arrays.class Gen&lt;T extends Number&gt; {\tT ob;\tT vals[];\t// OK\tGen(T o, T[] nums) {\t\tob = o;\t\t\t\t// This statement is illegal.\t\t// vals = new T[10]; \t// can't create an array of T\t\t\t\t// But, this statement is OK.\t\tvals = nums;\t// OK to assign reference to existent array\t}}class GenArrays { public static void main(String args[]) { Integer n[] = { 1, 2, 3, 4, 5 }; Gen&lt;Integer&gt; iOb = new Gen&lt;Integer&gt;(50, n); // Can't create an array of type-specific generic references. // Gen&lt;Integer&gt; gens[] = new Gen&lt;Integer&gt;[10];\t// Wrong! // This is OK. Gen&lt;?&gt; gens[] = new Gen&lt;?&gt;[10];\t// OK }}泛型在异常方面的限制泛型类不可以继承 Throwable 意味着你不可以创建泛型异常类型。" }, { "title": "回顾 protected 访问修饰符", "url": "/2019/11/02/java-protected-access-modifier-revisited/", "categories": "", "tags": "Java, Inheritance", "date": "2019-11-02 07:00:00 +0800", "snippet": "使用 protected 访问控制符这是基础内容了，但是不能轻视，越基础越要清晰理解。Protected Access这是用于演示 protected 关键字的代码包图。首先创建一个 Bird 类并将其成员设置为 protected ：package pond.shore;public class Bird { protected String text = \"floating\";\t\t// protected 访问 protected void floatInWater() {\t\t\t// protected 访问 System.out.println(text); } }接着我们创建一个子类：package pond.goose;import pond.shore.Bird;\t\t// 在不同的包public class Gosling extends Bird {\t\t// 创建子类 public void swim() { floatInWater();\t\t// 调用 protected 成员 System.out.println(text);\t// 调用 protected 成员 }}运行以上代码，会打印 floating 两次，一次因为调用 floatInWater() 另一次因为 swim() 里面的 println()。 因为 Gosling 是 Bird 的子类，它可以访问这些成员，即使不在同一个包。 记住 protected 允许所有默认访问权限所允许的。(Remember protected also gives us access to everything that default access does.) 意味着与 Bird 在同一个包的类可以访问它的 protected 成员。package pond.shore;\t\t\t// 与 Bird 在同一个包public class BirdWatcher { public void watchBird() { Bird bird = new Bird(); bird.floatInWater();\t// 调用 protected 成员 System.out.println(bird.text);\t// 调用 protected 成员 }}现在我们尝试在不同的包做同样的操作：package pond.inland;\t\t\t// 与 Bird 不在同一个包public class BirdWatcherFromAfar { public void watchBird() { Bird bird = new Bird(); bird.floatInWater();\t// 不能通过编译 System.out.println(bird.text);\t// 不能通过编译 }}BirdWatcherFromAfar 与 Bird 不在同一个包，且不是 Bird 的子类，所以无法访问 Bird 的 protected 成员。好了，现在看看下面这个例子：package pond.swan;import pond.shore.Bird;\t\t\t// 与 Bird 不在同一个包public class Swan extends Bird {\t// 但是 Bird 的子类 public void swim() { floatInWater();\t\t// 包访问父类 System.out.println(text);\t// 包访问父类 } public void helpOtherSwanSwim() { Swan other = new Swan(); other.floatInWater();\t// 包访问父类 System.out.println(other.text);\t\t// 包访问父类 } public void helpOtherBirdSwim() { Bird other = new Bird(); other.floatInWater();\t// 不能通过编译 System.out.println(other.text);\t\t// 不能通过编译 }}上面代码，helpOtherBirdSwim() 方法里面 other.floatInWater() 和 System.out.println(other.text) 不能通过编译是因为引用变量 other 的类型是 Bird。 如果通过引用变量访问一个成员，能否访问取决于引用的变量的类型。再看看下面这个例子：package pond.goose;import pond.shore.Bird;\t\t\tpublic class Goose extends Bird {\t public void helpGooseSwim() { Goose other = new Goose(); other.floatInWater();\t System.out.println(other.text);\t\t } public void helpOtherGooseSwim() { Bird other = new Goose(); other.floatInWater();\t// 不能通过编译 System.out.println(other.text);\t\t// 不能通过编译 }}上面代码中，在第二个方法 helpOtherGooseSwim() 有问题，尽管创建的是一个 Goose 对象，但是 other 保存的引用类型是 Bird。因为 Goose 与 Bird 不在同一个包，而且 Bird 不是 Goose 的子类，所以不允许访问 Bird 的成员。在看多一个例子：package pond.duck;import pond.goose.Goose;public class GooseWatcher { public void watch() { Goose goose = new Goose(); goose.floatInWater();\t// 不能通过编译 }}代码不能通过编译的原因是我们不在 Goose 类里面。 floatInWater() 方法是 Bird 类中声明的。 GooseWatcher 与 Bird 不在同一个包，而且不是 Bird 的子类。Goose 继承自 Bird 只是允许 Goose 访问 floatInWater() ，而不是 Goose 的调用者。" }, { "title": "响应式Spring Boot系列教程1", "url": "/2019/10/31/reactive-spring-boot-part1-a-kotlin-rest-service/", "categories": "", "tags": "Kotlin, Tutorial, Spring Boot, Reactive, 教程, 翻译", "date": "2019-10-31 04:00:00 +0800", "snippet": " Posted on October 28, 2019 by Trisha Gee 原文由 Trisha Gee 在当地时间2019年10月28日发布在 INTELLIJ IDEA BLOG这个月（2019年10月）我在 SpringOne Platform（大会）做了一个现场代码演示，展示了如何构建一个 Spring Boot 应用，用来显示实时（股票）价格，用到了 Spring（很明显），Kotlin 还有 JavaFX。这个代码演示有录像，是一个时长 70 分钟的视频，不过我觉得作为一系列更简短的视频配以博客文章会更加容易消化，可以更慢、更详细地介绍每一步。这是第一步：使用 Kotlin 创建一个响应式 Spring Boot 服务。这篇博文包含一个视频演示一步步操作过程和一个文字版的操作过程（从视频的讲稿演变而来）给那些更偏好文字版的人。这个教程是我们构建一个完整的使用 Kotlin 写的 Spring Boot 应用作后端， Java 写客户端以及一个 JavaFX 写的用户界面的其中一些步骤。教程的第一步是创建一个 Kotlin 版的 Spring Boot 应用，作为应用程序的后端。我们将会创建一个 REST 服务，可在后面的教程中接入。创建一个 Spring Boot 服务让我们为我们的 Spring Boot 服务创建一个新项目。 选择 New Project，可从 IntelliJ IDEA 的菜单开始或在开始屏幕开始。 选择 New Project 窗口左边的 Spring Initializr 。 我们使用 Java 13 作为这个教程的 SDK，尽管我们没有用到 Java 13 的任何特性（你可以在这里下载 JDK 13.0.1，然后为其指定一个新的 IntelliJ IDEA SDK）。 给项目填入 group 名称，然后我们使用 stock-server 作为名称。 我们可以使用 Maven 或 Gradle 构建此项目。我们将创建一个 Maven 项目，这会生成我们需要的 pom.xml 和 maven wrapper 文件。 选择 Kotlin 作为开发语言。 我们会选择 Java 11 作为 Java 版本，因为这是最新的长期支持版 Java，不过对于这个教程没有什么差别。 项目名称自动根据构件(artifact)名称填充，我们不需要修改它。 给项目添加一个有用的描述。 如有需要，我们可以更改顶层包。下一步我们选择所需的 Spring Boot Starters。 选使用哪个版本的 Spring Boot。在这个教程我们将使用 2.2.0 RC1，因为后面我们将用到只有在候选发布版中才有的特性。（译者注：现在可以直接用 2.2.0.RELEASE，要用到的新特性是 RSocket） 我们可以搜索并选择我们需要用到的 Spring Boot Starters。这是一个响应式 REST 服务，所以我们选择 Reactive Web。 我们使用默认的项目名称和保存位置。IntelliJ IDEA 会使用 Spring Initializr 去创建项目并正确地导入到 IDE。启用 Maven 的 auto-import （自动导入），这样当修改 pom.xml 文件时，项目的依赖会自动刷新。Spring Boot 项目在项目窗口我们看到已创建的项目的结构，包括一个 Kotlin 目录和 Spring Boot 创建的默认应用程序类。package com.mechanitis.demo.stockserviceimport org.springframework.boot.autoconfigure.SpringBootApplicationimport org.springframework.boot.runApplication@SpringBootApplicationclass StockServiceApplicationfun main(args: Array&lt;String&gt;) { runApplication&lt;StockServiceApplication&gt;(*args)}IntelliJ IDEA 旗舰版有对 Spring 应用的全面支持，包括边栏图标，使得在像 Spring Beans 这些 Spring 元素之间的导航更加容易。如果我们快速看一下生成的 pom.xml 文件，我们看到不仅有所选的 Spring Boot Starters 和 Kotlin 依赖，我们还看到 Spring 编译器插件在 kotlin-maven-plugin 里面。这使得用 Kotlin 写 Spring 更容易一些。从应用程序类文件中运行这个基本的应用的程序（使用快捷键）Windows 或 Linux 是 Ctrl + Shift + F10 （macOS 是 ⌃⇧R ），或者双击 Ctrl（运行任意东西）并输入 “StockServiceApplication” 以运行应用程序。它应该会成功启动的，并有 Netty 运行在 8080 端口。关闭它可使用快捷键 Ctrl + F2 ( ⌘F2 )。创建一个 REST Controller现在我们知道项目能运行，我们可以开始添加功能了。 为我们的 REST Controller 创建一个类。简单起见我们现在会将它放在同一个 Kotlin 文件。 我们要将它注解为一个 @RestController。 （贴士：我们可以使用代码模板更快地创建代码。我们可以输入 “fun1” 然后按 tab 去创建一个需要一个参数的函数） 创建一个函数“prices” 接受我们想知道价格的股票代号作为参数。这个方法会返回 Flux&lt;StockPrice&gt;，这是股票价格的不间断流数据。// 起初的 REST Controller@RestControllerclass RestController() { fun prices(@PathVariable symbol: String): Flux&lt;StockPrice&gt; { }}为股票价格创建一个数据类（data class) （贴士：我们可以让 IntelliJ IDEA 创建 StockPrice 类，选中红色的 StockPrice 按下 Alt + Enter 并选择“Create class StockPrice”）。 在同一个 Kotlin 文件内创建一个 StockPrice 类。 这是一个 Kotlin 数据类（data class）。这是一种紧凑的方式声明带有属性的类，然后我们只需声明在构造方法参数中用到的。我们想要一个股票代号，即 String 类型，股票价格，是 Double 类型的，而且还有股票价格相关的时间，用到的是 Java 8 的 java.time.LocalDateTime。// StockPrice 数据类data class StockPrice(val symbol: String, val price: Double, val time: LocalDateTime)生成并返回股票价格现在我们要定义 prices 方法要返回什么。这个方法将会创建一个会每秒发出随机生成的股票价格的 Flux。我们可以通过让它的 interval（时间间隔）设为 1 秒的 Duration （持续时长）。fun prices(symbol: String): Flux&lt;StockPrice&gt; { return Flux.interval(Duration.ofSeconds(1))}（注意：以上代码尚未能通过编译）然后我们为这些逐秒时间创建一个新的 StockPrice 对象。注意在 Kotlin 我们不需要 new 关键字。StockPrice 对象需要 symbol（股票代号），price（股票价格），在这个教程中只是随机生成的值，然后还有 time（时间，或说时刻更准确点），是当下时刻。fun prices(symbol: String): Flux&lt;StockPrice&gt; { return Flux \t\t.interval(Duration.ofSeconds(1)) \t\t.map { StockPrice(symbol, randomStockPrice(), LocalDateTime.now())}}（注意：以上代码尚未能通过编译）创建这个 randomStockPrice 函数（我们可以使用 Alt + Enter 自动创建它）。一种创建任意 Double 对象的的方式是使用 ThreadLocalRandom 和它的 nextDouble 方法。让我们生成一个在 0 到 100 之间的数。@RestControllerclass RestController() { @GetMapping(value = [\"/stocks/{symbol}\"], produces = [MediaType.TEXT_EVENT_STREAM_VALUE]) fun prices(@PathVariable symbol: String): Flux&lt;StockPrice&gt; { return Flux \t\t.interval(Duration.ofSeconds(1)) \t\t.map { StockPrice(symbo, randomStockPrice(), LocalDateTime.now())} } private fun randomStockPrice(): Double { return ThreadLocalRandom.current().nextDouble(100.0) }}运行应用运行应用看是否能正确启动。打开浏览器并访问 http://localhost:8080/stocks/DEMO，你应该可以看到每秒有一个事件发生，并看到股票价格以 JSON 字符串的形式呈现。data:{\"symbol\":\"DEMO\",\"price\":89.06318870033823,\"time\":\"2019-10-17T17:00:25.506109\"}总结我们创建了一个使用了 Reative Steams 每秒发出随机生成的股票价格的简单 Kotlin Spring Boot 应用程序。// StockServiceApplication.kt@SpringBootApplicationclass StockServiceApplication fun main(args: Array&lt;String&gt;) { runApplication&lt;StockServiceApplication&gt;(*args)} @RestControllerclass RestController() { @GetMapping(value = [\"/stocks/{symbol}\"], produces = [MediaType.TEXT_EVENT_STREAM_VALUE]) fun prices(@PathVariable symbol: String): Flux&lt;StockPrice&gt; { return Flux.interval(Duration.ofSeconds(1)) .map { StockPrice(symbol, randomStockPrice(), LocalDateTime.now()) } } private fun randomStockPrice(): Double { return ThreadLocalRandom.current().nextDouble(100.0) }} data class StockPrice(val symbol: String, val price: Double, val time: LocalDateTime)在接下来的教程里，我们将会展示如何连接到这个服务器获取股票价格，还有如何创建一个图表实时显示股票价格更新。代码在 GitHub：https://github.com/zwt-io/rsb" }, { "title": "OCP 考试大纲", "url": "/2019/10/30/ocp-review-topics/", "categories": "", "tags": "Java, OCP", "date": "2019-10-30 00:00:00 +0800", "snippet": "Exam Objectives考点内容见这个链接Java Class Design Implement encapsulation Implement inheritance including visibility modifiers and composition Implement polymorphism Override hashCode, equals, and toString methods from Object class Create and use singleton classes and immutable classes Develop code that uses static keyword on initialize blocks, variables, methods, and classesAdvanced Java Class Design Develop code that uses abstract classes and methods Develop code that uses the final keyword Create inner classes including static inner class, local class, nested class, and anonymous inner class Use enumerated types including methods, and constructors in an enum type Develop code that declares, implements and/or extends interfaces and use the @Override annotation. Create and use Lambda expressionsGenerics and Collections Create and use a generic class Create and use ArrayList, TreeSet, TreeMap, and ArrayDeque objects Use java.util.Comparator and java.lang.Comparable interfaces Collections Streams and Filters Iterate using forEach methods of Streams and List Describe Stream interface and Stream pipeline Filter a collection by using lambda expressions Use method references with StreamsLambda Built-in Functional Interfaces Use the built-in interfaces included in the java.util.function package such as Predicate, Consumer, Function, and Supplier Develop code that uses primitive versions of functional interfaces Develop code that uses binary versions of functional interfaces Develop code that uses the UnaryOperator interfaceJava Stream API Develop code to extract data from an object using peek() and map() methods including primitive versions of the map() method Search for data by using search methods of the Stream classes including findFirst, findAny, anyMatch, allMatch, noneMatch Develop code that uses the Optional class Develop code that uses Stream data methods and calculation methods Sort a collection using Stream API Save results to a collection using the collect method and group/partition data using the Collectors class Use flatMap() methods in the Stream APIExceptions and Assertions Use try-catch and throw statements Use catch, multi-catch, and finally clauses Use Autoclose resources with a try-with-resources statement Create custom exceptions and Auto-closeable resources Test invariants by using assertionsUse Java SE 8 Date/Time API Create and manage date-based and time-based events including a combination of date and time into a single object using LocalDate, LocalTime, LocalDateTime, Instant, Period, and Duration Work with dates and times across timezones and manage changes resulting from daylight savings including Format date and times values Define and create and manage date-based and time-based events using Instant, Period, Duration, and TemporalUnitJava I/O Fundamentals Read and write data from the console Use BufferedReader, BufferedWriter, File, FileReader, FileWriter, FileInputStream, FileOutputStream, ObjectOutputStream, ObjectInputStream, and PrintWriter in the java.io package.Java File I/O (NIO.2) Use Path interface to operate on file and directory paths Use Files class to check, read, delete, copy, move, manage metadata of a file or directory Use Stream API with NIO.2Java Concurrency Create worker threads using Runnable, Callable and use an ExecutorService to concurrently execute tasks Identify potential threading problems among deadlock, starvation, livelock, and race conditions Use synchronized keyword and java.util.concurrent.atomic package to control the order of thread execution Use java.util.concurrent collections and classes including CyclicBarrier and CopyOnWriteArrayList Use parallel Fork/Join Framework Use parallel Streams including reduction, decomposition, merging processes, pipelines and performance.Building Database Applications with JDBC Describe the interfaces that make up the core of the JDBC API including the Driver, Connection, Statement, and ResultSet interfaces and their relationship to provider implementations Identify the components required to connect to a database using the DriverManager class including the JDBC URL Submit queries and read results from the database including creating statements, returning result sets, iterating through the results, and properly closing result sets, statements, and connectionsLocalization Read and set the locale by using the Locale object Create and read a Properties file Build a resource bundle for each locale and load a resource bundle in an applicationAssume the following: Missing package and import statements: If sample code do not include package or import statements, and the question does not explicitly refer to these missing statements, then assume that all sample code is in the same package, or import statements exist to support them. No file or directory path names for classes If a question does not state the file names or directory locations of classes, then assume one of the following, whichever will enable the code to compile and run: All classes are in one file Each class is contained in a separate file, and all files are in one directory Unintended line breaks: Sample code might have unintended line breaks. If you see a line of code that looks like it has wrapped, and this creates a situation where the wrapping is significant (for example, a quoted String literal has wrapped), assume that the wrapping is an extension of the same line, and the line does not contain a hard carriage return that would cause a compilation failure. Code fragments: A code fragment is a small section of source code that is presented without its context. Assume that all necessary supporting code exists and that the supporting environment fully supports the correct compilation and execution of the code shown and its omitted environment. Descriptive comments: Take descriptive comments, such as “setter and getters go here,” at face value. Assume that correct code exists, compiles, and runs successfully to create the described effect." }, { "title": "OCA 回顾与评价", "url": "/2019/10/25/oca-exam-prep-review/", "categories": "", "tags": "Java, OCA", "date": "2019-10-25 00:00:00 +0800", "snippet": "背景大学是软件工程专业，大一专业课先学 C 语言，接着是C语言的数据结构。大二分方向，C++ 和 Java 两个方向。C++ 作为我入门面向对象编程的语言，学完大学的 C++ 课程，主要实践就是用 Qt 写了个简单的数据库课程设计，之后就没有怎么用了，荒废掉了。 C 语言还因为学习微机原理（51 单片机）重新拾起来了一段时间。之后因为那段时间喜欢折腾一些硬件所以也开始玩树莓派，树莓派用 Python 比较多，所以又稍微接触了一下 Python 的基础。到后来因为组队参加比赛，开始接触 Android 编程，那时候 Android 还未开始用 Kotlin, 就开始学习，边学边开发。后来学校的课程也有 Java Web，和 Android 。在做课程设计的过程就开始使用 Spring Boot + AngularJS (那时候用的是 1.x)，写一下后端 REST API，之后觉得 Java Web 后端开发是我想做的方向。可以因为之前学得比较杂，还因为 C/C++ 硬件背景，让我在情感上有点不重视 Java，所以学习投入程度不够。后果就是有时候看代码，写代码的时候觉得很吃力，一种似懂非懂的状态，模糊不清晰，好像大概知道这是做什么功能，但是要清晰地表达出来就有困难了。 要摆脱这种状况，所以多看书，多写代码。参加 Oracle Java 认证考试的作用就是可以驱动学习，有了这个目标，就会认真深入学习，这就是考试的意义。备考选择哪个考试？历史Java 1995年5月23日 首次发布，到现在过去了24年，Java 版本经历了很多变化，Java 考试也经历了很多变化。 从最初的 Sun 公司的 SCJP(Sun Certified Java Programmer) 和 SCJA(Sun Certified Java Associate)。 后来 Oracle 收购了 Sun 公司，相应的考试名称更改了，变成 OCJP 和 OCJA。 后来从Java 7 版本开始，Oracle 决定不再更新 OCJA 考试。 并将更多内容移入到程序员考试，更名为 Oracle Certified Associate Java Programmer (OCAJP)，也称为 Java Programmer I，或称 OCA。 考完 OCA 接着就应该参加 Oracle Certified Professional Java Programmer（OCPJP）考试，或称 OCP，又名 Java Programmer II。现在只需要关注的考试：1Z0-808（Java SE 8 助理程序员），1Z0-809（Java SE 8 专业程序员），1Z0-817（Java SE 6,7,8 专业程序员升级到 Java SE 11 开发者），1Z0-815（Java SE 11 程序员第一部分），1Z0-816（Java SE 11 程序员第二部分，考过即为 Java SE 11开发者）报考创建帐户在 Oracle 大学网站创建帐户，然后购买考试券。在这个页面可以看到关于 OCA 考试的介绍，关于认证路径的更详细内容在另一个页面。 这两个页面都包含了可以购买用于 Pearson VUE 考试的考试券。在 Oracle 大学购买考试券可以支持国内银行卡汇款的支付方式，直接在Pearson VUE 注册并付款就只支持国外信用卡和考试券的方式。 我没有Visa / Master 之类的信用卡，所以就用国内银行汇款的方式了，考试券1077元。实际上加上增值税一共花费1142元，发票数据是 1107.36 + 63.64 税。当然没有国外信用卡的也可以找人代付，据网友分享，淘宝代付1131元。 我倾向于银行汇款的方式。报名在 Pearson VUE 的网站找到 Oracle 的这个 1Z0-808 考试按提示一步步报名就可以了。考试我在广州嘉为考试中心考的试，不同考试中心肯定是不同的。在嘉为考试中心，只提供了A4 纸长一点的 Pearson VUE 可擦除手写板，和一支白板笔。那其实就是是一张白纸过塑了，就像集体照那种，不过它正面是白色给写画，背面是一些考生规则介绍。连个擦除白板字迹的白板擦或者一块布或纸巾都没有提供，当时我做题的时候在版上思考写画，直接用手擦除了，不太好擦，因为版本笔质量比较好，笔迹清晰。按规定中途可以要求在更换白板的，不过我嫌浪费时间就用手擦算了。考试的系统，看起来像是基于浏览器系统，考试过程那个屏幕分辨率低，看起来文字显示粗糙，不过这也不意外，有点像考驾照的文明驾驶科目的那种。但是有时候还要反应慢，估计是直连海外 Pearson 的服务器传输的题目数据，而不是缓存到本地机器的。中间差点以为链接断开了，点下一题的按钮挺久无响应的。有时候突然想起前一题可能做错了，想快速回头检查一下，也会有点卡顿，估计网络延迟比较严重。那个考试系统提供了标记题目的功能，还有鼠标右键划线排除某个选项的功能，最后还可以回顾，检查，这些功能在模拟测试软件都有的。这些功能如果有刷过牛客网，或者做过其他在线笔试的话，可能也不陌生标记题目等功能。觉得还是做题速度和节奏比较重要，如果做得够快，就会有比较多的时间回头检查，double check，但是题目比较多，基本上比较难做得到double check，mark 就很重要了，标记出有疑问的，到最后剩得二三十分钟可以再检查一遍有标记的题目，然后基本就这样的过程了。获得认证考试结束后，考试结果会在两小时内收到邮件，就可以查看到成绩报告了，报告包括题目正确率和结果是否通过。然后在 48 小时后会发放电子证书和数字徽章，电子证书就是一个 pdf 文件，就是证书的模样，因为推崇环保就默认不方法纸质证书了。 然后电子徽章是基于 open badge 标准的，发布于 Pearson 旗下的 Acclaim，数字徽章可以发布到区块链供查询认证，也支持分享到一些社交网络，嵌入到 web 页面。我的数字徽章在这里。OCA考试大纲Java Basics 基础 Define the scope of variables 定义变量的作用范围 Define the structure of a Java class 定义一个 Java 类的结构 Create executable Java applications with a main method; run a Java program from the command line; produce console output 创建包含一个 main 方法的可执行 Java 应用程序；从命令行运行一个 Java 程序；产生控制台输出 Import other Java packages to make them accessible in your code 导入其他 Java 包使其可在你的代码中使用 Compare and contrast the features and components of Java such as: platform independence, object orientation, encapsulation, etc. 比较和对比 Java 的特性和组件，例如：平台独立性，面向对象，封装等Using Operators and Decision Constructs 使用操作符和条件判断结构 Use Java operators; use parentheses to override operator precedence 使用操作符；使用括号覆盖操作符优先级 Test equality between Strings and other objects using == and equals () 使用 == 和 equals() 检查字符串和其他对象之间的相等性 Create if and if/else and ternary constructs 创建 if 和 if/else 已经三元（条件）结构 Use a switch statement 使用 switch 语句Using Loop Constructs 使用循环结构 Create and use while loops 创建并使用 while 循环 Create and use for loops including the enhanced for loop 创建并使用 for 循环，包括增强版 for 循环 Create and use do/while loops 创建并使用do/while 循环 Compare loop constructs 比较循环结构 Use break and continue 使用 break 和 continueWorking with Inheritance 使用继承 Describe inheritance and its benefits 描述继承及其好处 Develop code that makes use of polymorphism; develop code that overrides methods; differentiate between the type of a reference and the type of an object 开发应用到了多态的代码；开发重写方法的代码；区分引用的类型和对象的类型 Determine when casting is necessary 确定何时类型转换时必要的 Use super and this to access objects and constructors 使用 super 和 this 访问对象和构造方法 Use abstract classes and interfaces 使用抽象类和接口Working with Selected classes from the Java API 使用从 Java API 中选择的类 Manipulate data using the StringBuilder class and its methods 使用 StringBuilder 类及其方法去操作数据 Create and manipulate Strings 创建并操作字符串 Create and manipulate calendar data using classes from java.time.LocalDateTime, java.time.LocalDate, java.time.LocalTime,java.time.format.DateTimeFormatter, java.time.Period 创建并操纵日历数据，使用这些类：java.time.LocalDateTime, java.time.LocalDate, java.time.LocalTime,java.time.format.DateTimeFormatter, java.time.Period Declare and use an ArrayList of a given type 声明并使用某个类型的 ArrayList Write a simple Lambda expression that consumes a Lambda Predicate expression 编写一个简单的 Lambda 表达式，要求一个 Lambda Predicate 表达式Working With Java Data Types 使用 Java 数据类型 Declare and initialize variables (including casting of primitive data types) 声明并初始化变量（包括原始数据类型的转换） Differentiate between object reference variables and primitive variables 区分对象引用变量和原始变量 Know how to read or write to object fields 知道如何读或写对象字段 Explain an Object’s Lifecycle (creation, “dereference by reassignment” and garbage collection) 解释一个对象的生命周期（创建，“重新赋值解引用” 和垃圾回收） Develop code that uses wrapper classes such as Boolean, Double, and Integer 开发使用封装类的代码，例如 Boolean, Double 和 IntegerCreating and Using Arrays 创建并使用数组 Declare, instantiate, initialize and use a one-dimensional array 声明，实例化，初始化以及使用一维数组 Declare, instantiate, initialize and use multi-dimensional arrays 声明，实例化，初始化以及使用多维数组Working with Methods and Encapsulation 使用方法和封装 Create methods with arguments and return values; including overloaded methods 创建带参数和返回值的方法 Apply the static keyword to methods and fields 在方法和字段应用 static 关键字 Create and overload constructors; differentiate between default and user defined constructors 创建并重载构造方法；区分默认和用户定义构造方法 Apply access modifiers 应用访问修饰符 Apply encapsulation principles to a class 对类应用封装原则 Determine the effect upon object references and primitive values when they are passed into methods that change the values 确定对象引用和原始变量传递到会改变值的方法时的效果 （考察引用传递还是值传递）Handling Exceptions 处理异常 Differentiate among checked exceptions, unchecked exceptions, and Errors 区分检查异常，非检查异常以及错误 Create a try-catch block and determine how exceptions alter normal program flow 创建一个 try-catch 语句块并确定异常时如何改变正常的程序控制流的 Describe the advantages of Exception handling 描述异常处理的优点 Create and invoke a method that throws an exception 创建并调用一个会抛出异常的方法 Recognize common exception classes (such as NullPointerException, ArithmeticException, ArrayIndexOutOfBoundsException, ClassCastException) 识别常见的异常类（例如 空指针异常，算术异常，数组越界异常，类型转换异常）Assume the following: 默认以下情况： Missing package and import statements: If sample code do not include package or import statements, and the question does not explicitly refer to these missing statements, then assume that all sample code is in the same package, or import statements exist to support them. 缺失的包和导入语句：如果示例代码没有包含包或导入语句，并且问题没有明示这些缺失的语句，那么认为所有的示例代码是在同一个包，或者存在导入它们的导入语句。 No file or directory path names for classes:类没有文件名或者目录路径名： If a question does not state the file names or directory locations of classes, then assume one of the following, whichever will enable the code to compile and run: 如果问题没有提及到类的文件名或者目录位置，那么假设以下几点，能让代码编译并运行即可： All classes are in one file 所有类是在同一个文件 Each class is contained in a separate file, and all files are in one directory每个类分别存在与不同的文件，并且所有文件都在同一个目录 Unintended line breaks: Sample code might have unintended line breaks. If you see a line of code that looks like it has wrapped, and this creates a situation where the wrapping is significant (for example, a quoted String literal has wrapped), assume that the wrapping is an extension of the same line, and the line does not contain a hard carriage return that would cause a compilation failure. 意外的换行：示例代码可能由非预期的换行。如果你看到一行代码看起来软换行了，并且它造成了一个情形，换行的影响是重要的（例如，一个双引号括起来的字符串常量换行了），假设那个换行是同一行的延申，且该行不包含导致编译失败的硬回车换行。 Code fragments: A code fragment is a small section of source code that is presented without its context. Assume that all necessary supporting code exists and that the supporting environment fully supports the correct compilation and execution of the code shown and its omitted environment. 代码片段：一个代码片段是不带有上下文出现的一小节代码片段。假设所有必要的支持代码存在并且支持的环境能保证呈现的代码片段及其省略的部分能够正确执行。 Descriptive comments: Take descriptive comments, such as “setter and getters go here,” at face value. Assume that correct code exists, compiles, and runs successfully to create the described effect. 描述性注释：将描述性注释，例如“setter 和 getters 在这里” 按字面意思理解。假设正确的代码存在，编译、运行成功产生所描述的效果。 书籍信息这文章讲 OCA 准备过程，读过的书籍。 这本书是 : OCA Oracle Certified Associate Java SE 8 Programmer I Study Guide针对 Exam 1Z0-808 ，考的内容是 Java 8 版本，属于长期支持版。 还有一个专业级别的 OCP 考试： Oracle Certified Professional Java SE 8 Programmer II，那个难度大一点。书的目录内容：Chapter 1 Java Building BlocksChapter 2 Operators and StatementsChapter 3 Core Java APIChapter 4 Methods and EncapsulationChapter 5 Class DesignChapter 6 ExceptionsInfoq 有人翻译了一篇介绍这本书的文章模拟考试软件 (Enthuware)一个Java写的软件，界面没什么用户体验的，不过这样好，因为实际考试也差不多的体验。在软件的欢迎界面看到介绍包含了超过 600 个问题，7个模拟考试，还有关于官方考试的一些细节介绍。其实这就足够应付考试了，实际上这并不是所谓的题库。根本不存在题库，然后买个题库相当于背题考试就完了。这些只是模拟题目，OCA 考试的题目是会不断变化的。后续计划今年考完接着考 Java SE 8 Programmer 升级到 Java SE 11 DeveloperJava 11 之后，也不分什么OCA OCP了，只有 Java SE 11 Programmer Part 1 &amp; Part 2.附录：出现的生僻英语单词（对我而言） perpetually 常常；永远；没完没了地 inquire 询问；打听；调查；〈古〉质问 cougar 【动】美洲狮 puma 美洲狮 gibberish 无稽之谈 cram 把…塞进；挤满；塞满；（为应考）临时死记硬背 meekly 温顺地 portion 把…分成若干份（或部分） dividend 被除数，股息；利息；(破产时清算的)分配金 divisor 除数；除子 solely 只；仅；唯；单独地 nontrivial 非平凡；不容易的；〔数〕非零的；非无效的 endeavor 努力 trip 绊倒；将…绊倒；使跌倒；脚步轻快地走（或跑、跳舞） 还有 trick 为欺骗的；使人产生错觉的；虚弱有毛病的 还有 cheat 骗子；欺诈行为；欺骗手段；作弊软件 stray 走失的宠物（或家畜）；无主的宠物（或家畜）；离群者；零星的；孤立的 astray 出正轨的 ；迷路；堕落 pathways 同“path” glaring 显眼的；明显的；易见的；刺眼的 “glare”的现在分词 methodical 有条理的；有条不紊的；办事有条不紊的 Being methodical pays off. bulge 凸出；鼓胀；充满；塞满 鼓起；凸起；（身体的）肥胖部位；暂时的激增 koala 树袋熊；考拉熊；无尾熊 hamster 仓鼠（有颊囊可存放食物，常作宠物） floppy 松散下垂的；耷拉的；松软的 lenient 仁慈的 宽恕; 宽容; 宽厚,宽仁的; 宽大为怀 covariant 【物】协变式的；【统】协变的 【统】协变式；协度 fraught 充满（不愉快事物）的；焦虑的；忧虑的；担心的 货物 pitfalls 陷阱；诱惑；圈套；隐藏的危险 prepend add (something) to the beginning of something else. lemur 狐猴（栖居于马达加斯加岛） primate 灵长类；灵长目动物；大主教；总主教 capybara A mammal native to South America. toddler 学步的儿童；刚学会走路的孩子 contrived 预谋的；不自然的；人为的；矫揉造作的 porcupine 豪猪；箭猪 thwart 阻止；阻挠；对…构成阻力 穿过的；不利的 (横贯小艇的)坐板 momentum 动量；势头；动力；推进力 self-imposed (of a task or circumstance) imposed on oneself, not by an external force. 自我加强 imposed 使…负担；强派(工)；把(次品等)硬卖给 assimilate 吸收；消化；透彻理解；（使）同化 jotting noun. a brief note. “a few jottings on an envelope” 简短的笔记， 随笔 allot v. 分配；分派（任务等）give or apportion (something) to someone. sparingly adverb. in a restricted or infrequent manner; in small quantities." }, { "title": "ETS Test 2 回顾", "url": "/2019/10/23/ets-test2-review/", "categories": "", "tags": "Java, OCA", "date": "2019-10-23 00:00:00 +0800", "snippet": " Enthuware Test Studio Test 2 错题回顾，题目编号为测试系统的编号。2.Given:package loops;public class JustLooping { private int j; void showJ(){ while(j&lt;=5){ for(int j=1; j &lt;= 5;){ System.out.print(j+\" \"); j++; } j++; } } public static void main(String[] args) { new JustLooping().showJ(); }}What is the result?You had to select 1 option It will not compile. It will print 1 2 3 4 5 five times. It will print 1 3 5 five times. It will print 1 2 3 4 5 once. It will print 1 2 3 4 5 six times.✨Explanation 2The point to note here is that the j in for loop is different from the instance member j. Therefore, j++ occuring in the for loop doesn’t affect the while loop. The for loop prints 1 2 3 4 5.The while loop runs for the values 0 to 5 i.e. 6 iterations. Thus, 1 2 3 4 5 is printed 6 times. Note that after the end of the while loop the value of j is 6.6.Given://in file Movable.javapackage p1;public interface Movable { int location = 0; void move(int by); public void moveBack(int by);}//in file Donkey.javapackage p2;import p1.Movable;public class Donkey implements Movable{ int location = 200; public void move(int by) { location = location+by; } public void moveBack(int by) { location = location-by; }}//in file TestClass.javapackage px;import p1.Movable;import p2.Donkey;public class TestClass { public static void main(String[] args) { Movable m = new Donkey(); m.move(10); m.moveBack(20); System.out.println(m.location); }}Identify the correct statement(s).You had to select 1 option Donkey.java will not compile. TestClass.java will not compile. Movable.java will not compile. It will print 190 when TestClass is run. It will print 0 when TestClass is run.✨Explanation 6There is no problem with the code. All variables in an interface are implicitly public, static, and final. All methods in an interface are public.There is no need to define them so explicitly. Therefore, the location variable in Movable is public and static and the move() method is public.Now, when you call m.move(10) and m.moveBack(20), the instance member location of Donkey is updated to 190 because  the reference m refers to a Donkey at run time and so move and moveBack methods of Donkey are invoked at runtime. However, when you print m.location, it is the Movable’s location (which is never updated) that is printed.8.What will be the result of trying to compile and execute the following program?public class TestClass{ public static void main(String args[] ){ int i = 0 ; int[] iA = {10, 20} ; iA[i] = i = 30 ; System.out.println(\"\"+ iA[ 0 ] + \" \" + iA[ 1 ] + \" \"+i) ; }}You had to select 1 options It will throw ArrayIndexOutOfBoundsException at Runtime Compile time Error. It will print 10 20 30 It will print 30 20 30✨Explanation 8The statement iA[i] = i = 30; will be processed as follows:iA[i] = i = 30; 👉 iA[0] = i = 30; 👉 i = 30; iA[0] = i ; 👉 iA[0] = 30;Here is what JLS says on this:1 Evaluate Left-Hand Operand First2 Evaluate Operands before Operation3 Evaluation Respects Parentheses and Precedence4 Argument Lists are Evaluated Left-to-RightFor Arrays: First, the dimension expressions are evaluated, left-to-right. If any of the expression evaluations completes abruptly, the expressions to the right of it are not evaluated.11.Consider the following class :public class Test{ public static void main(String[] args){ if (args[0].equals(\"open\")) if (args[1].equals(\"someone\")) System.out.println(\"Hello!\"); else System.out.println(\"Go away \"+ args[1]); }}Which of the following statements are true if the above program is run with the command line :java Test closedYou had to select 1 options It will throw ArrayIndexOutOfBoundsException at runtime. It will end without exceptions and will print nothing. It will print Go away It will print Go away and then will throw ArrayIndexOutOfBoundsException. None of the above.✨Explanation 11As in C and C++, the Java if statement suffers from the so-called “dangling else problem,” The problem is that both the outer if statement and the inner if statement might conceivably own the else clause. In this example, one might be tempted to assume that the programmer intended the else clause to belong to the outer if statement.The Java language, like C and C++ and many languages before them, arbitrarily decree that an else clause belongs to the innermost if so as the first if() condition fails (args[0] not being “open”) there is no else associated to execute. So, the program does nothing. The else actually is associated with the second if.So had the command line been :java Test open, it would have executed the second if and thrown ArrayIndexOutOfBoundsException.If the command line had been:java Test open xyz, it would execute the else part(which is associated with the second if) and would have printed “Go away xyz”.14.Which of the following code snippets will compile without any errors?(Assume that the statement int x = 0; exists prior to the statements below.)You had to select 3 options while (false) { x=3; } if (false) { x=3; } do{ x = 3; } while(false); for( int i = 0; i&lt; 0; i++) x = 3;✨Explanation 14while (false) { x=3; } is a compile-time error because the statement x=3; is not reachable;Similarly, for( int i = 0; false; i++) x = 3; is also a compile time error because x = 3; is unreachable.In if(false){ x=3; }, although the body of the condition is unreachable, this is not an error because the JLS explicitly defines this as an exception to the rule. It allows this construct to support optimizations through the conditional compilation. For example,if(DEBUG){ System.out.println(\"beginning task 1\"); }Here, the DEBUG variable can be set to false in the code while generating the production version of the class file, which will allow the compiler to optimize the code by removing the whole if statement entirely from the class file.20.Given the following code, which of these statements are true?class TestClass{ public static void main(String args[]){ int k = 0; int m = 0; for ( int i = 0; i &lt;= 3; i++){ k++; if ( i == 2){ // line 1 } m++; } System.out.println( k + \", \" + m ); }}You had to select 3 options It will print 3, 2 when line 1 is replaced by break; It will print 3, 2 when line 1 is replaced by continue. It will print 4, 3 when line 1 is replaced by continue. It will print 4, 4 when line 1 is replaced by i = m++; It will print 3, 3 when line 1 is replaced by i = 4;✨Explanation 20This is a simple loop. All you need to do is execute each statement in your head. For example, if line 1 is replaced by break: ① k=0, m=0② iteration 1: i=0 ⇨ k = 1 ⇨ i == 2 is false ⇨ m = 1③ iteration 2: i = 1 ⇨ k=2 ⇨ i==2 is false ⇨ m = 2④ iteration 3: i = 2 ⇨ k=3 ⇨ i==2 is true ⇨ break⑤ print 3, 225.Which of these statements are true?You had to select 2 options A static method can call other non-static methods in the same class by using the ‘this’ keyword. A calss may contain both static and non-static variables and both static and non-static methods. Each object of a class has its own copy of each non-static member variable. Instance methods of a class has it own copy of each non-static member variable. Instance methods may access local variables of static methods. All methods in a class are implicitly passed a ‘this’ parameter when called.✨Explanation 25‘this’ is assigned a reference to the current object automatically by the JVM. Thus, within an instance method foo, calling this.foo(); is same as calling foo();Since there is no current object available for a static method, ‘this’ reference is not available in static methods and therefore it can only be used within instance methods. For the same reason, static methods cannot access non static fields or methods of that class directly i.e. without a reference to an instance of that class.Note : you can’t reassign ‘this’ like this: this = new Object();28.Which of the following comparisons will yield false?You had to select 3 options Boolean.parseBoolean(\"true\") == true Boolean.parseBoolean(\"TrUe\") == new Boolean(null); new Boolean(\"TrUe\") == new Boolean(true); new Boolean() == false; new Boolean(\"true\") == Boolean.TRUE new Boolean(\"no\") == false;✨Explanation 28You need to remember the following points about Boolean:1. Boolean class has two constructors - Boolean(String) and Boolean(boolean) The String constructor allocates a Boolean object representing the value true if the string argument is not null and is equal, ignoring case, to the string “true”. Otherwise, allocate a Boolean object representing the value false. Examples: new Boolean(\"True\") produces a Boolean object that represents true. new Boolean(\"yes\") produces a Boolean object that represents false.The boolean constructor is self explanatory.2. Boolean class has two static helper methods for creating booleans - parseBoolean and valueOf. Boolean.parseBoolean(String ) method returns a primitive boolean and not a Boolean object (Note - Same is with the case with other parseXXX methods such as Integer.parseInt - they return primitives and not objects). The boolean returned represents the value true if the string argument is not null and is equal, ignoring case, to the string “true”.Boolean.valueOf(String ) and its overloaded Boolean.valueOf(boolean ) version, on the other hand, work similarly but return a reference to either Boolean.TRUE or Boolean.FALSE wrapper objects. Observe that they dont create a new Boolean object but just return the static constants TRUE or FALSE defined in Boolean class.3. When you use the equality operator ( == ) with booleans, if exactly one of the operands is a Boolean wrapper, it is first unboxed into a boolean primitive and then the two are compared (JLS 15.21.2). If both are Boolean wrappers, then their references are compared just like in the case of other objects. Thus, new Boolean(\"true\") == new Boolean(\"true\") is false, but new Boolean(\"true\") == Boolean.parseBoolean(\"true\") is true.29.Identify the valid for loop constructs assuming the following declarations:Object o = null;Collection c = //valid collection object.int[][] ia = //valid arrayYou had to select 2 options for(o : c){ } Cannot use an existing/predefined variable in the variable declaration part. for(final Object o2 :c){ } final is the only modifier (excluding annotations) that is allowed here. for(int i : ia) { } Each element of ia is itself an array. Thus, they cannot be assigned to an int. for(Iterator it : c.iterator()){ } c.iterator() does not return any Collection. Note that the following would have been valid:Collection&lt;Iterator&gt; c = //some collection that contains Iterator objectsfor(Iterator it : c){ } for(int i : ia[0]){ } Since ia[0] is an array of ints, this is valid. (It may throw a NullPointerException or ArrayIndexOutOfBoundsException at runtime if ia is not appropriately initialized.) ✨Explanation 29see above 👆33.Which of these assignments are valid?You had to select 3 options short s = 12; This is valid since 12 can fit into a short and an implicit narrowing conversion can occur. long g = 012; 012 is a valid octal number. int i = (int) false; Values of type boolean cannot be converted to any other types. float f = -123; Implicit widening conversion will occur in this case. float d = 0 * 1.5; double cannot be implicitly narrowed to a float even though the value is representable by a float. ✨Explanation 33Note thatfloat d = 0 * 1.5f; and float d = 0 * (float)1.5; are OKAn implicit narrowing primitive conversion may be used if all of the following conditions are satisfied:1. The expression is a compile time constant expression of type byte, char, short, or int.2. The type of the variable is byte, short, or char.3. The value of the expression (which is known at compile time, because it is a constant expression) is representable in the type of the variable.Note that implicit narrowing conversion does not apply to long or double. So, char ch = 30L; will fail even though 30 is representable in char.44.What will the following code print?public class TestClass{ int x = 5; int getX(){ return x; } public static void main(String args[]) throws Exception{ TestClass tc = new TestClass(); tc.looper(); System.out.println(tc.x); } public void looper(){ int x = 0; while( (x = getX()) != 0 ){ for(int m = 10; m&gt;=0; m--){ x = m; } } } }You had to select 1 option It will not compile. It will throw an exception at runtime. It will print 0. It will print 5. None of these. This program will compile and run but will never terminate. ✨Explanation 44Note that looper() declares an automatic variable x, which shadows the instance variable x. So when x = m; is executed, it is the local variable x that is changed not the instance field x. So getX() never returns 0. If you remove int x = 0; from looper(), it will print 0 and end.48.What will the following program print?class Test{ public static void main(String args[]){ int var = 20, i=0; do{ while(true){ if( i++ &gt; var) break; } }while(i&lt;var--); System.out.println(var); }}You had to select 1 option 19 20 21 22 It will enter an infinite loop.✨Explanation 48When the first iteration of outer do-while loop starts, var is 20. Now, the inner loop executes till i becomes 21.Now, the condition for outer do-while is checked, while( 22 &lt; 20 ), [i is 22 because of the last i++&gt;var check], thereby making var 19. And as the condition is false, the outer loop also ends.So, 19 is printed.56.Consider the following code:class A{ A() { print(); } void print() { System.out.println(\"A\"); }}class B extends A{ int i = 4; public static void main(String[] args){ A a = new B(); a.print(); } void print() { System.out.println(i); }}What will be the output when class B is run ?You had to select 1 option It will print A, 4 It will print A, A It will print 0, 4 It will print 4, 4 None of the above.✨Explanation 56Note that method print() is overridden in class B. Due to polymorphism, the method to be executed is selected depending on the class of the actual object.Here, when an object of class B is created, first B’s default constructor (which is not visible in the code but is automatically provided by the compiler because B does not define any constructor explicitly) is called. The first line of this constructor is a call to super(), which invokes A’s constructor. A’s constructor in turn calls print(). Now, print is a non-private instance method and is therefore polymorphic, which means, the selection of the method to be executed depends on the class of actual object on which it is invoked. Here, since the class of actual object is B, B’s print is selected instead of A’s print. At this point of time, variable i has not been initialized (because we are still in the middle of initializing A), so its default value i.e. 0 is printed.Finally, 4 is printed.58.What will be the result of attempting to compile and run the following program?class TestClass{ public static void main(String args[]){ int i = 0; loop : // 1 { System.out.println(\"Loop Lable line\"); try{ for ( ; true ; i++ ){ if( i &gt;5) break loop; // 2 } } catch(Exception e){ System.out.println(\"Exception in loop.\"); } finally{ System.out.println(\"In Finally\"); // 3 } } }}You had to select 1 option Compilation error at line 1 as this is an invalid syntax for defining a label. You can apply a label to any code block or a block level statement (such as a for statement) but not to declarations. For example: loopX : int i = 10; Compilation error at line 2 as ‘loop’ is not visible here. No compilation error and line 3 will be executed. Even if the break takes the control out of the block, the finally clause will be executed. No compilation error and line 3 will NOT be executed. Only the line with the label loop will be printed.✨Explanation 58A break without a label breaks the current loop (i.e. no iterations any more) and a break with a label tries to pass the control to the given label. ‘Tries to’ means that if the break is in a try block and the try block has a finally clause associated with it then it will be executed.65.Consider the following code snippet:XXXX m ;//other code switch( m ){ case 32 : System.out.println(\"32\"); break; case 64 : System.out.println(\"64\"); break; case 128 : System.out.println(\"128\"); break; }What type can ‘m’ be of so that the above code compiles and runs as expected ?You had to select 3 options int m; m can hold all the case values. long m; long, float, double, and boolean can never be used as a switch variable. char m; m can hold all the case values. byte m; m will not be able to hold 128. a byte’s range is -128 to 127. short m; m can hold all the case values. ✨Explanation 65Here are the rules for a switch statement:1. Only String, byte, char, short, int, (and their wrapper classes Byte, Character, Short, and Integer), and enums can be used as types of a switch variable. (String is allowed only since Java 7).2. The case constants must be assignable to the switch variable. For example, if your switch variable is of class String, your case labels must use Strings as well.3. The switch variable must be big enough to hold all the case constants. For example, if the switch variable is of type char, then none of the case constants can be greater than 65535 because a char’s range is from 0 to 65535.4. All case labels should be COMPILE TIME CONSTANTS.5. No two of the case constant expressions associated with a switch statement may have the same value.6. At most one default label may be associated with the same switch statement.69.Consider the following code:interface Flyer{ String getName(); }class Bird implements Flyer{ public String name; public Bird(String name){ this.name = name; } public String getName(){ return name; }}class Eagle extends Bird { public Eagle(String name){ super(name); }}public class TestClass { public static void main(String[] args) throws Exception { Flyer f = new Eagle(\"American Bald Eagle\"); //PRINT NAME HERE }}Which of the following lines of code will print the name of the Eagle object?You had to select 3 options System.out.println(f.name); System.out.println(f.getName()); System.out.println(((Eagle)f).name); System.out.println(((Bird)f).getName()); System.out.println(Eagle.name); name is not a static field in class Eagle. System.out.println(Eagle.getName(f)); This option doesn’t make any sense. ✨Explanation 69While accessing a method or variable, the compiler will only allow you to access a method or variable that is visible through the class of the reference.When you try to use f.name, the class of the reference f is Flyer and Flyer has no field named “name”, thus, it will not compile. But when you cast f to Bird (or Eagle), the compiler sees that the class Bird (or Eagle, because Eagle inherits from Bird) does have a field named “name” so ((Eagle)f).name or ((Bird)f).name will work fine.f.getName() will work because Flyer does have a getName() method.🔚" }, { "title": "OCA Study Guide 练习回顾", "url": "/2019/10/22/oca-study-guide-test-review/", "categories": "", "tags": "Java, OCA", "date": "2019-10-22 00:00:00 +0800", "snippet": " 这文章讲OCA准备过程，读过的书籍。 这本书叫 OCA Oracle Certified Associate Java SE 8 Programmer I Study Guide 以下按章节整理错题： Chapter 1 Java Building Blocks (2/23😄)18.Which represent the order in which the following statements can be assembled into a program that will compile successfully? (Choose all that apply)A: class Rabbit {}B: import java.util.*;C: package animals; A. A, B, CB. B, C, AC. C, B, AD. B, AE. C, AF. A, CG. A, B22.Which of the following are true statements? (Choose all that apply) A. Java allows operator overloading.B. Java code compiled on Windows can run on Linux.C. Java has pointers to specific locations in memory.D. Java is a procedural language.E. Java is an object-oriented language.F. Java is a functional programming language.Chapter 2 Operators and Statements (3/20😊)9.How many times will the following code print “Hello World”?3: for(int i=0; i&lt;10 ; ) {4: i = i++;5: System.out.println(\"Hello World\");6: } A. 9B. 10C. 11D. The code will not compile because of line 3.E. The code will not compile because of line 5.F. The code contains an infinite loop and does not terminate.16.What is the output of the following code snippet?3: do {4: int y = 1;5: System.out.print(y++ + \" \");6: } while(y &lt;= 10); A. 1 2 3 4 5 6 7 8 9B. 1 2 3 4 5 6 7 8 9 10C. 1 2 3 4 5 6 7 8 9 10 11D. The code will not compile because of line 6.E. The code contains an infinite loop and does not terminate.17.What is the output of the following code snippet?3: boolean keepGoing = true;4: int result = 15, i = 10;5: do {6: i--;7: if(i==8) keepGoing = false;8: result -= 2;9: } while(keepGoing);10: System.out.println(result); A. 7B. 9C. 10D. 11E. 15F. The code will not compile because of line 8.Chapter 3 Core Java APIs (13/33😂)4.What is the result of the following code?7: StringBuilder sb = new StringBuilder();8: sb.append(\"aaa\").insert(1, \"bb\").insert(4, \"ccc\");9: System.out.println(sb); A. abbaacccB. abbacccaC. bbaaacccD. bbaacccaE. An exception is thrown.F. The code does not compile.5.What is the result of the following code?2: String s1 = \"java\";3: StringBuilder s2 = new StringBuilder(\"java\");4: if (s1 == s2)5: System.out.print(\"1\");6: if (s1.equals(s2))7: System.out.print(\"2\"); A. 1B. 2C. 12D. No output is printed.E. An exception is thrown.F. The code does not compile.15.Which of these array declarations is not legal? (Choose all that apply) A. int[][] scores = new int[5][];B. Object[][][] cubbies = new Object[3][0][5];C. String beans[] = new beans[6];D. java.util.Date[] dates[] = new java.util.Date[2][];E. int[][] types = new int[];F. int[][] java = new int[][];16.Which of these compile when replacing line 8? (Choose all that apply)7: char[]c = new char[2];8: // INSERT CODE HERE A. int length = c.capacity;B. int length = c.capacity();C. int length = c.length;D. int length = c.length();E. int length = c.size;F. int length = c.size();G. None of the above.17.Which of these compile when replacing line 8? (Choose all that apply)7: ArrayList l = new ArrayList();8: // INSERT CODE HERE A. int length = l.capacity;B. int length = l.capacity();C. int length = l.length;D. int length = l.length();E. int length = l.size;F. int length = l.size();G. None of the above.18.Which of the following are true? (Choose all that apply) A. An array has a fixed size.B. An ArrayList has a fixed size.C. An array allows multiple dimensions.D. An array is ordered.E. An ArrayList is ordered.F. An array is immutable.G. An ArrayList is immutable.19.Which of the following are true? (Choose all that apply) A. Two arrays with the same content are equal.B. Two ArrayLists with the same content are equal.C. If you call remove(0) using an empty ArrayList object, it will compile successfully.D. If you call remove(0) using an empty ArrayList object, it will run successfully.E. None of the above.20.What is the result of the following statements?6: List&lt;String&gt; list = new ArrayList&lt;String&gt;();7: list.add(\"one\");8: list.add(\"two\");9: list.add(7);10: for(String s : list) System.out.print(s); A. onetwoB. onetwo7C. onetwo followed by an exceptionD. Compiler error on line 9.E. Compiler error on line 10.24.What is the result of the following?6: String [] names = {\"Tom\", \"Dick\", \"Harry\"};7: List&lt;String&gt; list = names.asList();8: list.set(0, \"Sue\");9: System.out.println(names[0]); A. SueB. TomC. Compiler error on line 7.D. Compiler error on line 8.E. An exception is thrown.25.What is the result of the following?List&lt;String&gt; hex = Arrays.asList(\"30\", \"8\", \"3A\", \"FF\");Collections.sort(hex);int x = Collections.binarySearch(hex, \"8\");int y = Collections.binarySearch(hex, \"3A\");int z = Collections.binarySearch(hex, \"4F\");System.out.println(x + \" \" + y + \" \" + z); A. 0 1 –2B. 0 1 –3C. 2 1 –2D. 2 1 –3E. None of the above.F. The code doesn’t compile.26.Which of the following are true statements about the following code? (Choose all that apply)4: List&lt;Integer&gt; ages = new ArrayList&lt;&gt;();5: ages.add(Integer.parseInt(\"5\"));6: ages.add(Integer.valueOf(\"6\"));7: ages.add(7);8: ages.add(null);9: for (int age : ages) System.out.print(age); A. The code compiles.B. The code throws a runtime exception.C. Exactly one of the add statements uses autoboxing.D. Exactly two of the add statements use autoboxing.E. Exactly three of the add statements use autoboxing.29.Which of the following can be inserted into the blank to create a date of June 21, 2014? (Choose all that apply)import java.time.*;public class StartOfSummer { public static void main(String[] args) { LocalDate date = _________ }} A. new LocalDate(2014, 5, 21);B. new LocalDate(2014, 6, 21);C. LocalDate.of(2014, 5, 21);D. LocalDate.of(2014, 6, 21);E. LocalDate.of(2014, Calendar.JUNE, 21);F. LocalDate.of(2014, Month.JUNE, 21);30.What is the output of the following code?LocalDate date = LocalDate.of(2018, Month.APRIL, 40);System.out.println(date.getYear() + \" \" + date.getMonth() + \" \"+ date.getDayOfMonth()); A. 2018 APRIL 4B. 2018 APRIL 30C. 2018 MAY 10D. Another date.E. The code does not compile.F. A runtime exception is thrown.Chapter 4 Methods and Encapsulation (14/29😂)2.Which of the following compile? (Choose all that apply) A. final static void method4() { }B. public final int void method() { }C. private void int method() { }D. static final void method3() { }E. void final method() {}F. void public method() { }5.Given the following method, which of the method calls return 2? (Choose all that apply)public int howMany(boolean b, boolean... b2) {return b2.length;} A. howMany();B. howMany(true);C. howMany(true, true);D. howMany(true, true, true);E. howMany(true, {true});F. howMany(true, {true, true});G. howMany(true, new boolean[2]);6.Which of the following are true? (Choose all that apply) A. Package private access is more lenient than protected access.B. A public class that has private fields and package private methods is not visible to classes outside the package.C. You can use access modifiers so only some of the classes in a package see a particular package private class.D. You can use access modifiers to allow read access to all methods, but not any instance variables.E. You can use access modifiers to restrict read access to all classes that begin with the word Test.9.Which are methods using JavaBeans naming conventions for accessors and mutators? (Choose all that apply) A. public boolean getCanSwim() { return canSwim;}B. public boolean canSwim() { return numberWings;}C. public int getNumWings() { return numberWings;}D. public int numWings() { return numberWings;}E. public void setCanSwim(boolean b) { canSwim = b;}11.Which are true of the following code? (Choose all that apply)1: public class Rope {2: public static void swing() {3: System.out.print(\"swing \");4: }5: public void climb() {6: System.out.println(\"climb \");7: }8: public static void play() {9: swing();10: climb();11: }12: public static void main(String[] args) {13: Rope rope = new Rope();14: rope.play();15: Rope rope2 = null;16: rope2.play();17: }18: } A. The code compiles as is.B. There is exactly one compiler error in the code.C. There are exactly two compiler errors in the code.D. If the lines with compiler errors are removed, the output is climb climb .E. If the lines with compiler errors are removed, the output is swing swing .F. If the lines with compile errors are removed, the code throws a NullPointerException.12.What is the output of the following code?import rope.*;import static rope.Rope.*;public class RopeSwing { private static Rope rope1 = new Rope(); private static Rope rope2 = new Rope(); { System.out.println(rope1.length); } public static void main(String[] args) { rope1.length = 2; rope2.length = 8; System.out.println(rope1.length); }}package rope;public class Rope { public static int length = 0;} A. 02B. 08C. 2D. 8E. The code does not compile.F. An exception is thrown.15.What is the result of the following statements?1: public class Test {2: public void print(byte x) {3: System.out.print(\"byte\");4: }5: public void print(int x) {6: System.out.print(\"int\");7: }8: public void print(float x) {9: System.out.print(\"float\");10: }11: public void print(Object x) {12: System.out.print(\"Object\");13: }14: public static void main(String[] args) {15: Test t = new Test();16: short s = 123;17: t.print(s);18: t.print(true);19: t.print(6.789);20: }21: } A. bytefloatObjectB. intfloatObjectC. byteObjectfloatD. intObjectfloatE. intObjectObjectF. byteObjectObject17.Which of the following are output by the following code? (Choose all that apply)public class StringBuilders { public static StringBuilder work(StringBuilder a, StringBuilder b) { a = new StringBuilder(\"a\"); b.append(\"b\"); return a; } public static void main(String[] args) { StringBuilder s1 = new StringBuilder(\"s1\"); StringBuilder s2 = new StringBuilder(\"s2\"); StringBuilder s3 = work(s1, s2); System.out.println(\"s1 = \" + s1); System.out.println(\"s2 = \" + s2); System.out.println(\"s3 = \" + s3); }} A. s1 = aB. s1 = s1C. s2 = s2D. s2 = s2bE. s3 = aF. s3 = nullG. The code does not compile.18.Which of the following are true? (Choose 2) A. this() can be called from anywhere in a constructor.B. this() can be called from any instance method in the class.C. this.variableName can be called from any instance method in the class.D. this.variableName can be called from any static method in the class.E. You must include a default constructor in the code if the compiler does not include one.F. You can call the default constructor written by the compiler using this().G. You can access a private constructor with the main() method.20.Which code can be inserted to have the code print 2?public class BirdSeed { private int numberBags; boolean call; public BirdSeed() { // LINE 1 call = false; // LINE 2 } public BirdSeed(int numberBags) { this.numberBags = numberBags; } public static void main(String[] args) { BirdSeed seed = new BirdSeed(); System.out.println(seed.numberBags);} } A. Replace line 1 with BirdSeed(2);B. Replace line 2 with BirdSeed(2);C. Replace line 1 with new BirdSeed(2);D. Replace line 2 with new BirdSeed(2);E. Replace line 1 with this(2);F. Replace line 2 with this(2);22.What is the result of the following?1: public class Order {2: static String result = \"\";3: { result += \"c\"; }4: static5: { result += \"u\"; }6: { result += \"r\"; }7: }1: public class OrderDriver {2: public static void main(String[] args) {3: System.out.print(Order.result + \" \");4: System.out.print(Order.result + \" \");5: new Order();6: new Order();7: System.out.print(Order.result + \" \");8: }9: } A. cururB. ucrcrC. u ucrcrD. u u curcurE. u u ucrcrF. ur ur urcG. The code does not compile.26.What is the result of the following class?1: import java.util.function.*;2: 3: public class Panda {4: int age;5: public static void main(String[] args) {6: Panda p1 = new Panda();7: p1.age = 1;8: check(p1, p -&gt; p.age &lt; 5);9: }10: private static void check(Panda panda, Predicate&lt;Panda&gt; pred) {11: String result = pred.test(panda) ? \"match\" : \"not match\";12: System.out.print(result);13: } } A. matchB. not matchC. Compiler error on line 8.D. Compiler error on line 10.E. Compiler error on line 11.F. A runtime excep27.What is the result of the following code?1: interface Climb {2: boolean isTooHigh(int height, int limit);3: }4: 5: public class Climber {6: public static void main(String[] args) {7: check((h, l) -&gt; h.append(l).isEmpty(), 5);8: }9: private static void check(Climb climb, int height) {10: if (climb.isTooHigh(height, 10))11: System.out.println(\"too high\");12: else13: System.out.println(\"ok\");14: }15: } A. okB. too highC. Compiler error on line 7.D. Compiler error on line 10.E. Compiler error on a different line.F. A runtime exception is thrown.29.Which lambda can replace the MySecret class to return the same value? (Choose all that apply)interface Secret { String magic(double d);}class MySecret implements Secret { public String magic(double d) { return \"Poof\"; }} A. caller((e) -&gt; \"Poof\");B. caller((e) -&gt; {\"Poof\"});C. caller((e) -&gt; { String e = \"\"; \"Poof\" });D. caller((e) -&gt; { String e = \"\"; return \"Poof\"; });E. caller((e) -&gt; { String e = \"\"; return \"Poof\" });F. caller((e) -&gt; { String f = \"\"; return \"Poof\"; });Chapter 5 Class Design (12/20😭)1.What modifiers are implicitly applied to all interface methods? (Choose all that apply) A. protectedB. publicC. staticD. voidE. abstractF. default2.What is the output of the following code?1: class Mammal {2: public Mammal(int age) {3: System.out.print(\"Mammal\");4: }5: }6: public class Platypus extends Mammal {7: public Platypus() {8: System.out.print(\"Platypus\");9: }10: public static void main(String[] args) {11: new Mammal(5);12: }13: } A. PlatypusB. MammalC. PlatypusMammalD. MammalPlatypusE. The code will not compile because of line 7.F. The code will not compile because of line 11.3.Which of the following statements can be inserted in the blank line so that the code willcompile successfully? (Choose all that apply)public interface CanHop {}public class Frog implements CanHop { public static void main(String[] args) { ____________frog = new TurtleFrog(); }}public class BrazilianHornedFrog extends Frog {}public class TurtleFrog extends Frog {} A. FrogB. TurtleFrogC. BrazilianHornedFrogD. CanHopE. ObjectF. Long4.Which statement(s) are correct about the following code? (Choose all that apply)public class Rodent { protected static Integer chew() throws Exception { System.out.println(\"Rodent is chewing\"); return 1; }}public class Beaver extends Rodent { public Number chew() throws RuntimeException { System.out.println(\"Beaver is chewing on wood\"); return 2; }} A. It will compile without issue.B. It fails to compile because the type of the exception the method throws is a subclass of the type of exception the parent method throws.C. It fails to compile because the return types are not covariant.D. It fails to compile because the method is protected in the parent class and public in the subclass.E. It fails to compile because of a static modifier mismatch between the two methods.5.Which of the following may only be hidden and not overridden? (Choose all that apply) A. private instance methodsB. protected instance methodsC. public instance methodsD. static methodsE. public variablesF. private variables8.Choose the correct statement about the following code:1: public interface Herbivore {2: int amount = 10;3: public static void eatGrass();4: public int chew() {5: return 13;6: }7: } A. It compiles and runs without issue.B. The code will not compile because of line 2.C. The code will not compile because of line 3.D. The code will not compile because of line 4.E. The code will not compile because of lines 2 and 3.F. The code will not compile because of lines 3 and 4.10.Which statements are true for both abstract classes and interfaces? (Choose all that apply) A. All methods within them are assumed to be abstract.B. Both can contain public static final variables.C. Both can be extended using the extends keyword.D. Both can contain default methods.E. Both can contain static methods.F. Neither can be instantiated directly.G. Both inherit java.lang.Object.11.What modifiers are assumed for all interface variables? (Choose all that apply) A. publicB. protectedC. privateD. staticE. finalF. abstract16.What is the output of the following code?1: abstract class Reptile {2: public final void layEggs() { System.out.println(\"Reptile laying eggs\"); }3: public static void main(String[] args) {4: Reptile reptile = new Lizard();5: reptile.layEggs();6: }7: }8: public class Lizard extends Reptile {9: public void layEggs() { System.out.println(\"Lizard laying eggs\"); }10: } A. Reptile laying eggsB. Lizard laying eggsC. The code will not compile because of line 4.D. The code will not compile because of line 5.E. The code will not compile because of line 9.18.What is the output of the following code? (Choose all that apply)1: interface Aquatic {2: public default int getNumberOfGills(int input) { return 2; }3: }4: public class ClownFish implements Aquatic {5: public String getNumberOfGills() { return \"4\"; }6: public String getNumberOfGills(int input) { return \"6\"; }7: public static void main(String[] args) {8: System.out.println(new ClownFish().getNumberOfGills(-1));9: }10: } A. 2B. 4C. 6D. The code will not compile because of line 5.E. The code will not compile because of line 6.F. The code will not compile because of line 8.19.Which of the following statements can be inserted in the blank so that the code will compile successfully? (Choose all that apply)public class Snake {}public class Cobra extends Snake {}public class GardenSnake {}public class SnakeHandler { private Snake snake; public void setSnake(Snake snake) { this.snake = snake; } public static void main(String[] args) { new SnakeHandler().setSnake(__________); }} A. new Cobra()B. new GardenSnake()C. new Snake()D. new Object()E. new String(\"Snake\")F. null20.What is the result of the following code?1: public abstract class Bird {2: private void fly() { System.out.println(\"Bird is flying\"); }3: public static void main(String[] args) {4: Bird bird = new Pelican();5: bird.fly();6: }7: }8: class Pelican extends Bird {9: protected void fly() { System.out.println(\"Pelican is flying\"); }10: } A. Bird is flyingB. Pelican is flyingC. The code will not compile because of line 4.D. The code will not compile because of line 5.E. The code will not compile because of line 9.Chapter 6 Exceptions (12/20😭)1.Which of the following statements are true? (Choose all that apply) A. Runtime exceptions are the same thing as checked exceptions.B. Runtime exceptions are the same thing as unchecked exceptions.C. You can declare only checked exceptions.D. You can declare only unchecked exceptions.E. You can handle only Exception subclasses.2.Which of the following pairs fill in the blanks to make this code compile? (Choose all that apply)7: public void ohNo() _____ Exception {8: _____________ Exception();9: } A. On line 7, fill in throwB. On line 7, fill in throwsC. On line 8, fill in throwD. On line 8, fill in throw newE. On line 8, fill in throwsF. On line 8, fill in throws new5.Which of the following exceptions are thrown by the JVM? (Choose all that apply) A. ArrayIndexOutOfBoundsExceptionB. ExceptionInInitializerErrorC. java.io.IOExceptionD. NullPointerExceptionE. NumberFormatException7.What is printed besides the stack trace caused by the NullPointerException from line 16?1: public class DoSomething {2: public void go() {3: System.out.print(\"A\");4: try {5: stop();6: } catch (ArithmeticException e) {7: System.out.print(\"B\");8: } finally {9: System.out.print(\"C\");10: }11: System.out.print(\"D\");12: }13: public void stop() {14: System.out.print(\"E\");15: Object x = null;16: x.toString();17: System.out.print(\"F\");18: }19: public static void main(String[] args) {20: new DoSomething().go();21: }22: } A. AEB. AEBCDC. AECD. AECDE. No output appears other than the stack trace.13.Which of the following statements are true? (Choose all that apply) A. You can declare a method with Exception as the return type.B. You can declare any subclass of Error in the throws part of a method declaration.C. You can declare any subclass of Exception in the throws part of a method declaration.D. You can declare any subclass of Object in the throws part of a method declaration.E. You can declare any subclass of RuntimeException in the throws part of a method declaration.14.Which of the following can be inserted on line 8 to make this code compile? (Choose all that apply)7: public void ohNo() throws IOException {8: // INSERT CODE HERE9: } A. System.out.println(\"it's ok\");B. throw new Exception();C. throw new IllegalArgumentException();D. throw new java.io.IOException();E. throw new RuntimeException();15.Which of the following are unchecked exceptions? (Choose all that apply) A. ArrayIndexOutOfBoundsExceptionB. IllegalArgumentExceptionC. IOExceptionD. NumberFormatExceptionE. Any exception that extends RuntimeExceptionF. Any exception that extends Exception16.Which scenario is the best use of an exception? A. An element is not found when searching a list.B. An unexpected parameter is passed into a method.C. The computer caught fire.D. You want to loop through a list.E. You don’t know how to code a method.17.Which of the following can be inserted into Lion to make this code compile? (Choose all that apply)class HasSoreThroatException extends Exception {}class TiredException extends RuntimeException {}interface Roar { void roar() throws HasSoreThroatException;}class Lion implements Roar {// INSERT CODE HERE} A. public void roar(){}B. public void roar() throws Exception{}C. public void roar() throws HasSoreThroatException{}D. public void roar() throws IllegalArgumentException{}E. public void roar() throws TiredException{}18.Which of the following are true? (Choose all that apply) A. Checked exceptions are allowed to be handled or declared.B. Checked exceptions are required to be handled or declared.C. Errors are allowed to be handled or declared.D. Errors are required to be handled or declared.E. Runtime exceptions are allowed to be handled or declared.F. Runtime exceptions are required to be handled or declared.19.Which of the following can be inserted in the blank to make the code compile? (Choose all that apply)public static void main(String[] args) { try { System.out.println(\"work real hard\"); } catch ( ______ e) { } catch (RuntimeException e) { }} A. ExceptionB. IOExceptionC. IllegalArgumentExceptionD. RuntimeExceptionE. StackOverflowErrorF. None of the above.20.What does the output of the following contain? (Choose all that apply)12: public static void main(String[] args) {13: System.out.print(\"a\");14: try {15: System.out.print(\"b\");16: throw new IllegalArgumentException();17: } catch (IllegalArgumentException e) {18: System.out.print(\"c\");19: throw new RuntimeException(\"1\");20: } catch (RuntimeException e) {21: System.out.print(\"d\");22: throw new RuntimeException(\"2\");23: } finally {24: System.out.print(\"e\");25: throw new RuntimeException(\"3\");26: }27: } A. abceB. abdeC. An exception with the message set to “1”D. An exception with the message set to “2”E. An exception with the message set to “3”F. Nothing, the code does not compile." }, { "title": "相反顺序输出一个整数", "url": "/2019/10/14/do1-cloud-test-review/", "categories": "", "tags": "Java, 笔试", "date": "2019-10-14 00:00:00 +0800", "snippet": "起初编写程序，对输入的一个整数，按相反顺序输出该数。// ReverseInt.javaimport java.util.Scanner;public class ReverseInt {\tpublic static void main(String[] args) {\t\tSystem.out.println(\"请输入一个整数：\");\t\tScanner input = new Scanner(System.in);\t\tString value = \"\" + input.nextBigInteger();\t\tinput.close();\t\tString reversed = \"\";\t\tfor (int i = value.length() - 1; i &gt;= 0; i--) {\t\t\treversed = reversed + value.charAt(i);\t\t}\t\tSystem.out.println(reversed);\t}}当时手写代码，for 循环的控制条件边界写错了，当时写成了 for (int i = value.length(); i &gt; 0; i--) 结果数组越界了。应该是 for (int i = value.length() - 1; i &gt;= 0; i--) 的。换成 input.nextBigInteger(); 好一点。 后来真是没有必要这样搞，用 StringBuilder 就可以了：import java.util.Scanner;public class ReverseInt {\tpublic static void main(String[] args) {\t\tSystem.out.println(\"请输入一个整数：\");\t\tScanner input = new Scanner(System.in);\t\tStringBuilder value = new StringBuilder();\t\tvalue.append(input.nextBigInteger());\t\tinput.close();\t\tSystem.out.println(value.reverse());\t}}【完】" }, { "title": "OCA 自测回顾", "url": "/2019/10/13/oca-guide-intro-test-review/", "categories": "", "tags": "Java, OCA", "date": "2019-10-13 00:00:00 +0800", "snippet": "OCA 自测题回顾 What is the output of the following code? (Choose all that apply) interface HasTail { int getTailLength(); } abstract class Puma implements HasTail { protected int getTailLength() {return 4;} } public class Cougar extends Puma { public static void main(String[] args) { Puma puma = new Puma(); System.out.println(puma.getTailLength()); } public int getTailLength(int length) {return 2;} } A. 2 B. 4 C. The code will not compile because of line 3. D. The code will not compile because of line 5. E. The code will not compile because of line 7. F. The output cannot be determined from the code provided. 答案是： C, D, E. First, the method getTailLength() in the interface HasTail is assumed to be public, since it is part of an interface. The implementation of the method on line 3 is therefore an invalid override, as protected is a more restrictive access modifier than public, so option C is correct. Next, the class Cougar implements an overloaded versionof getTailLength(), but since the declaration in the parent class Puma is invalid, it needs to implement a public version of the method. Since it does not, the declaration of Cougar is invalid, so option D is correct. Option E is correct, since Puma is marked abstract and cannot be instantiated. The overloaded method on line 11 is declared correctly, so option F is not correct. Finally, as the code has multiple compiler errors, options A, B, and G can be eliminated. What is the result of the following program? public class MathFunctions { public static void addToInt(int x, int amountToAdd) { x = x + amountToAdd; } public static void main(String[] args) { int a = 15; int b = 10; MathFunctions.addToInt(a, b); System.out.println(a); } } A. 10 B. 15 C. 25 D. Compiler error on line 3. E. Compiler error on line 8. F. None of the above. 答案是： B. The code compiles successfully, so options D and E are incorrect. The value of a cannot be changed by the addToInt method, no matter what the method does, because only a copy of the variable is passed into the parameter x. Therefore, a does not change and the output on line 9 is 15. What is the result of the following code? int[] array = {6,9,8}; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(array[0]); list.add(array[2]); list.set(1, array[1]); list.remove(0); System.out.println(list); A. [8] B. [9] C. Something like [Ljava.lang.String;@160bc7c0 D. An exception is thrown. E. The code does not compile. 答案是： B. The array is allowed to use an anonymous initializer because it is in the same line as the declaration. The ArrayList uses the diamond operator allowed since Java 7. This specifies the type matches the one on the left without having to re-type it. After adding the two elements, list contains [6, 8]. We then replace the element at index 1 with 9, resulting in [6, 9]. Finally, we remove the element at index 0, leaving [9]. Option C is incorrect because arrays output something like that rather than an ArrayList. What is the output of the following code? public class Deer { public Deer() { System.out.print(\"Deer\"); } public Deer(int age) { System.out.print(\"DeerAge\"); } private boolean hasHorns() { return false; } public static void main(String[] args) { Deer deer = new Reindeer(5); System.out.println(\",\"+deer.hasHorns()); } } class Reindeer extends Deer { public Reindeer(int age) { System.out.print(\"Reindeer\"); } public boolean hasHorns() { return true; } } A. DeerReindeer,false B. DeerReindeer,true C. ReindeerDeer,false D. ReindeerDeer,true E. DeerAgeReindeer,false F. DeerAgeReindeer,true G. The code will not compile because of line 7. H. The code will not compile because of line 12. 答案是：A. The code compiles and runs without issue, so options G and H are incorrect. First, the Reindeer object is instantiated using the constructor that takes an int value. Since there is no explicit call to the parent constructor, the default no-argument super() is inserted as the first line of the constructor. The output is then Deer, followed by Reindeer in the child constructor, so only options A and B can be correct. Next, the method hasHorns() looks like an overridden method, but it is actually a hidden method since it is declared private in the parent class. Because the hidden method is referenced in the parent class, the parent version is used, so the code outputs false, and option A is the correct answer. Which of the following statements are true? (Choose all that apply) A. Checked exceptions are intended to be thrown by the JVM (and not the programmer). B. Checked exceptions are required to be caught or declared. C. Errors are intended to be thrown by the JVM (and not the programmer). D. Errors are required to be caught or declared. E. Runtime exceptions are intended to be thrown by the JVM (and not the programmer). F. Runtime exceptions are required to be caught or declared. 答案是：B, C. Only checked exceptions are required to be handled (caught) or declared. Runtime exceptions are commonly thrown by both the JVM and programmer code. Checked exceptions are usually thrown by programmer code. Errors are intended to be thrown by the JVM. While a programmer could throw one, this would be a horrible practice. Which are true of the following code? (Choose all that apply) import java.util.*; public class Grasshopper { public Grasshopper(String n) { name = n; } public static void main(String[] args) { Grasshopper one = new Grasshopper(\"g1\"); Grasshopper two = new Grasshopper(\"g2\"); one = two; two = null; one = null; } private String name; } A. Immediately after line 9, no grasshopper objects are eligible for garbage collection. B. Immediately after line 10, no grasshopper objects are eligible for garbage collection. C. Immediately after line 9, only one grasshopper object is eligible for garbage collection. D. Immediately after line 10, only one grasshopper object is eligible for garbage collection. E. Immediately after line 11, only one grasshopper object is eligible for garbage collection. F. The code compiles. G. The code does not compile. 答案是：C, D, F. Immediately after line 9, only Grasshopper g1 is eligible for garbage collection since both one and two point to Grasshopper g2. Immediately after line 10, we still only have Grasshopper g1 eligible for garbage collection. Reference two points to g2 and reference two is null. Immediately after line 11, both Grasshopper objects are eligible for garbage collection since both one and two point to null. The code does compile. Although it is traditional to declare instance variables early in the class, you don’t have to. What is the output of the following program? public class FeedingSchedule { public static void main(String[] args) { \tint x = 5, j = 0; \tOUTER: for(int i=0; i&lt;3; ) \t\tINNER: do { i++; x++; if(x &gt; 10) break INNER; x += 4; j++; } while(j &lt;= 2); \t\tSystem.out.println(x); } } A. 10 B. 12 C. 13 D. 17 E. The code will not compile because of line 4. F. The code will not compile because of line 6. 答案是：B. The code compiles and runs without issue; therefore, options E and F are incorrect. This type of problem is best examined one loop iteration at a time: On the first iteration of the outer loop i is 0, so the loop continues. On the first iteration of the inner loop, i is updated to 1 and x to 6. The if-then statement branch is not executed, and x is increased to 10 and j to 1. On the second iteration of the inner loop (since j = 1 and 1 &lt;= 2), i is updated to 2 and x to 11. At this point, the if-then branch will evaluate to true for the remainder of the program run, which causes the flow to break out of the inner loop each time it is reached. On the second iteration of the outer loop (since i = 2), i is updated to 3 and x to 12. As before, the inner loop is broken since x is still greater than 10. On the third iteration of the outer loop, the outer loop is broken, as i is already not less than 3. The most recent value of x, 12, is output, so the answer is option B. Assuming we have a valid, non-null HenHouse object whose value is initialized by the blank line shown here, which of the following are possible outputs of this application?(Choose all that apply) class Chicken {} interface HenHouse { public java.util.List&lt;Chicken&gt; getChickens(); } public class ChickenSong { public static void main(String[] args) { HenHouse house = ______________ Chicken chicken = house.getChickens().get(0); for(int i=0; i&lt;house.getChickens().size(); chicken = house.getChickens().get(i++)) { System.out.println(\"Cluck\"); } } } A. The code will not compile because of line 6. B. The code will not compile because of lines 7–8. C. The application will compile but not produce any output. D. The application will output Cluck exactly once. E. The application will output Cluck more than once. F. The application will compile but produce an exception at runtime. 答案是：D, E, F. The code compiles without issue, so options A and B are incorrect. If house.getChickens() returns an array of one element, the code will output Cluck once, so option D is correct. If house.getChickens() returns an array of multiple elements, the code will output Cluck once for each element in the array, so option E is correct. Alternatively, if house.getChickens() returns an array of zero elements, then the code will throw an IndexOutOfBoundsException on the call to house.getChickens().get(0); therefore, option C is not possible and option F is correct. The code will also throw an exception if the array returned by house.getChickens() is null, so option F is possible under multiple circumstances. What individual changes, if any, would allow the following code to compile? (Choose all that apply) public interface Animal { public default String getName() { return null; } } interface Mammal { public default String getName() { return null; } } abstract class Otter implements Mammal, Animal {} A. The code compiles without issue. B. Remove the default method modifier and method implementation on line 1. C. Remove the default method modifier and method implementation on line 2. D. Remove the default method modifier and method implementation on lines 1 and 2. E. Change the return value on line 1 from null to \"Animal\". F. Override the getName() method with an abstract method in the Otter class. G. Override the getName() method with a concrete method in the Otter class. 答案是：D, F, G. The code does not compile, since a class cannot inherit two interfaces that both define default methods with the same signature, unless the class implementing the interfaces overrides it with an abstract or concrete method. Therefore, option A is incorrect and options F and G are correct. The alternate approach is to make the getName() method abstract in the interfaces, because a class may inherit two abstract methods with the same signature. The change must be made to both interfaces, though, so options B and C are incorrect if taken individually, and option D is correct since the changes are taken together. Which of the following lines can be inserted at line 11 to print true? (Choose all that apply) public static void main(String[] args) { // INSERT CODE HERE}private static boolean test(Predicate&lt;Integer&gt; p) { return p.test(5);} A. System.out.println(test(i -&gt; i == 5)); B. System.out.println(test(i -&gt; {i == 5;})); C. System.out.println(test((i) -&gt; i == 5)); D. System.out.println(test((int i) -&gt; i == 5); E. System.out.println(test((int i) -&gt; {return i == 5;})); F. System.out.println(test((i) -&gt; {return i == 5;})); 答案是：A, C, F. The only functional programming interface you need to memorize for the exam is Predicate. It takes a single parameter and returns a boolean. Lambda expressions with one parameter are allowed to omit the parentheses around the parameter list, making options A and C correct. The return statement is optional when a single statement is in the body, making option F correct. Option B is incorrect because a return statement must be used if braces are included around the body. Options D and E are incorrect because the type is Integer in the predicate and int in the lambda. Autoboxing works for collections not inferring predicates. If these two were changed to Integer, they would be correct. Which of the following are checked exceptions? (Choose all that apply) A. Exception B. IllegalArgumentException C. IOException D. NullPointerException E. NumberFormatException F. StackOverflowError 答案是：A, C. Option A is the exception base class, which is a checked exception. Options B, D, and E extend RuntimeException directly or indirectly and therefore are unchecked exceptions. Option F is a throwable and not an exception, and so should not be caught or declared. " }, { "title": "控制台输入数组", "url": "/2019/10/13/get-int-array-from-console-input/", "categories": "", "tags": "Java, Misc", "date": "2019-10-13 00:00:00 +0800", "snippet": "输入数据到整型数组问题从控制台标准输入读取键盘输入的数，存放到整型数组里面。数组的长度不确定，这种情况怎么处理？解决方法先输入字符串数组，中间按照某种模式（正则表达式）分隔开，得到字符串数组。取字符串数组(String[])的长度作为整型数组（int[])的初始长度，然后将字符串数组(String[])转化为整型数组。 Java 代码实现如下：public static void main(String[] args) {\tScanner stdIn = new Scanner(System.in); String[] strArray = null; strArray = stdIn.nextLine().split(\"\\\\s*,\\\\s*\"); // ','分割，前后可以有空格 int[] intArray = new int[strArray.length]; for(int i = 0; i&lt; strArray.length; i++) { intArray[i] = Integer.parseInt(strArray[i]); }}结束基本可以满足要求，如果想到更加方便，简洁的方式再更新。" }, { "title": "常见排序算法", "url": "/2019/10/12/sorting-algorithms/", "categories": "", "tags": "Java, Algorithms", "date": "2019-10-12 00:00:00 +0800", "snippet": "常见的排序算法" }, { "title": "OCA Study Guide Errata", "url": "/2019/10/12/errata/", "categories": "", "tags": "Java, OCA, Errata", "date": "2019-10-12 00:00:00 +0800", "snippet": "ERRATA Chapter Page Details       Introduction xxxix Errata in text Corrections in Book and Online: In Point number 1: Currently reads: a_b defaults to a null value Should read: $ defaults to 0 In Point number 3: ‘Puma is invalid’ should be ‘Cougar is invalid’ for the explanation for D ‘E is incorrect’ should be ‘E is correct’ In Point number 4: The first bullet should say ‘starts’ rather than ‘continues’ ‘With y taking a new value’ should be ‘With count taking a new value’ Also, in the second bullet, 1 + 4 should say 1 + 5.       Introduction xli Errata in Text Point Number 10 currently reads:Reference one points to g1 Should read:Reference two points to g2 Point Number 13 currently reads:D and E are correct Should read:D and E are incorrect       Introduction xlii Errata in text Corrections in Book and Online: Point number 16: Currently Reads: ‘because an interface may inherit two abstract methods with the same signature’ Should Read: ‘because a class may inherit two abstract methods with the same signature’       1 Chapter 1 Errata in text eBook Correction Only: In some of the review questions, the line break is missing between the code that would be in different files. You can assume that each package statement starts a new file.       1 4 Errata in text Corrections in Book Only: ‘each of these five words is in’ should be ‘each of these six words is in’       1 8 Errata in text The code currently reads: Zoo.mainmethod(Zoo.java:7) Should Read: Zoo.main(Zoo.java:4)       1 10 Errata in text In the fourth line of the second paragraph, ‘From example’ should be ‘For example’.       1 12 Errata in text Corrections in Book Only: ‘java.nio.files.Paths’ should be ‘java.nio.file.Paths’ Note:This change should carried out in two instances       1 18 Errata in text Corrections in Book Only: The middle code block should have } instead of { on line 5.       1 30 Errata in text The compiler error message at the top of the page should refer to line 7 rather than line 5.       1 31 Errata in text At the end of the second paragraph, ‘simplest type it can give the value’ should be ‘simplest value it can give the type’       2 53 Errata in text Corrections in Book Only: On the first line of table 2.1, ~ should be in the other unary operators section. And on the last line of the table, !=, should be |=.       2 54 Errata in text Corrections in Book Only: In ‘resulting in a value of x of 7. Make sure you understand why the result is 24’, the 7 should be 14       2 54 Errata in text Corrections in Book Only: In ‘int x = 2 * ((5 + 3) * 4 - 8); This time you would evaluate the addition operator 10 + 3’, the 10 should be 5.       2 57 Errata in text Corrections in Book Only: In the second sentence, ‘multiplied’ should be ‘divided’       2 61 Errata in text Corrections in Book Only: 9l should be 9f on the first row       2 62 Errata in text Corrections in Book Only: Currently Reads: The compound operator will first cast x to a long Should Read: The compound operator will first cast y to a long       2 64 Errata in text Corrections in Book Only: Figure 2.1 says ‘true tables’ rather than ‘truth tables’       2 69 Errata in text ‘block of statement’ should be ‘block of statements’       2 71 Errata in text The first code example shouldn’t have ‘final’ so the ternary operator is equivalent.       2 72 Errata in text Corrections in Book Only: Remove ‘As of Java 7’ from the first sentence       2 73 Text Correction ‘int’ and ‘Integer’ is listed twice in the bulleted list.       2 82 Errata in text Corrections in Book Only: In the first example on the page, System.out.println(x) should be removed.       2 82 Errata in text Corrections in Book Only: In the first example, ‘y and z were both long’ should be ‘In the multiple terms example, y and z were both long’       2 83 Errata in text Corrections in Book Only: Figure 2.8 says ‘semicolon’ rather than ‘colon’ when pointing to a colon       2 83 Errata in text Corrections in Book Only: In Figure 2.8, the title should be ‘enhanced for-each statement’ rather than ‘enhancement for statement’       2 86 Errata in text Corrections in Book Only: values[i]-values[i-1] should be (values[i]-values[i-1]) + “,”       2 91 Errata in text Corrections in Book Only: In table 2.5, the second table header should be ‘Allows unlabeled break’       2 96 Errata in text Corrections in Book and Online: In Point number 8: Choice E should be changed to ‘None of the above’       3 107 Errata in text Corrections in Book Only: int indexOf(char ch) should be int indexOf(int ch) and int indexOf(char ch, index, fromIndex) should be int indexOf(int ch, int fromIndex) int indexOf(String str, index fromIndex) should be int indexOf(String str, int fromIndex).       3 107 Errata in text Corrections in Book Only: ‘int substring’ should be ‘String substring’ in both substring methods       3 108 Errata in text Corrections in Book Only: Currently reads: toLowerCase(String str) Should read: toLowerCase() Currently Reads: toUpperCase(String str) Should Read: toUpperCase()       3 108 Errata in text Corrections in Book Only: Currently Reads: because the indexes can be backward Should Read: because the indexes can’t be backward       3 109 Errata in text Corrections in Book Only: boolean equals(String str) should be boolean equals(Object obj) Note: You only have to know about String for the exam       3 111 Text Correction Currently reads: Animal Should read: AnimAl       3 111 Errata in text Corrections in Book Only: In the third paragraph, there is a stray quote. “‘C’ should be ‘C’       5 115 Errata in text Corrections in Book Only: On line 6, the line should have a dash at the end       3 118 Errata in text Corrections in Book Only: In the code example, line 7 should have been t1 == t3.       3 120 Errata in text Corrections in Book Only: On the first line, ‘set all the elements’ should be ‘all elements are set’       3 124 Errata in text Corrections in Book Only: import java.util.* should be import java.util.*;       3 124 Errata in text Currently Reads: Using the length variable Should Read: using the length field       3 124 Errata in text Currently Reads: \\ L System.out.print Should Read: System.out.print       3 125 Errata in text Corrections in Book Only: In the last paragraph, ‘line 5 searches for the index of 1’ should be ‘line 6’       3 126 Errata in text Corrections in Book Only: In the first paragraph, ‘line 3 gave the wrong answer’ should be line 7.       3 126 Errata in equation Corrections in Book Only: int numbers = should be int[] numbers =       3 126 Errata in text Corrections in Book Only: In the last paragraph of the Autoboxing section, ‘outputs 1’ should be ‘outputs[1]’       3 129 Errata in equation Corrections in Book Only: import java.util.* should be import java.util.*;       3 141 Errata in text Corrections in Book Only: Currently Reads: public static LocalDateTime of(LocalDate date, LocalTime) Should Read: public static LocalDateTime of(LocalDate date, LocalTime time)       3 141 Errata in text Corrections in Book Only: Month.January, 32) should be Month.January, 32);       3 143 Errata in text Corrections in Book Only: LocalDateTime.of(date2 should be LocalDateTime.of(date       3 146 Errata in text Corrections in Book Only: toEpochTime should to toEpochSecond       3 147 Errata in text Corrections in Book Only: Currently Reads: wrong = Period.ofWeeks(7); Should Read: wrong = Period.ofWeeks(1);       3 148 Errata in text Corrections in Book Only: System.out.println(date.format(DateTimeFormatteer.ISO_LOCAL_DATE)); should have a line break immediately before “System”       3 150 Errata in text Corrections in Book Only: ‘dd means to include the leading zero for a single-digit month’ should be ‘dd means to include the leading zero for a single-digit day’       4 168 Errata in text Corrections in Book Only: ‘And since it is optional, you can’t have any of them at all.’ should be ‘And since it is optional, you are allowed to not have any of them at all.’       4 170 Errata in text Corrections in Book Only: Currently Reads: int long() {] Should Read: int longMethod(){       4 172 Errata in text Corrections in Book Only: Currently Reads: Walk1() is a valid method declaration without an empty method body. Should Read: Walk1() is a valid method declaration with an empty method body.       4 172 Errata in text Corrections in Book Only: Currently Reads: public void walk2; Should Read: public void walk2();       4 173 Errata in text Corrections in Book Only: Currently Reads: Line 20 calls a vararg parameter two parameters Should Read: Line 20 calls a vararg method with two parameters.       4 179 Errata in text ‘Bird is not a subclass of Bird’ should say ‘Bird is not a subclass of Goose’       4 181 Errata in text Table 4.2 INCORRECT: superclass CORRECT: subclass       4 184 Errata in text Corrections in Book Only: Currently Reads: public static average Should Read: public static double average       4 184 Errata in text Corrections in Book Only: In Table 4.3, the empty ‘How?’ cell should be ‘Not without instantiating the object’       4 188 Errata in text Corrections in Book Only: Currently Reads: 4: newNumber(5) Should Read: 4: newNumber(num)       4 191 Errata in text Corrections in Book Only: In the third paragraph, fifth sentence, ‘numbers’ should be ‘number’       4 191 Errata in text Corrections in Book Only: In the first sentence of the overloading methods section, it should say ‘same name’ not ‘same signature’       4 192 Errata in text Corrections in Book Only: Currently Reads: everything other than the method signature can vary for overloaded methods Should Read: everything other than the method name can vary for overloading methods       4 192 Errata in text Corrections in Book Only: Currently Reads: public void fly(int numMiles) { System.out.println(“short”); Should Read: public void fly(int numMiles) { System.out.println(“int”);       4 194 Errata in text Insert spaces after the answer text, preferably using double quotes, such as: [Start of First paragraph] The answer is \"string object \" [Start of Third paragraph] The answer is \"int long \". [Middle of Third paragraph] parameter list, the output becomes \"long long \". (Note the spaces before the second double quotes in each of the three corrections.)       4 199 Errata in text Corrections in Book Only: Currently Reads: When overloading methods, the method name and parameter list needed to match. Should Read: When overloading methods, the method name needs to match       4 203 Errata in text Corrections in Book Only: In the third sentence ‘lines 4 and 5’ should be ‘lines 4, 5 and 6’ when referring to the static initializer       4 204 Errata in text Corrections in Book Only: After ‘output Torchie.’, it should say ‘Line 6 then outputs 1.’       4 206 Errata in text Corrections in Book Only: In Table 4.5, ‘Getter methods begin with is if the property is a boolean’, should be ‘Getter methods begin with is or get if the property is a boolean’ ‘Line 14 doesn’t follow the JavaBeans naming conventions. Since playing is a boolean, the getter must begin with is’ should be ‘Line 14 is correct. SInce playing is a boolean, getter is allowed to begin with get or is’       4 209 Errata in text Corrections in Book Only: ‘that that’ has a duplicate word on the seventh line       4 210 Errata in text Corrections in Book Only: Currently Reads: 1: public class TraditionalSearch Should Read: 1: import java.util.*; public class TraditionalSearch       4 211 Errata in text Corrections in Book Only: ‘Java replies’ should be ‘Java relies’.       4 211 Errata in text Corrections in Book Only: a -&gt; a.canHop(); should be a -&gt; a.canHop()       4 213 Errata in text Corrections in Book Only: ‘Lambdas are allowed to access variables’ is in the real world scenario twice. The first sentence should be removed.       4 216 Errata in text Corrections in Book Only: In the summary section, (a -&gt; a.equals(b) has an extra open paren. It should be a-&gt; a.equals(b)       4 219 Errata in text Corrections in Book and Online: In Point number 7: ‘ClassRoom’ should be ‘Classroom’ In the line 6, “Mrs. Anderson” should be “Mrs. Anderson”       4 222 Errata in text Corrections in Book and Online: In Point number 11: Answers D and E should have an extra space at the end       4 226 Errata in text Corrections in Book and Online: In Point number 19: In the choice G, the closing } is missing       4 229 Errata in text In Point number 25: 1000L should be 100L. This does not affect the correct answer.       4 229 Errata in text Corrections in Book and Online: In Point number 25: Answers A through D should have an extra space at the end       5 237 Errata in text In the first paragraph after the note, second sentence: Remove “subclass or “ in the sentence. Updated sentence should read as: “The default package private modifier, which is the lack of any access modifier, indicates the class can be accessed only by a class within the same package”       5 239 Errata in text Corrections in Book Only: ‘user’ should be ‘use’ in ‘Notice the user of both super() and super(age)’       5 246 Errata in text Corrections in Book Only: “a method a method” should be “a method”       5 247 Errata in text Corrections in Book Only: The numbers output should be 50.0 and 70.0, not 50.00 and 70.00       5 249 Errata in text Corrections in Book Only: ‘The return type void is not a subclass of int’ is reversed. Swap int and void in the sentence       5 249 Errata in text In the last paragraph, ‘on the example’ should be ‘on the exam’         249 Errata in Text Currently reads:’constructor to a constructor’ Should read: ‘method to a method’       5 254 Errata in text Corrections in Book Only: ParentClassName.method() should be super.method()       5 261 Errata in text Corrections in Book Only: In the first sentence, ‘brackets’ should be ‘braces’.       5 263 Errata in text The second to last sentence in the second paragraph should read ‘The key point is that the first concrete class to extend the abstract class must implement all inherited abstract metthods’.       5 265 Errata in text In the First numbered list entitled “Abstract Class Definition Rules”, item #3: Add ‘protected’ to the list of items in the sentence. The words, private/protected/final - should use Inline Code font. Updated sentence should read as: “Abstract classes may not be marked as private, protected, or final.”       5 267 Errata in text Corrections in Book Only: Point number 4 should be - All top-level interfaces areassumed to have public or default access. They are assumed to be abstract whether this keyword is used or not. Therefore, making a method private, protected or final will trigger a compiler error as it is incompatible with these assumptions.       5 269 Errata in text Corrections in Book Only: ‘using the extend keyword’ should be ‘using the extends keyword’       5 272 Errata in text Corrections in Book Only: The second Bear class should have //DOES NOT COMPILE on line 1 as well.       5 274 Errata in text Corrections in Book Only: ‘The compile will’ should be ‘The compiler will’       5 285 Errata in text Corrections in Book Only: At the bottom of the page, the coding ‘Feeding reptile’ should be ‘Feeding:’       5 276 Errata in text Corrections in Book Only: At the bottom of the page, ‘the following class’ should say ‘the following interface’       5 291 Errata in text Corrections in Book and Online: In Point number 2: Choice E should reference line 7, not line 8       5 294 Errata in text Corrections in Book and Online: In Point number 10: In choice C, ‘extend’ should be ‘extends’       5 295 Errata in text Corrections in Book and Online: In Point number 13: The { is missing on line 1 of the provided code         301 Errata in Text Currently reads:’at mainmethod.Zoo.main(Zoo.java:7)’ Should read: ‘at Zoo.main(Zoo.java:4)’       6 312 Errata in text Corrections in Book Only: “There aren’t any, so the main method throws that new exception” should be “This exception is caught on line 23.”       6 313 Errata in text Corrections in Book Only: Lines 35, 37 and 42 should have a space before the final quote on the line       6 314 Errata in text Corrections in Book Only: In the ClassCastException section, ‘cast an exception to a subclass’ should be ‘cast an object to a subclass’       6 317 Errata in text Corrections in Book Only: ‘Common runtime exceptions’ should be ‘Common checked exceptions’         335 Errata in text Corrections in Book and Online: In Point number 14: In the explanation currently reads: ‘Option B is incorrect because package names are case sensitive’ Should read: ‘Option C is incorrect because package names are case sensitive’         338 Errata in text In Point number 14: In the explanation currently reads: ‘The value of result is computed by adding 4 to the original value of 8’ Should Read: ‘The value of result is computed by adding 8 to the original value of 4’ In Point number 18: The answer should be B (not A)         338 Errata in text Corrections in Book and Online: Corrections in Book and Online: In Point number 17: The explanation should say ‘keep going remains true’ rather than ‘keep going is false’         339 Errata in text Corrections in Book and Online: In Point number 2: The explanation should say ‘Line 8 also compares references but is true since both references point to the object from the string pool. Finally, line 9 compares one object from the string pool with one that was explicitly constructed and returns false.’         340 Errata in text Corrections in Book and Online: In Point number 10: The explanation should say ‘The if statement on line 18 returns true because’ rather than ‘The if statement on line 18 returns true’ In Point number 4: In the explanation, abbbaa has an extra b. There should only be two b’s.         341 Errata in text Corrections in Book and Online: In Point number 14: The explanation should say ‘Option B does not reverse the string’ rather than ‘Option B is a nice distraction resulting avaJ’ The explanation should say ‘starting with 0’ rather than ‘starting with 1’         342 Errata in text Corrections in Book and Online: In Point number 26: The explanation should say ‘The code does compile’ rather than ‘The code does not compile’       Appendix A 344 Errata in text Corrections in Book and Online: In Point number 9: A,C,E. Options B and D are incorrect because they don’t follow the naming convention of beginning with get/is/set. Options C and E follow normal getter and setter conventions. Option A is correct, but the book doesn’t explain this and is out of scope for the exam so give yourself credit if you answered C and E. Note: The ‘get/is/set’ within the explanation should be styled as Inline Code.         344 Errata in text Corrections in Book and Online: In Point number 10: should say ‘swing ‘ instead of ‘swing’ (missing space)         344 Errata in text Corrections in Book and Online: We autobox to objects so it should say ‘can be autoboxed to a Boolean’ rather than ‘boolean’ and ‘autoboxed to a Double’ rather than ‘double’         344 Errata in text Corrections in Book and Online: In Point number 17: ‘pass by reference’ should be ‘pass by value’         345 Errata in text Corrections in Book and Online: In Point number 23: In the explanation, ‘created on line 4’ should be ‘created on line 12’ and ‘created on line 5’ should be ‘created on line 13’         346 Errata in text Corrections in Book and Online: In Point number 2: The last sentence of the explanation should be removed         347 Errata in text Corrections in Book and Online: In Point number 8: In the first sentence of the explanation, ‘public and static’ should be ‘public, static and final’         347 Errata in text Corrections in Book and Online: In Point number 3: ‘CanHope’ should be ‘CanHop’         348 Errata in text Corrections in Book and Online: In Point number 18: In the explanation, ‘since int is not a subclass of String’ should be ‘since String is not a subclass of int’         350 Errata in text Corrections in Book and Online: In Point number 8: ‘try try’ should be ‘the try’       作者博客的非官方Errata作者的博客也有个页面维护了包括WILEY官方和读者提供的非官方Errata，地址在 https://www.selikoff.net/java-oca-8-programmer-i-study-guide/ " }, { "title": "EST 基础测试回顾", "url": "/2019/10/07/ets-foundation-test-review/", "categories": "", "tags": "Java, OCA", "date": "2019-10-07 00:00:00 +0800", "snippet": "基础测试的情况测试报告当时第一次测试结果报告如下：按照考试的主题（或者说考点）来看的话，Java Basics 正确率 6/7。然后，OO Concepts 过关的，Java Data Types 部分就只对了 3 题，有点危险。基础测试没有涉及到垃圾回收的内容，但是真正考试应该会有的，而且现在工作要求也肯定会问，需要了解的。关于操作符和条件判断结构居然也只有对了 6 个题，看起来真的有点 tricky。接下来的数组、循环结构和构造方法这些考点感觉还过得去的样子。 关于方法的使用居然有点不稳，要搞清楚了，可能需要翻译 Coderanch 的文章加深一下理解。这次没有涉及方法重载的题目，然而关于继承的理解，可能还不够深，要看看编程思想了。instanceof在继承相关主题没有考到，但在操作符题目里出现了，异常处理方面需要加强。最基本的 String， 以及相关的类要烂熟了，至少 API 文档过一遍。最后 Java 8 新的时间日期 API 还没有了解，这一次就新的旧的都看一遍吧，所以今天是要看完错题，找出对应的知识点，考点，然后读 API 文档。 接下来做什么整理错题 Compared to public, protected, and private accessibilities, default accessibility is … (Working with Methods) Less restrictive than public 肯定错啦，public 最宽了。 More restrictive than public, but less restrictive than protected. 想到 “by default is protect”，默认情况下，就相当于保护了，但是更深一层限制在同一个包里。所以就 default &lt; protected 所以下一个选项是正确的。 More restrictive than protected, but less restrictive than private. More restrictive than private. 肯定错， private 最窄了。 Less restrictive than protected from within a package, and more restrictive than protected from outside a package. 当时选择了这个选项，因为看起来好像很有道理，而且描述全面。但现在仔细看看，说的是，在同一个包内，访问权限比 protected 更受限，这已经错了，同一个包内两个一样的。后面部分就不用看了，当时就没多想，这次知道了，下次就不会错了。 What can be the type of a catch argument? (Select the best option.) (Handling Exceptions) Any class that extends java.lang.Exception Any class that extends java.lang.Exception except any class that extends java.lang.RuntimeException Any class that is-a Throwable. The catch argument type declares the type of exception that the handler can handle and must be the name of a class that extends Throwable or Throwable itself. Any Object Any class that extends Error 记录一个关于重写的： An overriding method must have the same parameter list and the same return type as that of the overridden method. 翻译成中文就是，重写方法必须与被重写方法具有相同的参数列表和返回类型。 True False 我答对了，不过好像没有理解正确。 解释是这样说的： This would have been true prior to Java 1.5. But from Java 1.5, an overriding method is allowed to change the return type to any subclass of the original return type, also known as covariant return type. This does not apply to primitives, in which case, the return type of the overriding method must match exactly to the return type of the overridden method. 所以主要看返回值类型，重写必须参数列表相同才算重写，不然就是重载了。而在 Java 1.5 之前，重写方法的返回值必须与被重写方法返回值一致。不过从 Java 1.5 开始，重写方法的返回值类型可以是被重写方法返回值的任意子类，也称为 covariant return type（好像中文译为“协变返回类型”） Which of the following statements are true?(Working with Inheritance) 选择两个正确的，当时选错了。 Private methods cannot be overridden in subclasses. Only methods that are inherited can be overridden and private methods are not inherited. 只有被继承的方法才能被重写，私有方法不会被继承。 A subclass can override any method in a non-final superclass. Only the methods that are not declared to be final can be overridden. Further, private methods are not inherited so they cannot be overridden either. An overriding method can declare that it throws a wider spectrum of checked exceptions than the method it is overriding. 这个没有在选项给出解释，看底下更长的解释。 The parameter list of an overriding method must be a subset of the parameter list of the method that it is overriding. An overriding method (the method that is trying to override the base class’s method) must have the same parameters. The overriding method may opt not to declare any throws clause even if the original method has a throws clause. No exception(i.e. an empty set of exceptions) is a valid subset of the set of exceptions thrown by the original method so an overriding method can choose to not have any throws clause. A method can be overridden by defining a method with the same signature(i.e. name and parameter list) and return type as the method in a superclass. The return type can also be a subclass of the original method’s return type. Only methods that are accessible can be overridden. A private method cannot, therefore, be overridden in subclasses, but the subclasses are allowed to define a new method with exactly the same signature. A final method cannot be overridden. An overriding method cannot exhibit behavior that contradicts the declaration of the original method. An overriding method, therefore, cannot return a different type (except a subtype) or throw a wider spectrum of exceptions than the original method in the superclass. This, of course, applies only to checked exceptions because unchecked exceptions are not required to be declared at all. A subclass may have a static method with the same signature as a static method in the base class but it is not called overriding. It is called hiding because the concept of polymorphism doesn’t apply to static members. 这部分这有点意思，之前没有了解到。关于方法重写和重载，还有静态成员的知识。对于静态方法，子类中具有与父类相同方法签名的静态方法，不叫重写，叫隐藏，因为多态的概念不适用于静态成员。 Given: (Working with Methods) //In file AccessTest.java package a; public class AccessTest { int a; private int b; protected void c() {} public int d() { return 0; } } //In file AccessTester.java package b; import a.AccessTest; public class AccessTester extends AccessTest { public static void main(String[] args) { AccessTest ref = new AccessTest(); } } Identify the correct statements - Only c() and b() can be accessed by ref. b, c() as well as d(), can be accessed by ref. Only d() can be accessed by ref. Only a and d() can be accessed by ref. The wording of this question is a bit vague because it is not clear what is meant by “can be accessed by”. Expect such wording in the real exam as well. Our guess is that it means what variables of class AceesssTest can be accessed using the reference named ref. Since a public member is always accessible to everyone, ref.d() is definitely correct. private is only accessible within that class, therefore, b cannot be accessed from anywhere outside of class AccessTest. A default (aka package protected) member is accessible only from members of the same package. Since AccessTester is in a different package a cannot be accessed from AccessTester either. Now, the question is only about the method c(). A protected member is inherited by a subclass and it is therefore accessible in the subclass. However, in the words of Java Language Specification, protected members of a class are accessible outside the package only in subclasses of that class, and only when they are fields of objects that are being implemented by the code that is accessing them. Basically, it implies that a protected member is accessible in the subclass only using a reference whose declared type is of the same subclass (or its subclass.). In this case, the declared type of ref is AccessTest, which is not of the same type as the class from which you are trying to access c(). Therefore, you cannot do ref.c() in AccessTester. If you had AccessTester ref = new AccessTester(); you could do ref.c() because now the declared type of ref(i.e. AccessTester) is the same subclass from which you are trying to access c(). It will work even if the declared type of the reference is a child of the subclass. For example, the following would be valid as well. SubAccessTester ref = new SubAccessTester(); ref.c(); // this is valid Where SubAccessTester is a subclass of AccessTester - class SubAccessTester extends AccessTester {} Which of these statements concerning the use of modifiers are true? (Java Basics) By default (i.e. no modifier) the member is only accessible to classes in the same package and subclasses of the class. No. the member will be accessible only within the package. You cannot specify visibility of local variables. They are always only accessible within the block in which they are declared. Local variable always have default accessibility. A local variable (aka automatic variable) means a variable declared in a method. They don’t have any accessibility. They are accessible only from the block they are declared in. Remember, they are not initialized automatically. You have to initialize them explicitly. Local variables can be declared as private. Local variables can only be declared as public. You cannot apply any modifier except final to a local variable. i.e. you cannot make them transient, volatile, static, public, and private. But you can apply access modifier (public private and protected) and final, transient, volatile, static to instance variables. You cannot apply native and synchronized to any kind of variable. 这些很经典的基础，关键词的运用，必须熟记。 An abstract method cannot be overridden. (Working with inheritance) True False Abstract methods are meant to be overridden in the subclass. Abstract methods describe behavior but do not implement it. So the subclasses have to override it to actually implement the behavior. A subclass may choose to override it, in which case, the subclass will have to be abstract too. What is the correct declaration for an abstract method ‘add’ in a class that is accessible to any class, takes no arguments and returns nothing? (You had to select 1 option) public void add(); An abstract method must have the abstract keyword and must not have a method body i.e. {}. abstract add(); A method that is not supposed to return anything must specify void as its return type. abstract null add(); A method that is not supposed to return anything must specify void as its return type. null is not a type, though it is a valid return value for any reference type. abstract public void add(); It is invalid because has a method body i.e. {}. 有方法体都不可以。 abstract public void add() throws Exception; Which of the following are correct about java.util.function.Predicate? It is an interface that has only one abstract method (among other non-abstract methods) with the signature - public void test(T t); It is an interface class that has only one abstract method (among other non-abstract methods) with the signature - public boolean test(T t); It is an abstract class that has only abstract method (among other non-abstract methods) with the signature - public abstract void test(T t); It is an abstract class that has only on abstract method (among other non-abstract methods) with the signature - public abstract boolean test(T t); java.util.function.Predicate is one of the several functional interfaces that have been added to Java 8. This interface has exactly one abstract method named test, which takes any object as input and returns a boolean. This comes in very handy when you have a collection of objects and you want to go through each object of that collection and see if that object satisfies some criteria. For example, you may have a collection of Employee objects and, in one place of your application, you want to remove all such employees whose age is below 50, while in other place, you want to remove all such employees whose salary is above 100,000. In both the cases, you want to go through your collection of employees and check each Employee object to determine if it fits the criteria. This can be implemented by writing an interface named CheckEmployee and having a method check(Employee) which would return true if the passed object satisfies the criteria. The following code fragments illustrate how it can be done - //define the interface for creating criteria interface CheckEmployee { boolean check(Employee e); } ...//write a method that filters Employees based on given criteria. public void filterEmployees(ArrayList&lt;Employee&gt; dataList, CheckEmployee p) { Iterator&lt;Employee&gt; i = dataList.iterator(); while(i.hasNext()) { if(p.check(i.next())) { i.remove(); } } } ... //create a specific criteria by defining a class that implements CheckEmployee class MyCheckEmployee implements CheckEmployee { public boolean check(Employee e) { return e.getSalary()&gt;100000; } } ... //use the filter method with the specific criteria to filter the collection. filterEmployees(employeeList, new MyCheckEmployee()); This is a very common requirement across applications. The purpose of Predicate interface (and other standard functional interfaces) is to eliminate the need for every application to write a customized interface. For example, you can do the same thing with the Predicate interface as follows public void filterEmployees(ArrayList&lt;Employee dataList, Predicate&lt;Employee&gt; p) { Iterator&lt;Employee&gt; i = dataList.iterator(); while(i.hasNext()) { if(p.test(i.next())) { i.remove(); } } } ... // Instead of defining a MyPredicate class (like we did with MyCheckEmployee), we could also define and instantiate an anonymous inner class to reduce code clutter Predicate&lt;Employee&gt; p = new Predicate&lt;Employee&gt;() { public boolean test(Employee e) { return e.getSalary()&gt;1000000; } } ... filterEmployees(employeeList, p); Note that both the interfaces (CheckEmployee and Predicate) can be used with lambda expressions in exactly the same way. Instead of creating an anonymous inner class that implements the CheckEmployee or Predicate interface, you could just do - filterEmployees(employeeList, e -&gt; e.getSalary()&gt;1000000); The benefit with Predicate is that you don’t have to write it, It is already there in the standard java library. Which of the following are valid declarations in a class? (You had to select 1 option) (Working with Inheritance) abstract int absMethod(int param) throws Exception; abstract native int absMethod(int param) throws Exception; native method cannot be abstract float native getVariance() throws Exception; return type should always be on the immediate left of the method name. abstract private int absMethod(int param) throws Exception; private method cannot be abstract. A private method is not inherited so how can a subclass implement it? Which of the following statements is/are true? (You had to select 1 option) Subclasses must define all the abstract methods that the superclass defines. Not if the subclass is also defined abstract! A class implementing an interface must define all the methods of that interface. Not if the class is defined abstract. Further, Java 8 allows interface to have and static methods, which need not be implemented by a non-abstract class that says it implements that interface. A class cannot override the super class’s constructor. Because constructors are not inherited. It is possible for two classes to be the superclass of each other. An interface can implement multiple interfaces. Interface cannot “implement” other interfaces. It can extend multiple interfaces. The following is a valid declaration interface I1 extends I2, I3, I4 {}。 记得了，接口是不可以实现其它接口的，但是可以实现多个接口。 Which of the following statements regarding ‘break’ and ‘continue’ are true? (You had to select 1 option) (Using Loop Constructs) 这题选错了，注意。 break without a label, can occur only in a switch, while, do, or for statement. continue without a label, can occur only in a switch, while, do, or for statement. It cannot occur in a switch. break can never occur without a label. continue can never occur WITH a label. None of the above. A break statement with no label attempts to transfer control to the innermost enclosing switch, while, do, or for statement; this statement, which is called the break target, then immediately completes normally. If no switch, while, do, or for statement encloses the break statement, a compile-time error occurs. A break statement with label Identifier attempts to transfer control to the enclosing labeled statement that has the same identifier as its label; this statement, which is called the break target, then immediately completes normally. In this case, the break target need not be a while, do, for, or switch statement. A continue statement with no label attempts to transfer control to the innermost enclosing while, do, or for statement; this statement, which is called the continue target, then immediately ends the current iteration and begins a new one. If no while, do, or for statement encloses the continue statement, a compile-time error occurs. A continue statement with label identifier attempts to transfer control to the enclosing labeled statement that has the same identifier as its label; that statement, which is called the continue target, then immediately ends the current iteration and begins a new one. The continue target must be a while, do, or for statement or a compile-time error occurs. If no labeled statement with identifier as its label contains the continue statement, a compile-time error occurs. What class of objects can be declared by the throws clause? (Handling Exceptions) Exception Error Event Object RuntimeException You can declare anything that is a Throwable or a subclass of Throwable, in the throws clause. Identify the valid members of Boolean class. parseBoolean(String) valueOf(boolean) parseBoolean(boolean) FALSE TRUE and FALSE are valid static members of Boolean class. Boolean(Boolean) There is no constructor that takes a Boolean. You need to remember the following points about Boolean: Boolean class has two constructors - Boolean(String) and Boolean(boolean) The String constructor allocates a Boolean object representing the value true if string argument is not null and is equal, ignoring case, to the string “true”. Otherwise, allocate a Boolean object representing the value false. Examples: new Boolean(\"True\") produces a Boolean object that represents true. new Boolean(\"yes\") produces a Boolean object that represents false. The boolean constructor is self-explanatory. Boolean class has two static helper methods for creating booleans - parseBoolean and valueOf. Boolean.parseBoolean(String ) method returns a primitive boolean and not a Boolean object (Note - Same as with the case with other parseXXX methods such as Integer.parseInt - they return primitives and not objects). The boolean returned represents the value true if the string argument is not null and is equal, ignoring case, to the string “true”. Boolean.valueOf(String ) and its overloaded Boolean.valueOf(boolean ) version, on the other hand, work similarly but returns a reference to either Boolean.TRUE or Boolean.FALSE wrapper objects. Observe that they don’t create a new Boolean object but just return the static constants TRUE or FALSE defined in Boolean class. When you use the equality operator ( == ) with booleans, if exactly one of the operands is a Boolean wrapper, it is first unboxed into a boolean primitive and then the two are compared (JLS 15.21.2). If both are Boolean wrappers, then their references are compared just like in the case of other objects. Thus, new Boolean(\"true\") == new Boolean(\"true\") is false, but new Boolean(\"true\") == Boolean.parseBoolean(\"true\") is true. (Working with Inheritance) A method with no access modifier defined in a class can be overridden by a method marked protected (assuming that it is not final) in the subclass. (You had to select 1 option) True False An overriding method is allowed to make the overridden method more accessible, and since protected is more accessible than default (package), this is allowed. Note that protected access will allow access to the subclass even if the subclass is in a different package but package access will not. Which of the following are NOT valid operators in Java? (Using Operators and Decision Constructs) sizeof It is a valid operator in C++ but not in java because the size of everything is known at compile time and is not machine dependent. &lt;&lt;&lt; For left shifts there is no difference between shifting signed and unsigned values so there is only one leftshift '&lt;&lt;' in java. instanceof 这个居然也算是运算符，记混了，以为只是关键字！ mod No such thing. equals boolean equals(Object o) is a method in java.lang.Object. It is not an operator. Which of these statements are true? All classes must explicitly define a constructor. A default no args one will be provided if not defined any. A constructor can be declared private. This feature is used for implementing Singleton Classes. 单例模式，要可以手写。 A constructor can declare a return value. A constructor must initialize all the member variables of a class. All non-final instance variables get default values if not explicitly initialized. A constructor can access the non-static members of a class. A constructor is non-static, and so it can access directly both the static and non-static members of the class. Constructors need not initialize all the member variables of the class. A non-final member(i.e. an instance) variable will be assigned a default value if not explicitly initialized. Which of these statements are true? (You had to select 2 option(s)) (Working with Inheritance) A super(&lt;appropriate list of arguments&gt;) or this(&lt;appropriate list of arguments&gt;) call must always be provided explicitly as the first statement in the body of the constructor. super(); is automatically added if the subclass constructor doesn’t call any of the super class’s constructors. If a subclass does not have any declared constructors, the implicit default constructor of the subclass will have a call to super(). If neither super() or this() id declared as the first statement of the body of a constructor, then this() will implicitly be inserted as the first statement. super() is added and not this() super(&lt;appropriate list of arguments&gt;) can only be called in the first line of the constructor but this(&lt;appropriate list of arguments&gt;) can be called from anywhere. You can either call super(&lt;appropriate list of arguments&gt;) or this(&lt;appropriate list of arguments&gt;) but not both from a constructor. Note that calling super(); will not always work because if the superclass has defined a constructor with arguments and has not defined a no args constructor then no args constructor will not be provided by the compiler. It is provided only to the class that does not define ANY constructor explicitly. Which of these combinations of switch expression types and case label value types are legal within a switch statement? (You had to select 1 option(s)) (Using Operators and Decision Constructs) switch expression of type int and case label value of type char. Note that the following is invalid though because a char cannot be assigned to an Integer. Integer x = 1; // int x = 1; is valid. switch(x) { case 'a' : System.out.println(\"a\"); } switch expression of type float and case label value of type int. switch expression of type byte and case label value of type float. switch expression of type char and case label value of type byte. This will not work in all cases because a byte may have negative values which cannot be assigned to a char. For example, char ch = -1; does not compile. Therefore, the following does not compile either: char ch = 'x';switch (ch) { case -1 : System.out.println(\"-1\"); break; // This will not compile: possible loss of precision default: System.out.println(\"default\"); } switch expression of type boolean and case label value of type boolean. You should remember the following rules for a switch statement: Only String, byte, char, short, int, and enum values can be used as types of a switch variable. (String is allowed since Java 7.) Wrapper classes Byte, Character, Short, and Integer are allowed as well. The case constants must be assignable to the switch variable. For example, if your switch variable is of class String, your case labels must use Strings as well. The switch variable must be big enough to hold all the case constants. For example, if the switch variable is of type char, then none of the case constants can be greater than 65535 because a char’s range is from 0 to 65535. Similarly, the following will not compile because 300 cannot be assigned to ‘by’, which can only hold values from -128 to 127. byte by = 10; switch(by){ case 200 : //some code; case 300 : //some code; } All case labels should be COMPILE TIME CONSTANTS. No two of the case constant expressions associated with a switch statement may have the same value. At most one default label may be associated with the same switch statement. Consider the following code: public class Conversion { public static void main(String[] args) { int i = 1234567890; float f = i; System.out.println( i - (int)f); } } What will it print when run? It will print 0. It will not print 0. It will not compile. It will throw an exception at runtime. None of the above. Actually, it prints -46. This is because the information was lost during the conversion from type int to type float as values of type float are not precise to nine significant digits. Note: You are not required to know the number of significant digits that can be stored by a float for the exam. However, it is good to know about the loss of precision while using float and double. Which of the following statements are true? (You had to select 2 option(s)) private keyword can never be applied to a class. private, protected and public can be applied to nested class. Although not too important for the exam, you should still know the following terminology: A top level class is a class that is not a nested class. A nested class is any class whose declaration occurs within the body of another class or interface. synchronized keyword can never be applied to a class. synchronized keyword may be applied to a non-primitive variable. It can only be applied to a method or a block. final keyword can never be applied to a class. It can be applied to class, variable and methods. A final variable can be hidden in a subclass. If the class declares a field with a certain name, then the declaration of that field is said to hide any and all accessible declarations of fields with the same name in superclasses and superinterfaces of the class. For example, class Base{ int i=10; } class Sub extends Base{ int i=20; //This i hides Base's i. } ... Sub s = new Sub(); int k = s.i; //assigns 20 to k. k = ((Base)s).i;//assigns 10 to k. The cast is used to show the Base's i. Base b = new Sub(); k = b.i;//assigns 10 to k because which field is accessed depends on the class of the variable and not on the class of the actual object. The same rule applies to static methods but the opposite is true for instance methods. final keyword when applied to a class means the class cannot be subclassed, when applied to a method means the method cannot be overridden (it can be overloaded though) and when applied to a variable means that the variable is a constant. (Working with Java API - Time and Date) Identify the correct statements. LocalDate, LocalTime, and LocalDateTime extend Date. LocalDate, LocalTime, and LocalDateTime implement TemporalAccessor. Both - LocalDate and LocalTime extend LocalDateTime, which extends java.util.Date. LocalDate, LocalTime, and LocalDateTime implement TemporalAccessor and extend java.util.Date. Here are some points that you should keep in mind about the new Date/Time classes introduced in Java 8 - They are in package java.time and they have no relation at all to the old java.util.Date and java.sql.Date. java.time.temporal.TemporalAccessor is the base interface that is implemented by LocalDate, LocalTime, and LocalDateTime concrete classes. This interface defines read-only access to temporal objects, such as a date, time, offset or some combination of these, which are represented by the interface TemporalField. LocalDate, LocalTime, and LocalDateTime classes do not have any parent/child relationship among themselves. As their names imply, LocalDate contains just the date information and no time information, LocalTime contains only time and no date, while LocalDateTime contains date as well as time. None of them contains zone information. For that, you can use ZonedDateTime. These classes are immutable and have no public constructors. You create objects of these classes using their static factory methods such as of(…) and from(TemporalAccessor ). For example, LocalDate ld = LocalDate.of(2015, Month.JANUARY, 1); or LocalDate ld = LocalDate.from(anotherDate); or LocalDateTime ldt = LocalDateTime.of(2015, Month.JANUARY, 1, 21, 10); //9.10 PM Since you can’t modify them once created, if you want to create new object with some changes to the original, you can use the instance method named with(…). For example, LocalDate sunday = ld.with(java.time.temporal.TemporalAdjusters.next(DayOfWeek.SUNDAY)); Formatting of date objects into String and parsing of Strings into date objects is done by java.time.format.DateTimeFormatter class. This class provides public static references to readymade DateTimeFormatter objects through the fields named ISO_DATE, ISO_LOCAL_DATE, ISO_LOCAL_DATE_TIME, etc. For example LocalDate d1 = LocalDate.parse(\"2015-01-01\", DateTimeFormatter.ISO_LOCAL_DATE); The parameter type and return type of the methods of DateTimeFormatter class is the base interface TemporalAccessor instead of concrete classes such as LocalDate or LocalDateTime. So you shouldn’t directly cast the returned values to concrete classes like this - LocalDate d2 = (LocalDate) DateTimeFormatter.ISO_LOCAL_DATE.parse(\"2015-01-01\"); //will compile but may or may not throw a ClassCastException at runtime. You should do like this - LocalDate d2 = LocalDate.from(DateTimeFormatter.ISO_LOCAL_DATE.parse(\"2015-01-01\")); Besides dates, java.time package also provides Period and Duration classes. Period is used for quantity or amount of time in terms of years, months and days, while Duration is used for quantity or amount of time in terms of hour, minute, and seconds. Durations and periods differ in their treatment of daylight savings time when added to ZonedDateTime. A Duration will add an exact number of seconds, thus a duration of one day is always exactly 24 hours. By contrast, a Period will add a conceptual day, trying to maintain the local time. For example, consider adding a period of one day and a duration of one day to 18:00 on the evening before a daylight savings gap. The Period will add the conceptual day and result in a ZonedDateTime at 18:00 the following day. By contrast, the Duration will add exactly 24 hours, resulting in a ZonedDateTime at 19:00 the following day (assuming a one hour DST gap). (Q 40 of 69 Working with Java API - Time and Date) Which of the following are true regarding the new Date-Time API of Java 8? (You had to select 2 option(s)) It uses the calendar system defined in ISO-8601 as the default calendar. This calendar is based on the Gregorian calendar system and is used globally as the defacto standard for representing date and time. The core classes in the Date-Time API have names such as LocalDateTime, ZonedDateTime, and OffsetDateTime. All of these use the ISO calendar system. If you want to use an alternative calendar system, such as Hijrah or Thai Buddhist, the java.time.chrono package allows you to use one of the predefined calendar systems. Or you can create your own. Most of the actual date related classes in the Date-Time API such as LocalDate, LocalTime, and LocalDateTime are immutable. These classes do not have any setters. Once created you cannot change their contents. Even their constructors are private. LocalDateTime includes time zone information but LocalDate does not. None of LocalDate, LocalDateTime, or LocalTime store zone information. java.time.ZonedDateTime does. ZonedDateTime is an immutable representation of a date-time with a time-zone. This class stores all date and time fields, to a precision of nanoseconds, and a time-zone, with a zone offset used to handle ambiguous local date-times. For example, the value “2nd October 2007 at 13:45:30.123456789 +02:20 in the Europe/Paris time-zone” can be stored in a ZonedDateTime. ZonedDateTime is not listed in official exam objectives. To create a LocalDate or a LocalDateTime object, you can use one of their several constructors. These classes do not have any public constructors. You need to use their static factory methods to get their instances. For example: java.time.LocalDate d1 = java.time.LocalDate.of(2015, Month.JANUARY, 31); java.time.LocalDateTime d2 = java.time.LocalDateTime.of(2015, Month.JANUARY, 31, 10, 56); java.time.LocalDateTime d3 = java.time.LocalDateTime.parse(\"2015-01-02T17:13:50\"); //Note that this will throw a java.time.format.DateTimeParseException if the input string lacks the time component i.e. T17:13:50 java.time.LocalDate d4 = java.time.LocalDate.parse(\"2015-01-02\"); //Note that this will throw a java.time.format.DateTimeParseException if the input string contains the time component java.time.LocalTime d5 = java.time.LocalTime.parse(\"02:13:59.985\"); //Note that this will throw a java.time.format.DateTimeParseException if the input string contains the Date component. Which of the following statements concerning the switch construct are true? (You had to select 3 option(s)) A character literal can be used as a value for a case label. boolean, long, float and double cannot be used. A ‘long’ cannot be used as a switch variable. boolean, long, float and double cannot be used. An empty switch block is a valid construct. A switch block must have a default label. If present, the default label must be the last of all the labels. Any order is valid. Here are the rules for a switch statement: Only String, byte, char, short, int, (and their wrapper classes Byte, Character, Short, and Integer), and enums can be used as types of a switch variable. (String is allowed only since Java 7). The case constants must be assignable to switch variable. For example, if your switch variable is of class String, your case labels must use String as well. The switch variable must be big enough to hold all the case constants. For example, if the switch variable is of type char, then none of the case constants can be greater than 65535 because a char’s range is from 0 to 65535. All case labels should be COMPILE TIME CONSTANTS. No two of the case constant expressions associated with a switch statement may have the same value. At most one default label may be associated with the same switch statement. How can you declare a method someMethod() such that an instance of the class is not needed to access it and all the members of the same package have access to it? public static void someMethod() static void someMethod() protected static void someMethod() void someMethod() protected void someMethod() public abstract static void someMethod() static methods can’t be abstract. Since the question says, “…an instance of the class is not needed…”, the method has to be static. Also, as the question does not say that other packages should not have access to the method so public or protected is also correct. Objects of which of the following classes can be thrown using a throw statement? (Handling Exceptions) Event Object Throwable Exception RuntimeException You can only throw a Throwable using a throws clause. Exception and Error are two main subclasses of Throwable. In which of these variable declarations, will the variable remain uninitialized unless explicitly initialized? (You had to select 1 option(s)) Declaration of an instance variable of type int. Declaration of a static class variable of type float. Declaration of a local variable of type float. Declaration of a static class variable of class Object. Declaration of an instance variable of class Object. We have to explicitly initialize local variables otherwise they remain uninitialized and it will be a compile time error if such variables are accessed without getting initialized first. Instance variables and static variables receive a default value if not explicitly initialized. All primitive types get a default value equivalent to 0, that is, int to 0 and float to 0.0f and so on and boolean to false. The type/class of a variable does not affect whether a variable is initialized or not. A try statement must always have a … associated with it. catch throws finally catch, finally or both throw A try without resources must have either a catch or a finally. It may have both as well. Thus, the following constructs are valid: try{ } catch(Exception e){ } // no finally try{ } finally{ } // no catch try{ } catch(Exception e) { } finally{ } A catch can catch multiple exceptions: try{ } catch(Exception1 | Exception2 | Exception3 e) { } Note: try with resources (which is not on this exam) may omit catch as well as finally blocks. Which of the following classes should you use to represent just a date without any time or zone information? (Working with Java API - Time and Date) java.util.Date java.sql.Date java.time.Date java.time.LocalDate Java 8 introduces a new package java.time to deal with dates. The old classes such as java.util.Date are not recommended anymore. Briefly: java.time Package: This is the base package of new Java Date Time API. All the commonly used classes such as LocalDate, LocalTime, LocalDateTime, Instant, Period, Duration are part of this package. All of these classes are immutable and thread safe. java.time.format Package: This package contains classes used for formatting and parsing date time objects such as java.time.format.DateTimeFormatter. (The following two are not important for the exam.) java.time.zone Package: This package contains classes for supporting different time zones and their rules. java.time.chrono Package: This package defines generic APIs for non ISO calendar systems. We can extend AbstractChronology class to create our own calendar system. java.time.temporal Package: This package contains temporal objects and we can use it for find out specific date or time related to date/time object. For example, we can use these to find out the first or last day of the month. You can identify these methods easily because they always have format “withXXX”. Consider the following variable declaration within the definition of an interface: int i = 10; Which of the following declarations defined in a non-abstract class, is equivalent to the above? (You had to select 1 option(s)) public static int i = 10; public final int i = 10; public static final int i = 10; public int i = 10; final int i = 10; Fields in an interface are implicitly public, static and final. Although you can put these words in the interface definition but it is not a good practice to do so. Which of the following statements are true? (You had to select 2 option(s)) The modulus operator % can only be used with integer operands. It can be used on floating points operands also. For example, 5.5 % 3 = 2.5 &amp; can have integral as well as boolean operands. The arithmetic operators *, / and % have the same level of precedence. &amp;&amp; can have integer as well as boolean operands. !, &amp;&amp; and || operate only on booleans. ~ can have integer as well as boolean operands. ~ Operates only on integral types. Note : integral types means byte, short, int, long, and, char As per Section 4.1 of JLS 8 - The integral types are byte, short, int, and long, whose values are 8-bit, 16-bit, 32-bit, and 64-bit signed two’s-complement integers, respectively, and char, whose values are 16-bit unsigned integers representing UTF-16 code units. Which of the following statements are correct? (You had to select 3 option(s)) An abstract class can be extended by an abstract or a concrete class. A concrete class can be extended by an abstract class or a concrete class. An interface can be extended by another interface. An interface can be extended by an abstract class. A class “implements” an interface. It does not “extend” an interface. An interface can be extended by a concrete class. An abstract class cannot implement an interface. Any class, whether abstract or concrete, can implement any interface. Which statements concerning conversion are true? (You had to select 4 option(s)) Conversion from char to long does not need a cast. Conversion from byte to short does not need a case. Conversion from short to char needs a cast. Conversion from int to float needs a cast. It does not need a cast because a float can hold any value of int. Note that the opposite is not true because of the loss of precision. Conversion from byte, char, or short to int, long or float does not need a case. Because int, long, or float are bigger than byte char or short. Think of it as transferring the contents of one bucket into another. You can always transfer the contents of a smaller bucket to a bigger one. But the opposite is not always possible. You can transfer the contents of the bigger bucket into the smaller bucket only if the actual content in the bigger bucket can fit into the smaller one. Otherwise, it will spill. It is the same with integral types as well. byte is smaller than short or int. So you can assign a byte to an int (or an int to a float, or a float to a double) without any cast. But for the reverse, you need to assure the compiler that the actual contents in my int will be smaller than a byte so let me assign this int to a byte. This is achieved by the cast. int i = 10; byte b = 20; b = i;//will not compile because byte is smaller than int b = (byte) i; //OK Further, if you have a final variable and its value fits into a smaller type, then you can assign it without a cast because the compiler already knows its value and realizes that it can fit into the smaller type. This is called implicit narrowing and is allowed between byte, int, char, and, short but not for long, float, and double. final int k = 10; b = k; //Okay because k is final and 10 fits into a byte final float f = 10.0;//will not compile because 10.0 is a double even though the value 10.0 fits into a float i = f;//will not compile. Which of the following statements are correct regarding a functional interface? (Lambda Expressions) It has exactly one method and it must be abstract. It has exactly one method and it may or may not be abstract. It must have exactly one abstract method and may have other default or static methods. It must have exactly one static method and may have other default or abstract methods. A functional interface is an interface that contains exactly one abstract method. It may contain zero or more default methods and/or static methods. Because a functional interface contains exactly one abstract method, you can omit the name of that method when you implement it using a lambda expression. For example, consider the following interface - interface Predicate&lt;T&gt; { boolean test(T t); } The purpose of this interface is to provide a method that operates on an object of class T and returns a boolean. You could have a method that takes an instance of class that implements this interface defined like this - public void printImportantData(ArrayList&lt;Data&gt; dataList, Predicate&lt;Data&gt; p){ for(Data d: dataList) { if(p.test(d)) System.out.println(d); } } where Data class could be as simple as public class Data { public int value;} Now, you can call the above method as follows: printImportantData(al, (Data d)-&gt;{ return d.value&gt;1;}); Notice the lack of method name here. This is possible because the interface has only one abstract method so the compiler can figure out the name. This can be shortened to: printImportantData(al, (Data d)-&gt;d.value&gt;1); Notice the lack of curly brackets, the return keyword, and the semicolon. This is possible because the method returns a boolean and the expression d.value&gt;1 also returns a boolean. The compiler is, therefore, able to figure out that the value of this expression is to be returned from the method. This can be shortened even more to: printImportantData(al, d-&gt;d.value&gt;1); Notice that there is no declaration of d! The compiler can figure out all the information it needs because the interface has only one abstract method and that method has only one parameter. So you don’t need to write all those things in your code. Compare the above approach to the old style using an inner class that does the same thing - printImportantData(al, new Predicate&lt;Data&gt;() { public boolean test(Data d) { return d.value &gt; 1; } }); The Predicate interface described above can be used anywhere there is a need to “do something with an object and return a boolean” and is actually provided by the standard java library in java.util.function package. This package provides a few other useful functional interfaces. Predicate&lt;T&gt; Represents a predicate (boolean-valued function) of one argument of type T. Consumer&lt;T&gt; Represents an operation that accepts a single input argument of type T and returns no result. Function&lt;T,R&gt; Represents a function that accepts one argument of type T and produces a result of type R Supplier&lt;T&gt; Represents a supplier of results of type T. For the exam, you only need to be aware of Predicate. Please see Lambda Expressions for learning Lambda expressions in Java. 结束这个错题整理也太长了，到这里结束了，其他内容放到其他文章。" }, { "title": "Java核心技术及面试指南读书记录", "url": "/2019/09/29/core-java-interview-cracking/", "categories": "", "tags": "Java, 面试笔试", "date": "2019-09-29 21:42:02 +0800", "snippet": "目录第1章　带你走进Java的世界1.1　搭建Java开发环境，运行基本程序1.1.1　在MyEclipse中开发第一个Java程序 1.1.2　第一个程序分析容易犯的错误 1.1.3　开发稍微复杂带函数调用的程序 1.1.4　可以通过Debug来排查问题 1.1.5　输入运行时的参数 1.1 这个小节基本可以略过了，内容很基础，习惯使用IntelliJ IDEA，内容不太适用。1.2　遵循规范，让你的代码看上去很专业1.2.1　注意缩进 1.2.2　规范命名1.2.3　在必要的地方加注释，让别人能看懂你的代码 1.2.4　把不同类型的代码放入不同的类、不同的包（package） 1.2 小节页没有什么，都了解过了1.3　高效学习法，让你不再半途而废1.3.1　在公司项目中，Web是重点，Core是基础 这个的确是，按照招聘要求，调整学习技术的重点，要用到MyBatis就学习，之前用Spring Data JPA比较多。 架构技术 - 负载均衡、消息服务等 Java Web 技术 - Spring MVC + MyBatis Core 技术 - 集合、数据库、IO、异常处理1.3.2　Core和Web知识点的学习路线图 一个月的学习进度？接下来大概有半个月准备 OCA，实际内容相当于 Java Core。而且路线图的内容有不少已经学习过了，不太适用我的实际情况。1.3.3　从基本的LinkedList入手，分享一些学习方法 这个可以作为一个切入点，深入集合框架的学习。以及回顾数据结构与算法，笔试常见的与链表相关的题目。1.3.4　除非有特殊的需求，否则可以延后学习的知识点 除了OCA跳不过，其他有很多内容是可以延后学习的。有很多内容是用不到的。1.3.5　以需求为导向，否则效率不高 目前与找工作为导向，Job oriented，还有 exam driven，所以下一步就是整理提炼，已经投递了的职位的要求，了解市场需要具备什么技能的程序员，面试多几次，积累经验，要有反馈，能够快速调整。 Done is better than perfect. 深入了解最常用的，其他不常用的了解即可。1.3.6　提升能力后，成功跳槽时常见的忧虑 大胆尝试 第一章看完了。第2章　基本语法中的常用技术点精讲2.1　基本数据类型、封装类和基本运算操作2.1.1　从int和Integer来区别基本数据类型和封装类 这部分要熟记基本数据类型的取值范围，要精确记住，记得有几多位，记得读出来是多少。 数据类型 范围 byte -128~127 short -32768 $(-2^{15})$ 到 32767 $(2^{15} - 1)$ int $-2^{32}$ 到 $2^{32} - 1$ 也就是 -4294967296 到 4294967295 long $-2^{63}$ 到 $2^{63} - 1$ float $3.4e-038$~$3.4e+038$ double $1.7e-308$~$1.7e+308$ char \\u0000~\\uffff boolean true 或 false 然后关于基本数据类型对应的封装类的基本使用要注意下，经常用来做数据转换。2.1.2　左加加和右加加的使用建议2.1.3　可以通过三目运算符来替代简单的if语句2.1.4　==和equals的区别2.1.5　基本数据类型、封装类和运算操作的面试题2.2　流程控制时的注意要点2.2.1　以if分支语句为例，观察条件表达式中的注意要点2.2.2　避免短路现象2.2.3　尤其注意while,do…while和for循环的边界值2.2.4　switch中的break和default2.2.5　流程控制方面的面试题2.3　需要单独分析的String对象2.3.1　通过String定义常量和变量的区别2.3.2　通过String来了解“内存值不可变”2.3.3　通过String和StringBuilder的区别查看内存优化2.3.4　会被不知不觉调用的toString()方法2.3.5　使用String对象时容易出错的问题点2.3.6　String相关的面试题2.4　论封装：类和方法2.4.1　类和实例的区别2.4.2　方法的参数是副本，返回值需要return2.4.3　通过合理的访问控制符实现封装2.4.4　静态方法和静态变量2.4.5　默认构造函数和自定义的构造函数2.5　论继承：类的继承和接口的实现2.5.1　从项目角度（非语法角度）观察抽象类和接口2.5.2　子类中覆盖父类的方法2.5.3　Java是单重继承，来看看老祖宗Object类的常用方法2.5.4　不能回避的final关键字2.5.5　要理解finalize方法，但别重写2.6　论多态：同一方法根据不同的输入有不同的作用2.6.1　通过方法重载实现多态2.6.2　方法重载和覆盖2.6.3　构造函数能重载但不能覆盖，兼说this和super2.6.4　通过多态减少代码修改成本2.7　面向对象思想的常用面试题及解析第3章　集合类与常用的数据结构3.1　常见集合类对象的典型用法3.1.1　通过数组来观察线性表类集合的常见用法3.1.2　以HashMap为代表，观察键值对类型的集合对象3.1.3　Set类集合的使用场景3.2　要学习线性表类集合，你必须掌握这些知识3.2.1　ArrayList和LinketList等线性表的适用场景3.2.2　对比ArrayList和Vector对象，分析Vector为什么不常用3.2.3　通过线性表初步观察泛型3.2.4　Set集合是如何判断重复的3.2.5　TreeSet、HashSet和LinkedHashSet的特点3.2.6　集合中存放的是引用：通过浅复制和深复制来理解3.2.7　通过迭代器访问线性表的注意事项3.2.8　线性表类集合的面试题3.3　关于键值对集合，你必须掌握这些基本知识3.3.1　通过Hash算法来了解HashMap对象的高效性3.3.2　为什么要重写equals和hashCode方法3.3.3　通过迭代器遍历HashMap的方法3.3.4　综合对比HashMap、HashTable及HashSet三个对象3.3.5　键值对部分的面试题3.4　Collections类中包含着操控集合的常见方法3.4.1　通过sort方法对集合进行排序3.4.2　把线程不安全变成线程安全的方法3.5　泛型的深入研究3.5.1　泛型可以作用在类和接口上3.5.2　泛型的继承和通配符3.6　集合部分的面试题及解析第4章　异常处理与IO操作 异常不是语法错误，它不是由程序员的疏忽造成的，而是一套保护机制。如果代码运行的环境出现了问题，如数据库服务器坏了，那么通过这套保护机制就可以捕获运行环境的异常并做出合理的异常处理动作。4.1　异常处理的常规知识点4.1.1　错误和异常4.1.2　异常处理的定式，try…catch…finally语句4.1.3　运行期异常类不必包含在try从句中4.1.4　throw,throws的Throwable的区别4.2　高级程序员需要掌握的异常部分知识点4.2.1　finally中应该放内存回收相关的代码4.2.2　在子类方法中不应该抛出比父类范围更广的异常4.2.3　异常处理部分的使用要点4.2.4　异常部分的面试题4.3　常见的IO读写操作4.3.1　遍历指定文件夹中的内容4.3.2　通过复制文件的案例解析读写文件的方式4.3.3　默认的输入输出设备与重定向4.3.4　生成和解开压缩文件4.3.5　对IO操作的总结4.4　非阻塞性的NIO操作4.4.1　与传统IO的区别4.4.2　NIO的三大重要组件4.4.3　通道（Channel）和缓冲器（Buffer）4.4.4　选择器（Selector）4.5　解析XML文件4.5.1　XML的文件格式4.5.2　基于DOM树的解析方式4.5.3　基于事件的解析方式4.5.4　DOM和SAX两种解析方式的应用场景4.6　Java IO部分的面试题第5章　SQL,JDBC与数据库编程5.1　项目中常用SQL语句的注意事项5.1.1　尽量别写select *5.1.2　count(*)和count（字段名）的比较5.1.3　insert的注意事项5.1.4　在delete中，可以通过in语句同时删除多个记录5.1.5　merge和update的比较5.1.6　关于存储过程的分析5.2　通过JDBC开发读写数据库的代码5.2.1　MySQL数据库中的准备工作5.2.2　编写读数据表的代码5.2.3　编写插入、更新、删除数据表的代码5.2.4　迁移数据库后，JDBC部分代码的改动5.3　优化数据库部分的代码5.3.1　把相对固定的连接信息写入配置文件中5.3.2　用PreparedStatement以批处理的方式操作数据库5.3.3　通过PreparedStatement对象防止SQL注入5.3.4　使用C3P0连接池5.3.5　数据库操作方面的面试题5.4　通过JDBC进行事务操作5.4.1　开启事务，合理地提交和回滚5.4.2　事务中的常见问题：脏读、幻读和不可重复读5.4.3　事务隔离级别5.5　面试时JDBC方面的准备要点第6章　反射机制和代理模式6.1　字节码与反射机制6.1.1　字节码和.class文件6.1.2　Class类是反射实现的语法基础6.2　反射的常见用法6.2.1　查看属性的修饰符、类型和名称6.2.2　查看方法的返回类型、参数和名称6.2.3　通过forName和newInstance方法加载类6.2.4　通过反射机制调用类的方法6.2.5　反射部分的面试题6.3　代理模式和反射机制6.3.1　代理模式6.3.2　有改进余地的静态代理模式6.3.3　在动态代理中能看到反射机制6.4　你已经掌握了一种设计模式，就应大胆地说出来6.4.1　如何在面试时找机会说出“代理模式”6.4.2　面试时如何说出对代理模式的认识第7章　多线程与并发编程7.1　线程的基本概念与实现多线程的基本方法7.1.1　线程和进程7.1.2　线程的生命周期7.1.3　通过extends Thread来实现多线程7.1.4　通过implements Runnable来实现多线程（线程优先级）7.1.5　多线程方面比较基本的面试题7.2　多线程的竞争和同步7.2.1　通过sleep方法让线程释放CPU资源7.2.2　Synchronized作用在方法上7.2.3　Synchronized作用在代码块上7.2.4　配套使用wait和notify方法7.2.5　死锁的案例7.2.6　Synchronized的局限性7.2.7　通过锁来管理业务层面的并发性7.2.8　通过Condition实现线程间的通信7.2.9　通过Semaphore管理多线程的竞争7.2.10　多线程并发方面的面试题7.3　对锁机制的进一步分析7.3.1　可重入锁7.3.2　公平锁和非公平锁7.3.3　读写锁7.4　从内存结构观察线程并发7.4.1　直观地了解线程安全与不安全7.4.2　从线程内存结构中了解并发结果不一致的原因7.4.3　volatile不能解决数据不一致的问题7.4.4　通过ThreadLocal为每个线程定义本地变量7.5　线程池7.5.1　通过ThreadPoolExecutor实现线程池7.5.2　通过Callable让线程返回结果7.5.3　通过ExecutorService创建4种类型的线程池7.6　多线程综合面试点归纳7.6.1　说出多线程的基本概念和常规用法7.6.2　说出多线程并发的知识点7.6.3　从线程内存角度分析并发情况第8章　让设计模式真正帮到你8.1　初识设计模式8.1.1　设计模式的分类8.1.2　面试时的常见问题（学习设计模式的侧重点）8.2　从单例模式入手来了解创建型设计模式8.2.1　单例模式的实现代码和应用场景8.2.2　通过工厂模式屏蔽创建细节8.2.3　简单工厂模式违背了开闭原则8.2.4　抽象工厂和一般工厂模式的区别8.2.5　分析建造者模式和工厂模式的区别8.3　了解结构型的设计模式8.3.1　简单的装饰器模式8.3.2　通过适配器模式协调不同类之间的调用关系8.4　了解行为型的设计模式8.4.1　通过迭代器了解迭代模式8.4.2　常见但大多数情况不用自己实现的责任链模式8.4.3　适用于联动场景的观察者模式8.5　设计模式背后包含的原则8.5.1　应用依赖倒转原则能减少修改所影响的范围8.5.2　能尽量让类稳定的单一职责原则8.5.3　继承时需要遵循的里氏替换原则8.5.4　接口隔离原则和最少知道原则8.5.5　通过合成复用原则优化继承的使用场景8.6　设计模式方面学习面试经验总结8.6.1　设计模式方面对于不同程序员的面试标准8.6.2　设计模式方面学习和面试的误区8.6.3　面试时如何展示设计模式的能力8.6.4　设计模式方面的面试题第9章　虚拟机内存优化技巧9.1　虚拟机体系结构和Java跨平台特性9.1.1　字节码、虚拟机、JRE和跨平台特性9.1.2　虚拟机体系结构9.1.3　归纳静态数据、基本数据类型和引用等数据的存储位置9.2　Java的垃圾收集机制9.2.1　分代管理与垃圾回收流程9.2.2　不重视内存性能可能会导致的后果9.2.3　判断对象可回收的依据9.2.4　深入了解finalize方法9.2.5　Java垃圾回收机制方面的初级面试题9.3　通过强、弱、软、虚4种引用进一步了解垃圾回收机制9.3.1　软引用和弱引用的用法9.3.2　软引用的使用场景9.3.3　通过WeakHashMap来了解弱引用的使用场景9.3.4　虚引用及其使用场景9.4　更高效地使用内存9.4.1　StoptheWorld、栈溢出错误和内存溢出错误9.4.2　内存泄漏的示例9.4.3　在代码中优化内存性能的具体做法9.4.4　调整运行参数，优化堆内存性能9.5　定位和排查内存性能问题9.5.1　什么情况下该排查内存问题9.5.2　通过JConsole监控内存使用量9.5.3　通过GC日志来观察内存使用情况9.5.4　通过打印内存使用量定位问题点9.5.5　出现OOM后如何获取和分析Dump文件9.5.6　出现内存问题该怎样排查9.6　内部类、final与垃圾回收9.7　在面试中如何展示虚拟机和内存调优技能9.7.1　从虚拟机体系结构引出内存管理的话题9.7.2　如何自然地引出内存话题9.7.3　根据堆区结构，阐述垃圾回收的流程9.7.4　进一步说明如何写出高性能的代码9.7.5　展示监控、定位和调优方面的综合能力第10章　通过简历和面试找到好工作10.1　哪些人能应聘成功10.1.1　公司凭什么留下待面试的简历10.1.2　技术面试官考查的要点及各要点的优先级10.1.3　项目经理和人事的考查要点10.1.4　入职后怎样进行背景调查10.2　怎样的简历能帮你争取到面试机会10.2.1　简历中应包含的要素，一个都别落下10.2.2　如何描述公司的工作情况10.2.3　描述项目经验的技巧10.2.4　投送简历时的注意要点10.3　面试时叙述项目经验和回答问题的技巧10.3.1　通过叙述项目技能引导后继问题10.3.2　结合项目实际回答问题10.4　面试前可以做的准备10.4.1　事先准备些亮点，回答问题时找机会抛出10.4.2　事先练习展示责任心和团队协作能力的方式10.4.3　准备提问环节的问题，以求给自己加分10.4.4　准备用英文回答问题，以求有备无患10.4.5　准备些常见刁钻问题的回答，不要临场发挥10.4.6　准备谈薪资的措辞10.5　项目经理级别面试的注意要点10.5.1　把面试官想象成直接领导10.5.2　在回答中展示良好的沟通和团队协作能力10.5.3　让面试官确信你会干得长久10.6　Offer和劳动合同中需要注意的要点10.7　最后祝大家前程似锦" }, { "title": "学习MyBatis基础知识", "url": "/2019/09/28/mybatis-intro/", "categories": "", "tags": "MyBatis, 数据库", "date": "2019-09-28 11:32:02 +0800", "snippet": "目录第1章 MyBatis入门 11.1 MyBatis简介 2与其他的ORM不同，MyBatis没有将Java对象与数据库表关联起来，而是将Java方法与SQL语句关联。SQL语句可以被动态生成。1.2 创建Maven项目 3Maven配置参考pom.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;properties&gt;&lt;!-- &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;--&gt;&lt;!-- &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;--&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;groupId&gt;io.zwt&lt;/groupId&gt; &lt;artifactId&gt;simple&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.6&lt;/source&gt; &lt;target&gt;1.6&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;1.3 简单配置让MyBatis跑起来 7 1.3.1 准备数据库 8创建一些测试数据库。 1.3.2 配置MyBatis 8配置文件mybatis-config.xml 参考&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name=\"io.zwt.simple.model\"/&gt; &lt;/typeAliases&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt; &lt;property name=\"\" value=\"\"/&gt; &lt;/transactionManager&gt; &lt;dataSource type=\"UNPOOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"xxxx\"/&gt; &lt;property name=\"password\" value=\"xxxx\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=\"io.zwt.simple.mapper\"/&gt;&lt;!-- &lt;mapper resource=\"io/zwt/simple/mapper/CountryMapper.xml\"/&gt;--&gt;&lt;!-- &lt;mapper resource=\"io/zwt/simple/mapper/UserMapper.xml\"/&gt;--&gt;&lt;!-- &lt;mapper resource=\"io/zwt/simple/mapper/RoleMapper.xml\"/&gt;--&gt;&lt;!-- &lt;mapper resource=\"io/zwt/simple/mapper/PrivilegeMapper.xml\"/&gt;--&gt;&lt;!-- &lt;mapper resource=\"io/zwt/simple/mapper/UserRoleMapper.xml\"/&gt;--&gt;&lt;!-- &lt;mapper resource=\"io/zwt/simple/mapper/RolePrivilegeMapper.xml\"/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 1.3.3 创建实体类和Mapper.xml文件 10实体类就普通POJO，Mapper.xml文件可以参考如下：&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"io.zwt.simple.mapper.CountryMapper\"&gt; &lt;select id=\"selectAll\" resultType=\"Country\"&gt; select id, countryname, countrycode from country &lt;/select&gt;&lt;/mapper&gt; 1.3.4 配置Log4j以便查看MyBatis操作数据库的过程 11Log4j挺有用的，方便，配置参考如下：#全局配置 log4j.rootLogger=ERROR, stdout #MyBatis 日志配置 log4j.logger.io.zwt.simple.mapper=TRACE #控制台输出配置 log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 1.3.5 编写测试代码让MyBatis跑起来 12单元测试，使用了JUnit 4.12，熟悉下，到时候可以用JUnit 5，刚开始的单元测试代码如下：package io.zwt.simple.mapper;import io.zwt.simple.model.Country;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.BeforeClass;import org.junit.Test;import java.io.IOException;import java.io.Reader;import java.util.List;public class CountryMapperTest { private static SqlSessionFactory sqlSessionFactory; @BeforeClass public static void init() { try { Reader reader = Resources.getResourceAsReader(\"mybatis-config.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); reader.close(); } catch (IOException ignore) { ignore.printStackTrace(); } } @Test public void testSelectAll() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { List&lt;Country&gt; countryList = sqlSession.selectList(\"selectAll\"); printCountryList(countryList); } finally { sqlSession.close(); } } private void printCountryList(List&lt;Country&gt; countryList) { for (Country country : countryList) { System.out.printf(\"%-4d%4s%4s\\n\", country.getId(), country.getCountryname(), country.getCountrycode()); } }}1.4 本章小结 14上手简单，感觉还不错的样子。第2章 MyBatis XML方式的基本用法 152.1 一个简单的权限控制需求 16搞个简单的RBAC做例子。2.1.1 创建数据库表 16 16创建了五个表：用户表、角色表、权限表、用户角色关系表和角色权限关系表。2.1.2 创建实体类 19 19实体类也是很常规的POJO，后期可以使用MBG生成。2.2 使用XML方式 21语句映射是特点。MyBatis 3.0 支持使用接口来调用方法。命名空间和方法id2.3 select用法 23在接口（例如UserMapper)中添加一个selectById方法，后面代码参考如下：package io.zwt.simple.mapper;import io.zwt.simple.model.SysRole;import io.zwt.simple.model.SysUser;import java.util.List;public interface UserMapper { /** * 通过id查询用户 * * @param id * @return */ SysUser selectById(Long id); /** * 查询全部用户 * * @return */ List&lt;SysUser&gt; selectAll(); /** * 根据用户 id 获取角色信息 * * @param userId * @return */ List&lt;SysRole&gt; selectRolesByUserId(Long userId);}接着在对应的Mapper.xml文件（例如UserMapper.xml）里面添加&lt;resultMap&gt;和&lt;select&gt;部分代码，参考如下：&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"io.zwt.simple.mapper.UserMapper\"&gt; &lt;resultMap id=\"userMap\" type=\"io.zwt.simple.model.SysUser\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"userName\" column=\"user_name\"/&gt; &lt;result property=\"userPassword\" column=\"user_password\"/&gt; &lt;result property=\"userEmail\" column=\"user_email\"/&gt; &lt;result property=\"userInfo\" column=\"user_info\"/&gt; &lt;result property=\"headImg\" column=\"head_img\" jdbcType=\"BLOB\"/&gt; &lt;result property=\"createTime\" column=\"create_time\" jdbcType=\"TIMESTAMP\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selectById\" resultMap=\"userMap\"&gt; select * from sys_user where id = #{id} &lt;/select&gt; &lt;select id=\"selectAll\" resultType=\"io.zwt.simple.model.SysUser\"&gt; select id, user_name userName, user_password userPassword, user_email uersEmail, user_info userInfo, head_img headImg, create_time createTime from sys_user &lt;/select&gt; &lt;select id=\"selectRolesByUserId\" resultType=\"io.zwt.simple.model.SysRole\"&gt; select r.id, r.role_name roleName, r.enabled, r.create_by createBy, r.create_time createTime from sys_user u inner join sys_user_role ur on u.id = ur.user_id inner join sys_role r on ur.role_id = r.id where u.id = #{userId} &lt;/select&gt;&lt;/mapper&gt;接口和XML通过将namespace的值设置为接口的全限定名称来进行关联的，接口中方法名和XML中的select标签的id属性值对应。2.4 insert用法 35 2.4.1 简单的insert方法 35基本使用 2.4.2 使用JDBC方式返回主键自增的值 38id 回写 2.4.3 使用selectKey返回主键的值 40不同数据库的selectKey使用方式不同2.5 update用法 422.6 delete用法 452.7 多个接口参数的用法 472.8 Mapper接口动态代理实现原理 502.9 本章小结 51第3章 MyBatis注解方式的基本用法 533.1 @Select注解 54 3.1.1 使用mapUnderscoreToCamelCase配置 55 3.1.2 使用resultMap方式 55 3.2 @Insert注解 58 3.2.1 不需要返回主键 58 3.2.2 返回自增主键 58 3.2.3 返回非自增主键 59 3.3 @Update注解和@Delete注解 593.4 Provider注解 603.5 本章小结 61第4章 MyBatis动态SQL4.1 if用法 644.1.1 在WHERE条件中使用if 644.1.2 在UPDATE更新列中使用if 684.1.3 在INSERT动态插入列中使用if 704.2 choose用法 724.3 where、set、trim用法 75 4.3.1 where用法 75 4.3.2 set用法 76 4.3.3 trim用法 77 4.4 foreach用法 78 4.4.1 foreach实现in集合 78 4.4.2 foreach实现批量插入 81 4.4.3 foreach实现动态UPDATE 84 4.5 bind用法 864.6 多数据库支持 864.7 OGNL用法 894.8 本章小结 90第5章 Mybatis代码生成器 915.1 XML配置详解 92 5.1.1 property标签 95 5.1.2 plugin标签 96 5.1.3 commentGenerator标签 97 5.1.4 jdbcConnection标签 99 5.1.5 javaTypeResolver标签 100 5.1.6 javaModelGenerator标签 101 5.1.7 sqlMapGenerator标签 102 5.1.8 javaClientGenerator标签 103 5.1.9 table标签 104 5.2 一个配置参考示例 1095.3 运行MyBatis Generator 111 5.3.1 使用Java编写代码运行 111 5.3.2 从命令提示符运行 113 5.3.3 使用Maven Plugin运行 115 5.3.4 使用Eclipse插件运行 117 5.4 Example介绍 1195.5 本章小结 124第6章 MyBatis高级查询 1256.1 高级结果映射 126 6.1.1 一对一映射 126 6.1.2 一对多映射 140 6.1.3 鉴别器映射 156 6.2 存储过程 159 6.2.1 第一个存储过程 162 6.2.2 第二个存储过程 164 6.2.3 第三个和第四个存储过程 166 6.2.4 在Oracle中使用游标参数的存储过程 168 6.3 使用枚举或其他对象 170 6.3.1 使用MyBatis提供的枚举处理器 170 6.3.2 使用自定义的类型处理器 172 6.3.3 对Java 8日期（JSR-310）的支持 175 6.4 本章小结 176第7章 MyBatis缓存配置 1777.1 一级缓存 1787.2 二级缓存 181 7.2.1 配置二级缓存 181 7.2.2 使用二级缓存 184 7.3 集成EhCache缓存 1877.4 集成Redis缓存 1907.5 脏数据的产生和避免 1917.6 二级缓存适用场景 1947.7 本章小结 194第8章 MyBatis插件开发 1958.1 拦截器接口介绍 1968.2 拦截器签名介绍 198 8.2.1 Executor接口 198 8.2.2 ParameterHandler接口 200 8.2.3 ResultSetHandler接口 201 8.2.4 StatementHandler接口 202 8.3 下画线键值转小写驼峰形式插件 2038.4 分页插件 206 8.4.1 PageInterceptor拦截器类 207 8.4.2 Dialect接口 212 8.4.3 MySqlDialect实现 216 8.5 本章小结 220第9章 Spring集成MyBatis 2219.1 创建基本的Maven Web项目 2229.2 集成Spring和Spring MVC 2279.3 集成MyBatis 2329.4 几个简单实例 234 9.4.1 基本准备 235 9.4.2 开发Mapper层（Dao层） 235 9.4.3 开发业务层（Service层） 238 9.4.4 开发控制层（Controller层） 240 9.4.5 开发视图层（View层） 242 9.4.6 部署和运行应用 245 9.5 本章小结 246第10章 Spring Boot集成MyBatis 24710.1 基本的Spring Boot项目 24810.2 集成MyBatis 25110.3 MyBatis Starter配置介绍 25310.4 简单示例 255 10.4.1 引入simple依赖 255 10.4.2 开发业务（Service）层 258 10.4.3 开发控制（Controller）层 259 10.4.4 运行应用查看效果 259 10.5 本章小结 260第11章 MyBatis开源项目 26111.1 Git入门 262 11.1.1 初次运行配置 262 11.1.2 初始化和克隆仓库 263 11.1.3 本地操作 265 11.1.4 远程操作 267 11.2 GitHub入门 269 11.2.1 创建并提交到仓库 269 11.2.2 Fork仓库并克隆到本地 272 11.2.3 社交功能 275 11.3 MyBatis源码讲解 27811.4 MyBatis测试用例 29011.5 本章小结 293附录 类型处理器（TypeHandler） 295" }, { "title": "学习Redis基础知识", "url": "/2019/09/27/redis-basics/", "categories": "", "tags": "Redis", "date": "2019-09-27 23:25:02 +0800", "snippet": "基础命令启动 Redisredis-server查看 Redis 是否启动redis-cliredis-cli --raw 中文不会乱码默认情况下相当于 redis-cli -h 127.0.0.1 -p 6379设置键值对：set myKey abc取出键值对：get myKeyRedis 数据类型StringHash HMSET HGETList LPUSH LRANGESET集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 $O(1)$。 SADD SMEMBERS zset(sorted set:) ZADDRedis 发布订阅Redis 事务Redis 脚本" }, { "title": "笔试题目回顾", "url": "/2019/09/26/exam-review/", "categories": "", "tags": "笔试面试", "date": "2019-09-26 21:30:02 +0800", "snippet": "多选一选择题和编程题JavaCore - 14题 下述哪些说法是正确的？（） A. 实例变量是用static关键字声明的 B. 方法变量在方法执行时创建 C. 实例变量是类的成员变量 D. 方法变量在使用之前必须初始化 这个题有点怀疑它的准确性，单选题又问“哪些说法是正确的”…… 在设计接口定义时，不用声明可能抛出的异常，可以把它放在具体实现类里处理。（） A. 错 B. 对 A 错的 定义一个接口使用的关键字是（） A. interface B. class C. extends D. implements A 在hibernate的多对多关系中，对inverse属性描述正确的是（） A. 关系双方都在&lt;set&gt;节点中设置inverse=”true”属性 B. 一方在&lt;set&gt;节点中设置inverse=”false”属性，另一方不设置 C. 关系双方都在&lt;set&gt;节点中设置inverse=”false”属性 D. 关系双方都在&lt;set&gt;节点中去掉inverse属性 很少直接用 hibernate 用Spring Data JPA，还要查一下文档。 下列代码的输出是什么？ int[] xxx = {10,20}; List&lt;String&gt; list = new ArrayList&lt;String&gt;(10); list.add(\"01\"); list.add(\"02\"); System.out.println(xxx.length + \",\" + list.size()); A. 2,2 B. 10,2 C. 2,10 D. 1,2 E. 编译错误 A 在spring中， applicationContext.xml如下： &lt;bean id=\"chinese1\" class=\"test1.Chinese\" &gt; &lt;!--设置注入：主要方式--&gt; &lt;constructor-arg&gt; &lt;ref local=\"steelAxe\"/&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=\"stoneAxe\" class=\"test1.StoneAxe\"&gt;&lt;/bean&gt;&lt;bean id=\"steelAxe\" class=\"test1.SteelAxe\"&gt;&lt;/bean&gt; Beantest.java如下： ApplicationContext ctx=new ClassPathxmlApplicationContext(\"applicationContext.xml\"); 以下说法错误的是（） A. ApplicationContext实例化时，将所有对象都实例化了 B. ApplicationContext实例化时，没有实例化Chinese对象 C. 所有类都只能生成一个对象（即支持单例模式） D. 当前的依赖注入方式时构造方法注入 spring 的 xml 配置方式也要熟悉啊，虽然现在基本用 Spring Boot，而且多采用 Java 配置。 JDBC中，一条SQL语句的执行结果存放在一个类的对象中，这个类时（） A. ResultSetMetaData B. Driver C. DatabaseMetaData D. ResultSet 关于持久化状态的说法正确的是（） A. 持久化状态只能由load方法转换过来； B. 持久化状态和游离状态的区别在于游离态没有对应的数据库记录； C. 持久化状态不能改变； D. 调用session的save方法可以改变变成持久化状态 JDBC中向MySQL发送并执行一个静态sql语句，应创建SQL语句对象的类是（） A. Statement B. ResultSet C. Connection D. Driver 下列说法中错误的是： A. 没有在方法定义中指明throws的方法，不可能抛出checked异常 B.程序不应该尝试捕捉处理Error C. 任何情况下，catch块都不应该将捕获的异常重新抛出 D. 异常的逃逸可能会导致线程的终止 System.out.println(Math.floor(-2.1)); 打印的结果为： A. 2.0 B. -2.0 C. -3.0 以下声明中，错误的是？ A. float f = 1; B. float f = 1.2; C. float f = (float)1.2; D. float f = 12.f; 设数组Array由以下语句定义int Array = new int[10];则数组的第一个元素的正确引用方法为： A. Array[] B. Array C. Array[0] D. Array[1] try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行？ A. 会执行，在return前执行。 B. 会执行，在return后执行。 C. 其余三种说法全错 D. 不会执行。 JSP - 4题 要设置某个JSP页面为错误处理页面，以下page指令正确的是 A. %@ page extends=\"javax.servlet.jsp.JspErrorPage\"% B. %@ page isErrorPage=\"true\"% C. %@ page info=\"error\"% D. %@ page errorPage=\"true\"% 在J2EE中，${2 + “4”}将输出（） A. 2 + 4 B. 6 C. 不会输出，因为表达式是错误的 D. 24 servlet的声明周期由一系列事件组成，把这些事件按照先后顺序排序，以下正确的是（） A. 实例化，加载类，初始化，请求处理，销毁 B. 加载类，实例化，初始化，请求处理，销毁 C. 加载类，实例化，请求处理，初始化，销毁 D. 加载类，初始化，实例化，请求处理，销毁 在JSP中，只有一行代码：&lt;%=' A' + ' B' %&gt;，运行将输出（） A. 131 B. AB C. A+B D. 错误信息，因为表式是错误 数据库 - 6题Oracle 如下语句： if v_num&gt;5 then\tv_example: =1:elsif v_num&gt;10 then\tv_example: =2:elsif v_hum&lt;20 then\tv_example: =3:elsif v_num&lt;39 then\tv_example: =4:else\tv_example: =5: 如果v_num=37, 则v_example的值是多少？ A. 4 B. 5 C. 1 D. 3 E. 2 MySQL 数据库恢复的重要依据是什么？ A. DD B. 文档 C. DBA D. 事务日志 用户经常查询雇员工资增长12%的情况，为提高性能需要建立一个索引，下列那条语句比较合适？ A. create bitmap index my_idx_1 on employee (salary) B. create unique index my_idex_1 on employee (salary) C. create index my_idx_1 on employee (salary * 1.12) D. create index my_idx_1 on employee (salary) reverse 在创建触发器时，哪一个语句决定了触发器是针对每一行执行一次，还是针对每个语句执行一次？ A. REFERENCING B. FOR EACH C. NEW D. ON MySQL的数值处理函数不包含（）。 A. Exp() B. Cot() C. Cos() D. Tan() MySQL中，以下哪个函数可以计算出日期之差？ A. DateDiff() B. DateSub() C. SubDate() D. DiffDate() 这题选 A 测试过了。SELECT DateDiff('2019-10-25', now()) 现在到 2019 年 10 月 25 日还有几天？ Web基础 - 6题 假设有以下的web.xml设定档： —- 多选题 &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;Login Required&lt;/web-resource-name&gt; &lt;url-pattern&gt;/delete.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;/delete.do&lt;/url-pattern&gt; &lt;http-method&gt;GET&lt;/http-method&gt; &lt;http-method&gt;POST&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt; &lt;role-name&gt;admin&lt;/role-name&gt; &lt;/auth-constraint&gt;&lt;/security-constraint&gt; 以下描述何者正确？ A. 其他角色可以使用GET、POST以外的HTTP方法存取 B. GET与POST方法只允许admin使用 C. admin角色只允许使用GET和POST方法 D. 只有admin角色才可以存取/delete.jsp与/delete.do HTML HTML中，target属性等于什么值，浏览器才会在一个新的、未命名的窗口中加载文档？ A. _blank B. _top C. _self D. _parent 在HTML页面中，CSS样式的属性名为background-image对应的style对象的属性名是 A. back-ground B. background C. image D. backgroundImage 表示放在每个定义术语词之前的HTML代码是？ A. &lt;dt&gt; B. &lt;dl&gt;&lt;/dl&gt; C. &lt;dd&gt; 哪个HTML标签用来包含外部的样式表？ A. &lt;STYLE&gt; B. &lt;INCLUDE&gt; C. &lt;LINK&gt; D. &lt;CSS&gt; 下列关于绝对路径的说法正确的一项是 A. 创建外部链接时，必须使用绝对路径 B. 使用绝对路径需要考虑源文件的位置 C. 在绝对路径中，如果目标文件被移动，则链接同时可用 D. 绝对路径时被链接文档的完整URL，不包含使用的传输协议 软件工程和计算机基础软件工程 程序的三种基本控制结构的共同特点是（）。 A. 不能嵌套使用 B. 仅用于自动控制系统 C. 只能用来描述简单程序 D. 单入口，单出口 计算机基础 32位处理器的最大虚拟地址空间为 A. 16GB B. 2GB C. 8GB D. 4GB Linux /dev/hdd3分区表示（） A. 第4块IDE硬盘的第3个分区，是扩展区 B. 第3块IDE硬盘的第3个分区，是主分区 C. 第1块IDE硬盘的第3个分区，是逻辑分区 D. 第4块IDE硬盘的第3个分区，是主分区或扩展分区 Linux管道符 A. &lt; B. &gt; C. &gt;&gt; D. | 数据结构与算法 设无向图G=(V, E)和G’ =(V’, E’)，如果G’是G的生成树，则下面的说法中错误的是（） A. G’ 为 G的连通分量 B. G’ 是 G的一个无环子图 C. G’ 为 G的子图 D. G’ 为G的极小连通图且 V = V’ 若长度为 $n$ 的线性表采用顺序存储结构，在其第 $i$ 个位置插入一个新元素的算法的时间复杂度为（）(1&lt;=i&lt;=n+1)。 A. $O(0)$ B. $O(n)$ C. $O(1)$ D. $O(n^2)$ 栈和队列的共同点是 A. 都是先进后出 B. 没有共同点 C. 都是先进先出 D. 只允许在端点处插入和删除元素 线性表的顺序存储结构和线性表的链式存储结构分别是 A. 顺序存取的存储结构、顺序存取的存储结构 B. 随机存取的存储结构、随机存取的存储结构 C. 任意存取的存储结构、任意存取的存储结构 D. 随机存取的存储结构、顺序存取的存储结构 测试理论-&gt;白盒测试 有以下C语言代码段：下列测试用例可以实现条件覆盖的是（）。 int cal(int x,int y,int z){\tint k = 0; if(x&gt;3 || y&gt;4){ k = x + y; } if(z &gt; 2){ k += z; } return k;} A. {x = 4、y = 4、z = 1} {x = 2、y = 5、 z = 3} B. {x = 4、y = 4、z = 3} {x = 2、 y = 3、z = 3} C. {x = 4、y = 4、z = 1} {x = 2、 y = 5、z = 2} D. {x = 4、y = 4、z = 4} {x = 4、 y = 4、z = 3} 有以下C语言代码段：下列测试用例可以实现判定覆盖的是（）。 void cal(intx, int y, int z){ int k=0,j=0; if(x&gt;3&amp;&amp;y&gt;4){ k=x+y; } if((x+y)&gt;5||z&gt;5){ j=x+y+z; }} A. {x = 3, y = 5, z = 5} {x = 2, y = 3, z = 5} B. {x = 4, y = 5, z = 5} {x = 3, y = 3, z = 5} C. {x = 4, y = 5, z = 5} {x = 2, y = 3, z = 5} D. {x = 4, y = 5, z = 5} {x = 2, y = 4, z = 5} 编程题按升序顺序输出begin到end闭区间的所有素数（在大于1的自然数中，除了1和它本身以外不再有其他因数）。无需添加主函数，试题采用 JDK 1.7 编译。样例一 输入 int begin 1 int end 10 输出（int[]) 2，3，5，7package com.baiyi;import java.util.*;public class TestUtils { /** * 按升序顺序获取闭区间内的素数列表 * * @param begin 开始值 * @param end 结束值 * @return 整型数组 */ public static int[] getPrimers(int begin, int end) throws Exception{ // 请在此添加代码 } // 若有需要，请在此处添加辅助变量、方法}" }, { "title": "关于OCA的一些想法", "url": "/2019/09/25/thoughts-on-oca/", "categories": "", "tags": "OCA", "date": "2019-09-25 23:40:36 +0800", "snippet": "为什么考OCA简单地说就是通过考试驱动学习，这样目的性强，学起来比较专注，高效。 针对考试的学习，有时候也是很有用的。引用下面的话： That’s not to say that preparing for the exam won’t help you become a better Java programmer! On the contrary, even the most experienced Java developers often claim that having to prepare for the certification exam made them for more knowledgeable and well-rounded programmers than they would have been without the exam-driven studying.不管怎么说，已经预约好考试了，一个月之后拿下考试，目标是 100% 的正确率。参考书的内容目录 Declaration and Access Control Object Orientation Assignments Operators Flow Control and Exception Strings, Arrays, ArrayList, Dates, and Lambdas阅读建议 留意那些 Two-Minute Drill 部分，多读几次。 重读所有 Exam Watch notes. 重做所有 Self Tests. 完成所有练习。 写很多很多 Java 代码。（不要用 IDE）可是后来我选择了 Scott 和 Jeanne 的书，后面的文章有提到。" }, { "title": "Spring及其周边关键词", "url": "/2019/09/25/spring-keywords/", "categories": "", "tags": "笔试面试", "date": "2019-09-25 19:19:36 +0800", "snippet": "全部 SpEL Spring 表达式语言 Framework open for extension close for modification. Portable Service Abstraction. Rest Template Rest 客户端 @PathVariable AOP AspectJ Pointcut @Aspect LoggingAspect Proceeding JointPoint javax.servlet.Filter Auto Config class path spring.factories @Configuration Spring Security Login/Logout Cross Site Request Forgery Logout Form HttpServletRequest Principal getUserPrincipal FilterChainProxy Authentication Session Fixation WebSecurityConfigurerAdapter UserDetailService.java UserDetails.java Authentication.java AuthenticationManager AuthenticationProvider DaoAuthenticationProvider DataSource JDBC logoutSucessHandler ControllerAdvice Principal Chain of Responsibility SLF4J(Simple Logging Facade for Java) log4j, logback, and JDK 1.4 logging org.springframework.core.env profile &amp; Properties &amp; Context Logger, Environment @Around @EnableConfigurationProperties Apache Commons commons lang LiquibaseProperties ApplicationProperties InitializatingBean @Configuration @EnableAsync JSR-107 JCACHE javax.persistence.EntityManagerFactory DateTimeFormatterRegistrar Jackson 处理 JSON AngularCookieLocaleResolver Logstash Logback addFilterBefore Servlet Filter HttpSecurity 在 Spring Security 中 sessionCreationPolicy STATELESS authorizedRequests ExpressionInterceptUrlRegistry AntPathMatcher Ant风格的路径匹配 SecurityConfigurerAdapter DefaultSecurityFilterChain, HttpSecurity InitializingBean openSSL rand -based64 64 UserMapper MapStruct DTO stream暂时做个记录入口可能每个点都可以继续。" }, { "title": "在数组中找到众数", "url": "/2019/09/25/exercise/", "categories": "", "tags": "笔试面试", "date": "2019-09-25 11:31:36 +0800", "snippet": "赛题内容给定一个大小为 $n$ 的数组，找到其中的众数。众数是指在数组中出现次数大于 $\\lfloor n/2 \\rfloor$ 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。测试样例：样例输入：99 9 9 9 8 8 8 8 9样例输出：9思考过程Java实现public class Mode { }最后" }, { "title": "男女位置最小交换次数", "url": "/2019/09/24/minimum-swap-times/", "categories": "", "tags": "笔试面试", "date": "2019-09-24 23:51:36 +0800", "snippet": "题目幼儿园的小朋友准备上体育课，老师让他们手牵手排成一列。现在老师需要通过让相邻的小朋友交换位置来形成新的一列，实现男生和女生分开，也就是在这一列中，除了中间的唯一一对小朋友是男生和女生牵手，其余的小朋友只可以牵同性的手。请补齐下面的代码，输出最小的交换次数。示例：输入：{“男”，“女”，“男”，“女”}，输出：1。public class Kindergarten {\tpublic Integer childrenPartition(String[] children){\t\t//todo:\t}}思考过程两次冒泡，一次正序，一次逆序，分别记录交换次数，取较小值。Java实现import java.util.Arrays;public class Kindergarten { private Integer childrenPartition(String[] children) { // 正序交换次数 int a; // 逆序交换次数 int b; // 创建长度等于人数的整型数组 int[] forward = new int[children.length]; // 1 代表“男”，0 代表“女”，存入整型数组 for (int i = 0; i &lt; children.length; i++) { forward[i] = children[i].equals(\"男\") ? 1 : 0; } // 克隆一个用来做反向数组 int[] backward = forward.clone(); // 将数组反转 for (int start = 0, end = forward.length - 1; start &lt; end; start++, end--) { int temp = backward[end]; backward[end] = backward[start]; backward[start] = temp; } System.out.println(\"forward:\"); System.out.println(Arrays.toString(forward)); a = bubble(forward); System.out.printf(\"swap times: %d\\n\", a); System.out.println(\"------------------------------\"); System.out.println(\"backward:\"); System.out.println(Arrays.toString(backward)); b = bubble(backward); System.out.printf(\"swap times: %d\\n\\n\", b); System.out.print(\"最少交换次数：\"); return Math.min(a, b); } private int bubble(int[] array) { int length = array.length; int temp, count = 0; // 对较小的数进行冒泡排序，并记录交换次数 for (int i = 0; i &lt; length - 1; i++) { for (int j = 1; j &lt; length - i; j++) { if (array[j - 1] &gt; array[j]) { temp = array[j - 1]; array[j - 1] = array[j]; array[j] = temp; count++; } } } return count; } public static void main(String[] args) { Kindergarten kindergarten = new Kindergarten(); String[] children = new String[]{\"男\", \"女\", \"男\", \"女\", \"女\", \"男\", \"男\", \"男\", \"女\", \"男\"}; System.out.println(kindergarten.childrenPartition(children)); }}最后练习，代码未必最优。" }, { "title": "一次刺激的面试和笔试", "url": "/2019/09/21/exciting-interview/", "categories": "", "tags": "笔试面试", "date": "2019-09-21 00:00:00 +0800", "snippet": "前言那是经历的第一次面试，绿米联创 HR 面，2019 年 9 月 20 日下午 3 点，在华南理工大学（大学城校区）的图书馆底下的 O’Clock Coffee 咖啡厅。本来此前一天（2019 年 9 月 19 日）晚上 7 点参加了绿米联创的宣讲会，紧接着是 8 点多左右进行线下笔试，笔试时间为一个小时。题目难度中等，其中有“关灯开灯”问题（同 TCL 第 21 题），然后又有经典的输入网站按下回车键到浏览器显示网页经过了什么过程。还有一题是两个人轮流取硬币，最先取完的为胜…… 这类型题目，以前在看 BBC 一个关于算法的纪录片（Algorithms - The Secret Rules of Modern Living - BBC documentary）时候有看到，但是没有记住其中道理，因为到时已经有人翻译制作了中文字幕，所以我就没有翻译了，结果就是印象不够深刻。那晚宣讲会加线下笔试，错过了腾讯的在线笔试，在一个没什么灯光的路边阶梯坐下，抱着笔记本，摄像头监考，光线不好，操作不了，而且后台综合的试题全部是编程题，在剩余的不到 20 分钟内根本就不可能完成，直接提交了空白卷，连自信心被打击的机会都没有了，题目印象也没有，因为根本看不见什么，早知道找个光线好的教室坐着什么的，但是第一次去到华工校园，不熟悉环境。原本约的下午 3 点开始的面试，提前了十多分钟开始，持续了大概半小时。不过面试结束之后我赶紧拿出笔记本，坐到旁边的桌开始做网易的在线笔试题，这也是下午 3 点开始的。被面试占用了一些时间，后面就不够时间做在线笔试题了，最后十几分钟电池没电直接关机（因为调成高性能状态，且不设置电量少提示）。奇怪我也没有直接放弃，虽然知道最后也是么有办法做完和有机会通过笔试，但还是想办法继续完成考试。当时就走进咖啡厅里面询问是否有插座可以接电，还好有个位置可以充电接着完成考试。下午 5 点结束了网易笔试，为了节省时间就没去食堂吃饭，在咖啡厅吃个三明治算了，因为接下来 7 点还有商汤科技的在线笔试。商汤的笔试就比较针对 Java 了，有选择题、填空题和简答题。这次也是使用牛客网的考试系统，但是监考过程比腾讯和网易的多了一个手机小程序监控的步骤，还要录屏的。商汤试题刚开始的选择题涉及比较多数据结构的内容，二叉树什么的，填空题有涉及看代码写输出结果的。最后简答题好像有 9 个题，比较多 x 与 y 的区别之类的问题，例如 session 与 cookie 的区别，ArrayList 与 LinkedList 的区别，手写单例设计模式，常见的设计模式，Java 的原子类作用和原理， 还有关于 Java 虚拟机内存模型的， volatile 关键字的作用，后面的没时间，没有写完，中间网络出现点问题，中断一会。但也尽力做，开始有点感觉了，继续加油。题目回顾回顾一些错题，包括日常练习和在线笔试的。日常练习 一个以”.java”为后缀的源文件： 只能有一个与文件名相同的 public 类，可以包含其他非 public 类（不考虑内部类）。 基础概念要清晰。 关于 equals() 和 hashcode() 的，对象属性之类的东西。下面论述正确的是（）？ A. 如果两个对象的 hashcode 相同，那么它们作为同一个 HashMap 的 key 时，必然返回同样的值 B. 如果 a, b 的 hashcode 相同，那么 a.equals(b) 必须返回 true C. 对于一个类，其所有对象的 hashcode 必须不同 D. 如果 a.equals(b) 返回 true，那么 a,b 两个对象的 hashcode 必须相同答案是 D 解释如下：如果两个对象的 hashcode 相同，那么它们作为同一个 HashMap 的 key 时，必然返回同样的值。如果 a, b 的 hashcode 相同，那么 a.equals(b) 必须返回 true，对于一个类，其所有对象的 hashcode 必须不同，如果 a.equals(b) 返回 true，那么 a,b 两个对象的 hashcode 必须相同。 关于计算机网络如果在一个建立了 TCP 连接的 socket 上调用 recv 函数，返回值为 0，则表示（） A. 对端发送了一段长度为 0 的数据 B. 对端关闭了连接 C. 还没有收到对端数据 D. 连接发生错误基础，对于 TCP 协议的认识，解阻塞与非阻塞 recv 返回值没有区分，都是 &lt; 0 出错 = 0 连接关闭 &lt; 0 接收到数据太小 关于 JavaBean 的，还有一些 JSP，旧的技术还没有完全淘汰，有时候有必要了解一下。笔试回顾题目原表述和空间要求等已经记不清，凭回忆和草稿恢复题目如下：输入 $T$ 组数，格式为第 1 行是组数 $T$ ，余下每行 1 个数 $x$ ，对每个 $x$ 求输出对应的 $n$ ，满足 $x \\leq S(n)$ 的最小值。其中 $S(n)$ 表示 $n$ 的十进制各位之和， $1 \\leq T \\leq 10$, $1 \\leq x \\leq 10^5$。示例输入 2 13 18示例输出 49 99Java实现import java.util.Scanner;public class Exam1 { public static void main(String[] args) { Scanner stdIn = new Scanner(System.in); int T; // 组数 do { System.out.print(\"请输入数据组数T(1 &lt;= T &lt;= 10)：\"); T = stdIn.nextInt(); } while (T &lt; 1 || T &gt; 10); int[] x = new int[T]; // 输入的x for (int i = 0; i &lt; T; i++) { do { System.out.printf(\"请输入第%2d 组的 x(1 &lt;= x &lt;= 100000)：\", (i + 1)); x[i] = stdIn.nextInt(); } while (x[i] &lt; 1 || x[i] &gt; 100000); } for (int number : x) { System.out.print((number % 9 == 0) ? \"\" : (number % 9)); for (int i = 0; i &lt; number / 9; i++) { System.out.print(9); } System.out.println(); } }}思考过程考试的时候初步想法，输入数据组数 $T$ ，接下来每组的数保存在长度为 $T$ 的整型数组里面。 这只是输入数据的保存，接着就是核心算法部分，思考这个算法要做什么，要寻找什么规律，最终达到题目要求。我是这样想的，首先实现对于每个 $x$ 可以找到满足条件的 $n$ ，接着再考虑怎么知道这个 $n$ 是最小的，判断的依据是什么？功能实现完善了，再考虑优化时间复杂度或空间复杂度。初步来看，随着 $x$ 增大，符合条件的 $n$ 将会是一个很大的数，位数肯定超过 Java 支持的数据类型上限，这就是要考虑到的问题。 但可以先从小数入手，先实现在 $x$ 较小的情况下可以运行的程序，接着优化，添加可以处理大数的操作，使得在题目要求的数值范围内可以有效运行。最后才是细化优化。后来观察了一下这些数字，发现规律很明显，不用很复杂的算法就可以实现了。首先题目要求对于给定的 $x$ 要找到满足 $x \\leq S(n)$ 的 $n$ 的最小值，所以最小就是 $x = S(n)$ 的情形。列出一些 $x$ 和 对应的 $n$ 如下： 1\t…\t8\t9\t10\t11\t12\t…\t28 1\t…\t8\t9\t19\t29\t39\t…\t1999发现满足要求的都是最高位是 1~8 其余位数全部是 9 的数字（不然不可能最小）。所以问题就转化成求 $n$ 的最高位是什么，余下位数共有多少个 9 ，即最高位是 $n$ % 9, 余下有 $n$ / 9 个 9。 因为 $x = 10^5$ 的时候，满足条件的 $n$ 长度是 “最高位的 1 ” + “ 后面11111 个 9 ”， 长度达到 11112 位。 因此用打印字符串作为结果输出。时间复杂度$O(n)$。总结这题和轮流取硬币的那题都涉及到余数相关的性质，感觉有趣，平时解题思维锻炼得少，有时候会将简单问题复杂化，要多练习，希望有提高。最后今天应该报名 Oracle 的 Oracle Certified Java Programmer（1Z0 - 808）, 然后预约 2019 年 10 月 25 日上午 9 点的考试。今天开始到 2019 年底，还有 100 天，开始百日刷题计划。" }, { "title": "Java是值传递", "url": "/2019/09/05/java-is-pass-by-value/", "categories": "", "tags": "Java", "date": "2019-09-05 00:00:00 +0800", "snippet": "Java是值传递在一本Java面试参考书里面看到一个题目，有如下代码：public class Test { private void change(String str, char[] ch) { str = \"test ok\"; ch[0] = 'g'; } public static void main(String[] args) { String str = new String(\"good\"); char[] ch = {'a', 'b', 'c'}; Test ex = new Test(); ex.change(str, ch); System.out.print(str + \" and \"); System.out.print(ch); }}问上面程序运行的结果是（）A. good and abcB. good and gbcC. test ok and abcD. test ok and gbc 答案是 B这个题目主要考察Java语言中传参方式以及不可变类的知识。基本上对于String类是不可变的(Immutable)没有什么疑问，但关于Java的传参方式究竟是值传递还是引用传递的认识还不够清晰，所以在下文就要搞清楚这个知识点。其实Java都是值传递的，没有什么好说了，引用类型，只不过是传递了引用变量(reference variable)的值而已，说到底还是值传递，不存在引用传递的说法。这文章到这里可以结束了。" }, { "title": "编译器构造—编译", "url": "/2019/07/10/compilation/", "categories": "", "tags": "编译器构造", "date": "2019-07-10 00:00:00 +0800", "snippet": "编译编译器编译器就是将用高级语言编写的源程序编译成为对应的低级语言（例如机器语言）的程序。编程语言编程语言由三方面定义：1.标记（token）或词位。例如关键字if，操作符+，常量如4和'c'，还有标识符。2.语法描述和语言结构。例如类、方法、语句和表达式等。3.语义描述。描述各种语言结构的意义。机器语言机器语言就是机器的指令集，面向机器，更适合被机器解析。机器的指令集及其运行方式通常称为机器的体系结构。那么常见的机器语言就是某些体系结构的机器的指令集了，例如Intel i386系列的，属于复杂指令集计算机（CISC）。另外还有MIPS和ARM等精简指令集计算机（RISC）。除了这些实在的处理器的机器语言之外，Java的虚拟机（JVM）体系结构也是一种机器语言，称为虚拟机并不是因为不存在，而是因为它是用软件实现的。在这个系列里面，我们主要关注JVM的机器语言。为什么学习编译器1.编译器是比较大型的程序，学习规模较大的程序开发有好处。2.编译器应用到了很多已经学过的内容：数组、列表、队列、栈、树、图、maps、正则表达式、有限状态自动机、上下文无关语法还有解析器、递归以及模式。将这些知识都用起来是很有趣的。3.会更加熟悉要编译的语言（也就是Java）4.会学习到很多关于目标机器的知识，这里主要是关于JVM的。5.可以将编译器的技术应用于处理XML文件。编译器是如何工作的——编译的过程前端 分析源语言的输入程序的含义； 源语言相关的（依赖于源语言）； 可以细分为一系列分析阶段，如下图： 扫描器作用是将字符串分解成标记串：标识符、字面量、保留字、操作符和分隔符等。解析器是按照一定的语法规则将标记串生成对应的抽象语法树，作用是让隐式语法（源程序）变成显式语法（抽象语法树）。语义分析涉及到建立符号表（symbol table）、确定类型、类型检查，有时候还涉及一些存储分析，例如确定变量的地址和偏移量的时候。如果一门语义允许引用一个在后面才声明的变量，那么语义分析阶段至少要过两遍。后端 将中间表示转换成目标机器程序 依赖于目标语言（与源语言无关） 可以进一步划分成一些了综合阶段，如下图所示： 代码生成阶段负责选择生成哪些机器指令。peephole即窥视孔，peephole optimizer是窥孔优化，是一种局部优化方式，编译器仅仅在一个基本块或者多个基本块中，针对已经生成的代码，结合CPU自己指令的特点，通过一些认为可能带来性能提升的转换规则，或者通过整体的分析，通过指令转换，提升代码性能。别看这些代码转换很局部，很小，但可能会带来很大的性能提升。最后对象阶段将生成的模块链接起来称为可执行程序。“中端”有时候前端和后端之间会存在“优化器”，可理解为“中端”，如图：（勘误：上图左端文字应为“源语言程序”）分离的好处 降低实现的复杂度。 前后端分离可以让分别独立的团队同时开发不同的部分，缩短整体实现耗时。 促进代码复用。编译到虚拟机Java编译器javac产生适用于JVM的“字节码”，字节码也属于一种中间表达形式（IR），在本书中，我们会编译一个Java语言的子集(j--）。学习在针对JVM的编译器的过程还缺少了一个方面的经验，那就是关于寄存器分配的学习，因为JVM是基于栈（Stack-based）的虚拟机，没有寄存器。关于j--到JVM的编译器j--编译器的组织编译器的主入口是Main，它会读入一系列参数，然后创建一个扫描器对象用于扫描标记（Token），接着解析器对输入的源语言程序进行解析，并构造抽象语法树。抽象语法树的每个节点具有特定的类型，反映了背后的语法结构或支持的操作。例如类型JCompilationUnit在抽象语法树的根部，表示被编译的程序。它有子树，表示包名，导入的类型的列表，以及声明的类型。在抽象语法树中的一个类型为JMultiplyOp的对象，表示乘法操作。它的两棵子树分别表示两个操作数。在树的叶子可以发现有JVariable对象和表示字面常量的对象。抽象语法树的每个节点定义了三个方法，每个方法在节点上执行某个任务，并递归地处理其子树。 preAnalyze(Context context) 只在抽象语法树顶点附近的节点有定义，因为j--没有实现内部类。预分析主要处理导入的类型、定义的类名称、以及类成员头部（方法头和字段），这是很有必要的，因为方法体可能引用后面定义输入的名称。上下文参数是一连串Context（或其子类）对象，表示编译时符号表中声明的变量及其定义。 analyze(Context context)在抽象语法树的所有节点都有定义。当在某个节点调用这个方法，它会声明在符号表中的名称，检查类型（在符号表中寻找名称的类型），并且将局部变量转化成一个方法的运行时本地栈帧，即局部变量存储的地方。 codegen(CLEmitter output)用于生成该节点的Java虚拟机代码，并递归地调用生成其子树的代码。output参数是CLEmitter类型对象，它是生成的.class文件的一种抽象。扫描器解析器syntax directed, recursive descentcompilationUnit ::= [package qualifiedIdentifier;]{import qualifiedIdentifier;}{typeDeclaration} EOF认为不变吗？测试一下，改变文件内容后，url是否更新。抽象语法树类型符号表preAnalyze()和analyze()栈帧codegen()j--编译器代码强化j--编写测试修改词法和语法修改扫描器修改解析器语义分析和代码生成测试更改本书的组织形式" }, { "title": "不同领域的对数记法差异", "url": "/2019/06/26/log-notation/", "categories": "", "tags": "微积分", "date": "2019-06-26 00:00:00 +0800", "snippet": "The notation $x = \\ln y$ is a shorthand for the natural logarithm to the base $e$: $x = \\log_{e} y$ . This notation is used throughout mathematics, science, and engineering.The shorthand notation $x = \\log y$ is sometimes used when the base $b$ remains fixed and is understood from the context. The “understood” base, however, can vary from place to place: $x = \\log y$ often means $x = \\ln y$ in mathematics texts. $x = \\log y$ often means $x = \\lg y$ in science and engineering texts. $x = \\log y$ often means $x = \\log_{2} y$ in computer science texts. Be careful when reading or using $x = \\log y$ ." }, { "title": "普林斯顿微积分读本", "url": "/2019/06/21/the-calculus-lifesaver/", "categories": "", "tags": "微积分", "date": "2019-06-21 00:00:00 +0800", "snippet": " 最后这些日子，尽量全身心投入学习The Calculus Lifesaver讲解详细的书适合我​\t《普林斯顿微积分读本》是能看的进去的微积分书籍，不知道中文版是否也是这样的情况。这种讲人话的书，读起来不觉乏味。 余小乔 2011-10-30读起来就像是朋友在帮你复习，书中没有严格的证明，但是读完你都能知道大概是怎么一回事，相反很多初级教材里面一上来就给你精确却刻板的定义和证明，实际上会把学生的信心乱棍打死。如果能在初学国内的教材的时候，同时参考这本书，效果一定会非常好。当然更推荐的是一开始就用国外的教材。想起我学微积分历史，眼泪就掉下来。。。 0 有用 松鼠奥利奥 2019-05-04覆盖了单变量微积分、无穷级数、常系数线性微分方程，不覆盖曲面积分等。很多“说人话”的直观解释，例如用图形化的黎曼和解释定积分/反常积分，用线性化和中值定理推广来解释泰勒/麦克劳林级数。再就是做题的方法论比较多（微积分做题指南），有的只有公式结论。严肃的数学语言和证明不多，甚至一些证明放到了附录（其中对极限 ε-δ 语言的解释很精彩）。脚注比较负责。看起来适合热身、备考、回顾，或者作为辅助理解的“读… (展开) 17 有用 Satan 2017-11-07中国人就是太严肃，缺乏幽默感，这本书的名字是save your ass ,什么微积分读本，读本你个鬼啊。 22 有用 [已注销] 2014-07-23同济版高数讲了好久没讲懂的题，这本书一讲就懂了，力荐！ 1 有用 [已注销] 2011-09-25hiahia作者可爱的~ 其实是男盆友的书,看了里面教画函数的导数图像用的登山者…好用哇​\t有人说习惯国内教程的简单粗暴，而我发现我一直都不能习惯。" } ]
