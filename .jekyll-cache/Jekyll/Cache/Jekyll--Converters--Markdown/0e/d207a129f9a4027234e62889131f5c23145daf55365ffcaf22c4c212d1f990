I"<h2 id="æ¶ˆæ¯é€šä¿¡">æ¶ˆæ¯é€šä¿¡</h2>

<p><img src="/img/messaging.png" alt="messaging" /></p>

<p>æœ€ç®€å•çš„æ¶ˆæ¯æœºåˆ¶ï¼Œä»Aç‚¹åˆ°Bç‚¹ï¼Œé€šè¿‡æŸç§ä¿¡é“ä¼ é€’æ¶ˆæ¯ï¼Œå¯ä»¥ä½¿ä¸€ä¸ªç®€å•çš„å‡½æ•°è°ƒç”¨ï¼Œä¸€ä¸ªsocketè¿æ¥ï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªHTTPè¯·æ±‚ã€‚ä¸»è¦ç›®çš„æ˜¯å‘é€ç«¯å‘é€æ¶ˆæ¯ç»™æ¥æ”¶ç«¯æ¶ˆè´¹ã€‚</p>

<h3 id="æ¶ˆæ¯é€šä¿¡ä½¿ç”¨åœºæ™¯">æ¶ˆæ¯é€šä¿¡ä½¿ç”¨åœºæ™¯</h3>

<p>ä¸‹é¢åˆ—å‡ºä¸€äº›æ¶ˆæ¯é€šä¿¡å¸¸è§çš„ä½¿ç”¨åœºæ™¯ï¼š</p>

<h4 id="å¯é é€è¾¾">å¯é é€è¾¾</h4>

<p>é€šå¸¸éœ€è¦ä¸€äº›æ¶ˆæ¯ç¡®è®¤æœºåˆ¶ï¼Œå¦‚æœä¸­é—´æœ‰ä¸ªBrokerï¼Œæ¶ˆæ¯ç”Ÿäº§è€…è¦é€šè¿‡ä¸€äº›ç¡®è®¤ï¼Œäº†è§£Brokerç¡®å®æ”¶åˆ°äº†æ¶ˆæ¯ã€‚åŒç†åœ¨æ¶ˆè´¹è€…æ®µä¹Ÿéœ€è¦ç»™Brokerç¡®è®¤å·²ç»æ”¶åˆ°æ¶ˆæ¯ã€‚é€šå¸¸æ”¯ä»˜ã€è‚¡ç¥¨äº¤æ˜“ç­‰ç³»ç»Ÿä¼šä½¿ç”¨è¿™ç§æ¨¡å¼ã€‚<!--more--></p>

<h4 id="è§£è€¦">è§£è€¦</h4>

<p>æŒ‰ç…§ä¸šåŠ¡é¢†åŸŸè§£è€¦ï¼Œä½¿ç”¨bounded context.</p>

<h4 id="æ‰©å±•å’Œé«˜å¯ç”¨">æ‰©å±•å’Œé«˜å¯ç”¨</h4>

<p>å¤šä¸ªBrokeræ‰©å±•ã€‚</p>

<h4 id="å¼‚æ­¥">å¼‚æ­¥</h4>

<p>å¼‚æ­¥æ¶ˆæ¯ç¡®ä¿å“åº”æ€§ï¼Œresponsiveness</p>

<h4 id="äº’æ“ä½œæ€§">äº’æ“ä½œæ€§</h4>

<p>é‡‡ç”¨Brokeræ¶æ„ï¼Œå®ç°AMQPç­‰åè®®ã€‚</p>

<h3 id="æ¶ˆæ¯æ¨¡å¼å’Œè®¾è®¡æ¨¡å¼">æ¶ˆæ¯æ¨¡å¼å’Œè®¾è®¡æ¨¡å¼</h3>

<h4 id="ç‚¹åˆ°ç‚¹">ç‚¹åˆ°ç‚¹</h4>

<p><img src="/img/point-to-point.png" alt="point-to-point" /></p>

<h4 id="å‘å¸ƒ-è®¢é˜…">å‘å¸ƒ-è®¢é˜…</h4>

<p><img src="/img/pub-sub.png" alt="pub-sub" /></p>

<h4 id="è®¾è®¡æ¨¡å¼">è®¾è®¡æ¨¡å¼</h4>

<p>A design patterns is a solution to a commonly known problem in the software design. By the same token, messaging patterns attempt to solve problems with messaging designs.</p>

<p>â€‹	You will learn about the implementation of the following patterns during the course of this book, so I want to list them here with simple definitions to introduce them:</p>

<ul>
  <li><em>Message type patterns:</em> Describe different forms of messaging, such as string(maybe plain text, JSON and/or XML), byte array, object, etc.</li>
  <li><em>Message channel patterns:</em> Determine what kind of a transport(channel) will be used to send a message and what kind of attributes it will have. The idea here is that the producer and consumer know how to connect to the transport(channel) and can send and receive the message. Possible attributes of this transport include a request-reply feature and a unidirectional channel, which you will learn about very soon. One example of this pattern is the point-to-point channel.</li>
  <li><em>Routing patterns:</em> Describe a way to send message between producer and consumers by providing a routing mechanism(filtering thatâ€™s dependent on a set of conditions) in an integrated solution. That can be accomplished by programming, or in some cases, the messaging system(the broker) can have these capabilities(as with RabbitMQ).</li>
  <li><em>Service consumer patterns:</em> Describe how the consumers will behave when messages arrive, such as adding a transactional approach when processing the message. There are frameworks that allow you to initiate this kind of behavior(like the Spring Framework, which you do by adding the @Transactional, a transaction-base abstraction).</li>
  <li><em>Contract patterns:</em> Contracts between the producer and consumer to have simple communications, such as when you do some REST calls, where you call a JSON or XML message with fields.</li>
  <li><em>Message construction patterns:</em> Describe how a message is created so it can travel within the messaging system. For example, you can create an â€œenvelopeâ€ that can have a body(the actual message) and some headers(with a correlation ID or a sequence or maybe a reply address). With a simple web request, you can add parameters or headers and the actual message becomes the body of the request, making the whole request part of the construction pattern. The HTTP protocol allows for that kind of communication (messaging).</li>
  <li><em>Transformation patterns:</em> Describe how to change the content of the message within the messaging system. Think about a message that requires some processing and needs to be enhanced on the fly, such as a content enricher.</li>
</ul>

<p>As you can see, these patterns not only describe the messaging process but some of them describe how to handle some of the common use cases you saw earlier. Of cause, there are a lot more messaging patterns.</p>

:ET