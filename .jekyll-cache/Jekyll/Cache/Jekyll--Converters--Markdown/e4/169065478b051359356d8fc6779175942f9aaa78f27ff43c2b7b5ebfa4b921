I"Ö<h3 id="å…ˆå›é¡¾åŸºæœ¬æ¦‚å¿µ-overloading-and-overriding">å…ˆå›é¡¾åŸºæœ¬æ¦‚å¿µ Overloading and Overriding</h3>

<p>ä¸»è¦éœ€è¦æ€»ç»“çš„æ˜¯:</p>

<p>â€‹	When multiple overloaded methods are present, Java looks for the closest match first. It tries to find the following:</p>

<ul>
  <li>Exact match by type</li>
  <li>Matching a superclass type</li>
  <li>Converting to larger primitive type</li>
  <li>Converting to an autoboxed type</li>
  <li>Varargs</li>
</ul>

<p>For overriding, the overridden method has a few rules:</p>

<ul>
  <li>The access modifier must be the same or more accessible.</li>
  <li>The return type must be the same or a more restrictive type, also known as <em>covariant return types</em>.</li>
  <li>If any checked exceptions are thrown, only the same exceptions or subclasses of those exceptions are allowed to be thrown.</li>
</ul>

<p>The method must not be static. (If they are, the method is hidden and not overridden.)</p>

<h4 id="å…³äº-instanceof-æ“ä½œç¬¦null-çš„æƒ…å†µnull-ä¸æ˜¯-object">å…³äº instanceof æ“ä½œç¬¦ï¼Œnull çš„æƒ…å†µï¼Œnull ä¸æ˜¯ Object.</h4>

<p>instanceof ä¸èƒ½æ¯”è¾ƒæ²¡æœ‰ä»»ä½•ç»§æ‰¿å…³ç³»çš„ç±»ã€‚ è€Œæ¥å£å¯ä»¥ï¼Œå› ä¸ºæ¥å£å¯ä»¥è¢«å®ç°ã€‚</p>

<p>ç„¶åå…¥æ­£é¢˜:</p>
:ET